(ns pallet.action-plan
  "An action plan contains actions for execution.

   The action plan is built by executing a phase function. Each phase function
   calls actions which insert themselves into the action plan.

   The action plan is transformed to provide aggregated operations, and to
   resolve precedence relations between actions.

   A translated plan is executed by passing an executor, which is a map
   from action type to function.  The executor functions are called with the
   result of evaluating the action with it's arguments.

   Note this is an implementation namespace."
  {:author "Hugo Duncan"}
  (:require
   [pallet.argument :as argument]
   [pallet.context :as context]
   [pallet.phase :as phase]
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]
   [clojure.tools.logging :as logging]
   [clojure.set :as set]
   [clojure.string :as string])
  (:use
   [pallet.node-value :only [make-node-value set-node-value]]
   [clojure.algo.monads :only [defmonad domonad m-seq m-map]]
   [clojure.stacktrace :only [print-cause-trace]]
   [slingshot.slingshot :only [throw+]]))

;;; ## Action Plan Data Structure
;;; The action plan is a stack of actions, where the action could itself
;;; be a stack of actions (ie a tree of stacks).

(defn- push-block
  "Push a block onto the action-plan"
  [action-plan]
  (conj (or action-plan '(nil nil)) nil))

(defn- pop-block
  "Take the last block and add it to the scope below it in the stack.
   The block is reversed to put it into the order in which elements
   were added. Once pop'd, nothing should be added to the block."
  [action-plan]
  (let [block (peek action-plan)
        stack (pop action-plan)]
    (if-let [stem (next stack)]
      (conj
       stem
       (let [sb (first stack)]
         (conj
          (rest sb)
          (update-in (first sb) [:blocks]
                     (fn [blocks]
                       (conj (or blocks []) (reverse block)))))))
      (if-let [stem (seq (first stack))]
        (list
         (update-in
          stem :blocks (fn [blocks] (conj (or blocks []) (reverse block)))))
        (reverse block)))))

(defn- add-action
  "Add an action to the plan"
  [action-plan action]
  (let [action-plan (or action-plan '(nil nil))
        block (peek action-plan)
        stack (pop action-plan)]
    (conj stack (conj block action))))

;;; ## Action Representation
(defn action-map
  "Return an action map for the given args. The action plan is a tree of
   action maps.

   precedence specifies naming and dependencies, with :action-id, :always-before
   and :always-after. If a precedence is supplied, an action-id is generated
   if none present, to ensure that the standard action precedence is not
   altered.

   - :f            the action function
   - :args         the arguments to pass to the action function
   - :location     where to execute the action - :orgin or :target
   - :action-type  the type of action - :script/bash, :fn/clojure, etc
   - :execution    the execution type - :in-sequence, :aggregated, :collected
   - :value        the result of calling the action function, :f, with :args
   - :session      the session map after calling the action function.

   The action is generated by the specified action function and arguments that
   will be applied to the function when the action plan is executed.

   The action can be scheduled within one of three 'executions'
   (conceptually, sub-phases):

   :in-sequence - The generated action will be applied to the node
        \"in order\", as it is defined lexically in the source crate.
        This is the default.
   :aggregated - All aggregated actions are applied to the node
        in the order they are defined, but before all :in-sequence
        actions. Note that all of the arguments to any given
        action function are gathered such that there is only ever one
        invocation of each fn within each phase.
   :collected - All collected actions are applied to the node
        in the order they are defined, but after all :in-sequence
        action. Note that all of the arguments to any given
        action function are gathered such that there is only ever one
        invocation of each fn within each phase.

   The action-type determines how the action should be handled:

   :script/bash - action produces bash script for execution on remote machine
   :fn/clojure  - action is a function for local execution
   :transfer/to-local - action is a function specifying remote source
                        and local destination.
   :transfer/from-local - action is a function specifying local source
                          and remote destination."
  [action-fn precedence args execution action-type location]
  (let [precedence (and precedence (seq precedence)
                        (update-in precedence [:action-id]
                                   #(or % (gensym "action-id"))))]

    (merge
     (select-keys (meta action-fn) [:action-id :always-after :always-before])
     precedence
     {:f action-fn
      :args args
      :location location
      :action-type action-type
      :execution execution
      :context (context/phase-contexts)})))

(declare target-path)
(declare find-node-value-path)

(defn schedule-action
  "Registers an action in the action plan for execution. This function is
   responsable for creating a node-value, as node-value-path's have to be
   unique for all instances of an aggregated action."
  [session action]
  {:pre [session
         (keyword? (:phase session))
         (keyword? (:target-id session))]}
  (let [target-path (target-path session)
        node-value-path (if (= :aggregated (:execution action))
                          (or (find-node-value-path
                               (get-in session target-path) action)
                              (gensym "nv"))
                          (gensym "nv"))]
    [(make-node-value node-value-path)
     (update-in session target-path
                add-action (assoc action :node-value-path node-value-path))]))

;;; ## Utilities
(defn multi-context-string
  {:no-doc true}
  [context]
  (when (seq context)
    (str "[" (string/join ": " context) "]")))

(defn context-string
  {:no-doc true}
  [context]
  (when (seq context)
    (str (string/join ": " context) "\n")))

(defn- script-join
  "Concatenate multiple scripts, removing blank lines"
  [scripts]
  (str
   (->>
    scripts
    (map #(when % (string/trim %)))
    (filter (complement string/blank?))
    (string/join \newline))
   \newline))

;;; ## Action Plan Transformation
;;; Transform functions for working with an action-plan containing action-maps
;;; with :nested-scope types.
(defn- action-plan?
  [action-plan]
  (if (and action-plan
           (or (sequential? action-plan)
               (map? action-plan)))
    true
    (println "action-plan? failed: " action-plan)))

(defn- walk-action-plan
  "Traverses an action-plan structure.  leaf-fn is applied to leaf
   action, list-fn to sequences of actions, and nested-fn to
   a nested scope. nested-fn takes the existing nested scope and a transformed
   arg list"
  [leaf-fn list-fn nested-fn action-plan]
  ;;{:pre [(action-plan? action-plan)]}
  (cond
    (sequential? action-plan) (list-fn
                               (map
                                #(walk-action-plan leaf-fn list-fn nested-fn %)
                                action-plan))
    (:blocks action-plan) (nested-fn
                           action-plan
                           (map
                            #(walk-action-plan leaf-fn list-fn nested-fn %)
                            (:blocks action-plan)))
    :else (leaf-fn action-plan)))

(defn- assoc-blocks
  [action blocks]
  (assoc action :blocks blocks))

;;; ## Transform Executions
(defn- group-by-function
  "Transforms a seq of actions, generally some with identical :f values into a
   sequence of actions where the :args are the concatenation of all of the :args
   of associated with each :f in the original seq.  Sequence order from the
   original seq is retained. Keys over than :f and :args are assumed identical
   for a given :f value.

   e.g. (group-by-function
           [{:f :a :args [1 2]}
            {:f :b :args [3 4]}
            {:f :a :args [5 6]}
            {:f :c :args [7 8]]])
        => ({:f :a :args ([1 2] [5 6])}
            {:f :c :args ([7 8])}
            {:f :b :args ([3 4])})"
  [action-plan]
  (->>
   action-plan
   (group-by (juxt :f :action-id))
   (map (fn [[_ action-calls]]
          (update-in
           (reduce
            #(->
              %
              (update-in [:args] conj (:args %2))
              (update-in [:context] conj (multi-context-string (:context %2))))
            (assoc (first action-calls) :args [] :context [])
            action-calls)
           [:context] #(seq (distinct (filter identity %))))))))

(def ^{:doc "Execution specifc transforms" :private true}
  execution-transforms
  {:aggregated [group-by-function]
   :collected [group-by-function]})

(def ^{:private true} execution-ordering [:aggregated :in-sequence :collected])

(defn- transform-execution
  "Transform an execution by applying execution-transforms."
  [execution action-plan]
  (if-let [transforms (execution-transforms execution)]
    (reduce #(%2 %1) action-plan transforms)
    action-plan))

(defn- transform-scope-executions
  "Sort an action plan scope into different executions, applying execution
   specific transforms."
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (let [executions (group-by :execution action-plan)]
    (mapcat
     #(transform-execution % (% executions))
     execution-ordering)))

(defn- transform-executions
  "Sort an action plan into different executions, applying execution specific
   transforms."
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (walk-action-plan
   identity
   transform-scope-executions
   assoc-blocks
   action-plan))

;;; ### Enforce Declared Precedence Rules
(defn- symbol-action-fn
  "Lookup the action-fn from a symbol"
  [sym]
  (if-let [v (find-var sym)]
    (-> v var-get meta :pallet.action/action-fn)))

(defn- collect-action-id
  "Extract an action's id to function mapping"
  [m action]
  (if-let [id (:action-id action)]
    (assoc m id (:f action))
    m))

(defn- merge-union
  "Merge-with clojure.set/union"
  [& m]
  (apply merge-with set/union m))

(defn- action-dependencies
  "Extract an action's dependencies.  Actions are id'd with keywords
   and dependencies are declared on an action's id or function."
  [action-id-map action]
  (let [as-set (fn [x] (if (or (nil? x) (set? x)) x #{x}))
        before (as-set (:always-before action))
        after (as-set (:always-after action))
        self-id (select-keys action [:action-id :f])]
    (reduce
     (fn [m [id deps]] (update-in m [id] #(conj (or % #{}) deps)))
     {}
     (concat
      ;; before symbol
      (map
       #(vector {:f %} self-id)
       (map symbol-action-fn (filter symbol? before)))
      ;; before id
      (map
       #(vector {:action-id % :f (action-id-map %)} self-id)
       (filter keyword? before))
      ;; after symbol
      (map
       #(vector self-id {:f %})
       (map symbol-action-fn (filter symbol? after)))
      ;; after id
      (map
       #(vector self-id {:action-id % :f (action-id-map %)})
       (filter keyword? after))))))

(defn- action-instances
  "Given a map of dependencies, each with an :f and maybe a :action-id
   returns a map where the values are all matching action instances"
  [actions dependencies]
  (let [action-id-maps (reduce set/union (vals dependencies))]
    (reduce
     (fn [instances instance]
       (let [id (select-keys instance [:f :action-id])]
         (if (action-id-maps id)
           (update-in instances [id] #(conj (or % #{}) instance))
           instances)))
     {}
     actions)))

(defn- action-scope-dependencies
  [actions]
  (let [action-id-map (reduce collect-action-id {} actions)
        dependencies (reduce
                      #(merge-union %1 (action-dependencies action-id-map %2))
                      {} actions)
        instances (action-instances actions dependencies)
        dependents (zipmap (keys dependencies)
                           (map
                            (fn [d] (set (mapcat instances d)))
                            (vals dependencies)))]
    [action-id-map dependencies instances dependents]))

(defn- action-with-dependents
  [actions dependents seen action]
  {:pre [(vector? actions) (set? seen) (map? action)]}
  (if (seen action)
    [actions dependents seen]
    (let [ids (distinct [(select-keys action [:f :action-id])
                         (select-keys action [:f])])
          action-deps (mapcat dependents ids)]
      (let [[add-actions dependents seen]
            (reduce
             (fn add-a-w-d [[actions dependents seen] action]
               {:pre [(vector? actions) (set? seen) (map? action)]}
               (if (seen action)
                 [actions dependents seen]
                 (action-with-dependents actions dependents seen action)))
             [actions (reduce dissoc dependents ids) seen]
             action-deps)]
        [(conj add-actions action) dependents (conj seen action)]))))

(defn- enforce-scope-dependencies
  [actions]
  (let [[action-id-map dependencies instances dependents]
        (action-scope-dependencies actions)]
    (first (reduce
            (fn add-as-w-d [[actions dependents seen] action]
              {:pre [(vector? actions) (set? seen) (map? action)]}
              (if (seen action)
                [actions dependents seen]
                (action-with-dependents actions dependents seen action)))
            [[] dependents #{}]
            actions))))

(defn- enforce-precedence
  "Enforce precedence relations between actions."
  [action-plan]
  (walk-action-plan
   identity
   enforce-scope-dependencies
   assoc-blocks
   action-plan))

;;; ### Bind Arguments
;;; Arguments are evaluated.
(defn- evaluate-args
  "Evaluate an argument sequence"
  [session args]
  (map (fn [arg] (when arg (argument/evaluate arg session))) args))

(defn- apply-action
  "Returns a function that applies args to the function f
   evaluating the arguments."
  [f args]
  (fn [session]
    (apply f session (evaluate-args session args))))

(defn- apply-aggregated-action
  "Apply args-seq to the function f, evaluating each argument list in args-seq."
  [f args-seq]
  (fn [session]
    (f session (map #(evaluate-args session %) args-seq))))

(defmulti bind-action-arguments
  "Bind an action's arguments."
  (fn [{:keys [execution]}] execution))

(defmethod bind-action-arguments :in-sequence
  [{:keys [f args action-type] :as action-map}]
  (->
   action-map
   (update-in [:f] apply-action args)
   (dissoc :args)))

(defmethod bind-action-arguments :aggregated
  [{:keys [f args] :as action-map}]
  (->
   action-map
   (update-in [:f] apply-aggregated-action args)
   (dissoc :args)))

(defmethod bind-action-arguments :collected
  [{:keys [f args] :as action-map}]
  (->
   action-map
   (update-in [:f] apply-aggregated-action args)
   (dissoc :args)))

(defn- bind-scope-arguments
  "Takes an action plan scope and binds each actions arguments"
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (map bind-action-arguments action-plan))

(defn- bind-arguments
  "Takes an action plan and binds each actions arguments"
  [action-plan]
  (walk-action-plan
   identity
   bind-scope-arguments
    assoc-blocks
   action-plan))

;;; ### Augment Return

;;; TODO - rename to set-node-value-from-return, modify bash actions to return [rv session],
;;; so this can become a plain function (ie no special casing here)
(defmulti augment-return
  "Change the return type of an action, to be an action map with
   :value and :session keys that are the value of the action, and the updated
   session map for the next action.  This creates a consistent return value for
   all action types (effectively creating a monadic value which is a map).

   The function also sets the node-value to the result of the action."
  (fn [{:keys [action-type] :as action}] action-type))

(defmethod augment-return :default
  [{:keys [f node-value-path] :as action}]
  (assert node-value-path)
  (assoc action
    :f (fn [session]
         (let [session (assoc session :current-node-value-path node-value-path)
               rv (f session)]
           (logging/tracef "Set current node value: %s %s" node-value-path rv)
           (assoc action
             :session (dissoc
                       (set-node-value session rv) :current-node-value-path)
             :value rv)))))

(defmethod augment-return :fn/clojure
  [{:keys [f node-value-path] :as action}]
  (assoc action
    :f (fn [session]
         (let [[rv session] (f (assoc session
                                 :current-node-value-path node-value-path))
               session (set-node-value session rv)]
           (assoc action
             :session (dissoc session :current-node-value-path)
             :value session)))))

(defn- augment-scope-return-values
  "Augment the return values of each action in a scope."
  [action-plan]
  (map augment-return action-plan))

(defn- augment-return-values
  "Augment the return values of each action."
  [action-plan]
  (walk-action-plan
   identity
   augment-scope-return-values
   assoc-blocks
   action-plan))

;;; ### Set Defining Context
;;; The defining context is the phase context when the phase function is called.
;;; It is made available at action execution via *defining-context*.
(def
  ^{:doc "Phase contexts when action was called in a phase"
    :dynamic true
    :no-doc true}
  *defining-context*)

(defn- set-defining-context
  "Set the definining context"
  [{:keys [f context] :as action}]
  (assoc action
    :f (fn [session]
         (binding [*defining-context* context]
           (f session)))))

(defn- set-scope-defining-context
  "Set-Defining-Context the return values of each action in a scope."
  [action-plan]
  (map set-defining-context action-plan))

(defn- set-defining-contexts
  "Set-Defining-Context the return values of each action."
  [action-plan]
  (walk-action-plan
   identity
   set-scope-defining-context
   assoc-blocks
   action-plan))

;;; ## Translate Action Plan
(defn translate
  "Process the action-plan, applying groupings and precedence, producing
   an action plan with fully bound functions, ready for execution.

   This is equivalent to using an identity monad with a monadic value
   that is a tree of action maps."
  [action-plan]
  (->
   action-plan
   pop-block ;; pop the default block
   transform-executions
   enforce-precedence
   bind-arguments
   set-defining-contexts
   augment-return-values))


;;; ## Node Value Path Lookup
(defn- find-node-value-path
  [action-plan action]
  (letfn [(find-from-action [action-map]
            (when (= (:f action) (:f action-map))
              (:node-value-path action-map)))
          (find-from-actions [action-plan]
            (first (filter identity action-plan)))
          (first-identity [a s]
            s)]
    (when action-plan
      (walk-action-plan
       find-from-action
       find-from-actions
       first-identity
       action-plan))))

;;; ## Execute Action Plan
(defmonad
  ^{:private true
    :no-doc true}
  short-circuiting-state-m
  "Monad describing stateful computations. The monadic values have the
    structure (fn [old-state] [result new-state]). If result is a map with
    :action-plan/flag set to :action-plan/stop, then further calculations are
    short circuited."
  [m-result (fn m-result-state [v]
              (fn [s] [v s]))
   m-bind    (fn m-bind-short-state [mv f]
               (fn [s]
                 (let [[v ss] (mv s)]
                   (if (and (map? v) (= ::stop (::flag v)))
                     [v ss]
                     ((f v) ss)))))])

(def
  ^{:doc
    "The pallet action execution monad. This is fundamentally a state monad,
     where the state is the pallet session map."
    :private true
    :no-doc true}
  action-exec-m short-circuiting-state-m)

(defn translated?
  "Predicate to test if an action plan has been translated"
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (not (and (= 2 (count action-plan))
            (list? (first action-plan))
            (nil? (second action-plan)))))

(defn execute-action
  "Execute a single action, catching any exception and reporting it as
   an error map."
  [executor session action]
  (logging/tracef "execute-action %s %s %s" session action executor)
  (try
    (executor session action)
    (catch Exception e
      [{:error {:type :pallet/action-execution-error
                :context (context/contexts)
                :message (format "Unexpected exception: %s" (.getMessage e))
                ;; :location (with-out-str (print-cause-trace e))
                :cause e}}
       session])))

(defn stop-execution-on-error
  ":execute-status-fn algorithm to stop execution on an error"
  [[result session]]
  (if-let [flag (::flag result)]
    (if (not= flag ::stop)
      (if (:error result)
        [(assoc result ::flag ::stop) session]
        session)
      [result session])
    [result session]))

(defn exec-action
  [executor execute-status-fn]
  (fn exec-action-action [action]
    (fn exec-action-session [session]
      (logging/tracef "exec-action %s %s %s" session action executor)
      (execute-status-fn (execute-action executor session action)))))

(defn execute
  [action-plan session executor execute-status-fn]
  (logging/tracef "execute %s actions" (count action-plan))
  (when-not (translated? action-plan)
    (throw+
     {:type :pallet/execute-called-on-untranslated-action-plan
      :message "Attempt to execute an untranslated action plan"}))
  (letfn [(exec-action [action]
            (fn execute-with-error-check [session]
              (execute-status-fn (execute-action executor session action))))]
    ((domonad action-exec-m [v (m-map exec-action action-plan)] v)
     ;; the executor and execute-status-fn are put into the session map in order
     ;; to allow access to them in flow action execution
     (update-in
      session [:action-plan]
      assoc ::executor executor ::execute-status-fn execute-status-fn))))

(defn execute-if
  "Execute an if action"
  [session {:keys [f blocks] :as action}]
  (let [{:keys [value session]} (f session)
        executor (get-in session [:action-plan ::executor])
        _ (assert executor)
        execute-status-fn (get-in session [:action-plan ::execute-status-fn])
        _ (assert execute-status-fn)
        exec-action (exec-action executor execute-status-fn)]
    (logging/tracef "execute-if value %s" (pr-str value))
    (if value
      ((domonad action-exec-m [v (m-map exec-action (first blocks))] (last v))
       session)
      (if-let [else (seq (second blocks))]
        ((domonad action-exec-m [v (m-map exec-action else)] (last v))
         session)
        [nil session]))))

;;; ## Target specific functions
(defn- target-path*
  "Return the vector path of the action plan for the specified phase an
  target-id."
  [phase target-id]
  [:action-plan phase target-id])

(defn target-path
  "Return the vector path of the action plan for the current session target
   node, or target group."
  [session]
  {:pre [(keyword? (:phase session))
         (keyword? (:target-id session))]}
  (target-path* (:phase session) (-> session :target-id)))

(defn script-template-for-server
  "Return the script template for the specified server."
  [server]
  (let [family (-> server :image :os-family)]
    (filter identity
            [family
             (:packager server)
             (when-let [version (-> server :image :os-version)]
               (keyword (format "%s-%s" (name family) version)))])))

(defn script-template
  "Return the script template for the current group node."
  [session]
  (when-let [server (:server session)]
    (script-template-for-server server)))

;;; ## Action Plan Functions Based on Session
(defn reset-for-target
  "Reset the action plan for the current phase and target."
  [session]
  {:pre [(:phase session) (:target-id session)]}
  (reduce
   #(assoc-in %1 (target-path* %2 (-> session :target-id)) nil)
   session
   (phase/all-phases-for-phase (:phase session))))

(defn phase-for-target
  "Return the phase function for the target phase."
  [session]
  (let [phase (:phase session)]
    (or
     (phase (-> session :server :phases))
     (phase (:inline-phases session))
     (phase (-> session :group :phases)))))

(defn build-for-target
  "Create the action plan by calling the current phase for the target group."
  [session]
  {:pre [(:phase session)]}
  (if-let [f (phase-for-target session)]
    (script/with-script-context (script-template session)
      (stevedore/with-script-language :pallet.stevedore.bash/bash
        (logging/tracef "build-for-target building phase")
        (f (reset-for-target session))))
    [nil session]))

(defn get-for-target
  "Get the action plan for the current phase and target node."
  [session]
  (get-in session (target-path session)))

(defn translate-for-target
  "Build the action plan and translate for the current phase and target node."
  [session]
  {:pre [(:phase session)]}
  (update-in session (target-path session) translate))

(defn execute-for-target
  "Execute the translated action plan for the current target."
  [session executor execute-status-fn]
  {:pre [(:phase session)]}
  (logging/tracef "execute-for-target")
  (script/with-script-context (script-template session)
    (stevedore/with-script-language :pallet.stevedore.bash/bash
      (let [path (target-path session)]
        (logging/tracef "execute-for-target target-path %s" path)
        (execute (get-in session path) session executor execute-status-fn)))))

;;; ## Scope and Context Functions
(defmacro checked-script
  "Return a stevedore script that uses the current context to label the
   action"
  [name & script]
  `(stevedore/checked-script
    (str
     (context-string *defining-context*)
     ~name)
    ~@script))

(defn checked-commands*
  "Return a stevedore script that uses the current context to label the
   action"
  [name scripts]
  (stevedore/checked-commands*
   (str (context-string *defining-context*) name)
   scripts))

(defn checked-commands
  "Return a stevedore script that uses the current context to label the
   action"
  [name & script]
  (checked-commands* name script))

(defn enter-scope
  "Enter a new action scope."
  [session]
  [nil
   (update-in
    session (target-path session) push-block)])

(defn leave-scope
  "Leave the current action scope."
  [session]
  [nil
   (update-in
    session (target-path session) pop-block)])

;;; ## Flow actions
;;; Flow actions allow flow control over nested scopes.
(defn if-action
  "Insert a :flow/if action that will claim the next one or two nested scopes."
  [condition]
  (fn [session]
    (schedule-action
     session
     (action-map
      (fn [session value] value)
      {} [condition] :in-sequence :flow/if :origin))))
