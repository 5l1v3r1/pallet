<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Pallet - agile provisioning and configuration of compute nodes. A devops tool." name="description" /><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">/*!
 * Copyright ¬© 2010 Sattvik Software & Technology Resources, Ltd. Co.
 * All rights reserved.
 *
 * sh-clojure may be used under the terms of either the GNU Lesser General Public
 * License (LGPL) or the Eclipse Public License (EPL).  As a recipient of
 * sh-clojure, you may choose which license to receive the code under.  See the
 * LICENSE file distributed with sh-clojure for details.
 *
 * Written by Daniel Solano G√≥mez
 *
 * Version 0.9.1 - 10 Apr 2010
 */

function ClojureRegExp(pattern) {
	pattern = pattern + '(?=[[\\]{}(),\\s])';
	this.regex = new RegExp(pattern, 'g');
	this.lookBehind = /[\[\]{}(),\s]$/;
}

ClojureRegExp.prototype.exec = function (str) {
	var match, leftContext;
	while (match=this.regex.exec(str)) {
		leftContext = str.substring(0, match.index);
		if (this.lookBehind.test(leftContext)) {
			return match;
		}
		else {
			this.regex.lastIndex = match.index + 1;
		}
	}
	return null;
};

SyntaxHighlighter.brushes.Clojure = function () {
	var special_forms =
			'. def do fn if let loop monitor-enter monitor-exit new quote recur set! ' +
			'throw try var',
	    clojure_core =
			'* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* ' +
			'*command-line-args* *compile-files* *compile-path* *e *err* *file* ' +
			'*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* ' +
			'*print-dup* *print-length* *print-level* *print-meta* *print-readably* ' +
			'*read-eval* *source-path* *use-context-classloader* ' +
			'*warn-on-reflection* + - -> -&gt; ->> -&gt;&gt; .. / < &lt; <= &lt;= = ' +
			'== > &gt; >= &gt;= accessor aclone ' +
			'add-classpath add-watch agent agent-errors aget alength alias all-ns ' +
			'alter alter-meta! alter-var-root amap ancestors and apply areduce ' +
			'array-map aset aset-boolean aset-byte aset-char aset-double aset-float ' +
			'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? ' +
			'atom await await-for await1 bases bean bigdec bigint binding bit-and ' +
			'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left ' +
			'bit-shift-right bit-test bit-xor boolean boolean-array booleans ' +
			'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array ' +
			'char-escape-string char-name-string char? chars chunk chunk-append ' +
			'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? ' +
			'class class? clear-agent-errors clojure-version coll? comment commute ' +
			'comp comparator compare compare-and-set! compile complement concat cond ' +
			'condp conj conj! cons constantly construct-proxy contains? count ' +
			'counted? create-ns create-struct cycle dec decimal? declare definline ' +
			'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? ' +
			'deliver deref derive descendants destructure disj disj! dissoc dissoc! ' +
			'distinct distinct? doall doc dorun doseq dosync dotimes doto double ' +
			'double-array doubles drop drop-last drop-while empty empty? ensure ' +
			'enumeration-seq eval even? every? false? ffirst file-seq filter find ' +
			'find-doc find-ns find-var first float float-array float? floats flush ' +
			'fn fn? fnext for force format future future-call future-cancel ' +
			'future-cancelled? future-done? future? gen-class gen-interface gensym ' +
			'get get-in get-method get-proxy-class get-thread-bindings get-validator ' +
			'hash hash-map hash-set identical? identity if-let if-not ifn? import ' +
			'in-ns inc init-proxy instance? int int-array integer? interleave intern ' +
			'interpose into into-array ints io! isa? iterate iterator-seq juxt key ' +
			'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list ' +
			'list* list? load load-file load-reader load-string loaded-libs locking ' +
			'long long-array longs loop macroexpand macroexpand-1 make-array ' +
			'make-hierarchy map map? mapcat max max-key memfn memoize merge ' +
			'merge-with meta method-sig methods min min-key mod name namespace neg? ' +
			'newline next nfirst nil? nnext not not-any? not-empty not-every? not= ' +
			'	ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ' +
			'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? ' +
			'or parents partial partition pcalls peek persistent! pmap pop pop! ' +
			'pop-thread-bindings pos? pr pr-str prefer-method prefers ' +
			'primitives-classnames print print-ctor print-doc print-dup print-method ' +
			'print-namespace-doc print-simple print-special-doc print-str printf ' +
			'println println-str prn prn-str promise proxy proxy-call-with-super ' +
			'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot ' +
			'rand rand-int range ratio? rational? rationalize re-find re-groups ' +
			're-matcher re-matches re-pattern re-seq read read-line read-string ' +
			'reduce ref ref-history-count ref-max-history ref-min-history ref-set ' +
			'refer refer-clojure release-pending-sends rem remove remove-method ' +
			'remove-ns remove-watch repeat repeatedly replace replicate require ' +
			'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq ' +
			'rsubseq second select-keys send send-off seq seq? seque sequence ' +
			'sequential? set set-validator! set? short short-array shorts ' +
			'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by ' +
			'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? ' +
			'split-at split-with str stream? string? struct struct-map subs subseq ' +
			'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take ' +
			'take-last take-nth take-while test the-ns time to-array to-array-2d ' +
			'trampoline transient tree-seq true? type unchecked-add unchecked-dec ' +
			'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate ' +
			'unchecked-remainder unchecked-subtract underive unquote ' +
			'unquote-splicing update-in update-proxy use val vals var-get var-set ' +
			'var? vary-meta vec vector vector? when when-first when-let when-not ' +
			'while with-bindings with-bindings* with-in-str with-loading-context ' +
			'with-local-vars with-meta with-open with-out-str with-precision xml-seq ' +
			'zero? zipmap ';

	this.getKeywords = function (keywordStr) {
		// quote special characters
		keywordStr = keywordStr.replace(/[\-\[\]{}()*+?.\\\^$|,#]/g, "\\$&");
		// trim whitespace and convert to alternatives
		keywordStr = keywordStr.replace(/^\s+|\s+$/g, '').replace(/\s+/g, '|');
		// create pattern
		return '(?:' + keywordStr + ')';
	};

	this.regexList = [
		// comments
		{ regex: new RegExp(';.*$', 'gm'),
			css: 'comments' },
		// strings
		{ regex: SyntaxHighlighter.regexLib.multiLineDoubleQuotedString,
			css: 'string' },
		// regular expressions
		{ regex: /#"(?:\.|(\\\")|[^\""\n])*"/g,
			css: 'string' },
		// vectors
		{ regex: /\[|\]/g,
			css: 'keyword' },
		// amperstands
		{ regex: /&(amp;)?/g,
			css: 'keyword' },
		// sets and maps
		{ regex: /#?\{|\}/g,
			css: 'keyword' },
		// metadata
		{ regex: /#\^\{/g,
			css: 'keyword' },
		// anonymous fn syntactic sugar
		{ regex: /#\(|%/g,
			css: 'keyword' },
		// deref reader macro
		{ regex: /@/g,
			css: 'keyword' },
		// (un)quoted sexprs
		{ regex: /(['`]|~@?)[\[({]/g,
			css: 'keyword' },
		// lists
		{ regex: /\(|\)/g,
			css: 'keyword' },
		// character literals
		{ regex: /\\.\b/g,
			css: 'value' },
		// hexadecimal literals
		{ regex: /[+\-]?\b0x[0-9A-F]+\b/gi,
			css: 'value' },
		// integer/octal/float/bigdecimal literals
		{ regex: new ClojureRegExp("[+-]?\\b\\d+(\\.\\d*)?([eE][+-]?\\d+|M)?\\b"),
			css: 'value' },
		{ regex: /^[+\-]?\b\d+(\.\d*)?([eE][+\-]?\d+|M)?\b/g,
			css: 'value' },
		// booleans+nil
		{ regex: /\b(true|false|nil)\b/g,
			css: 'value' },
		// (un)quoted symbols
		{ regex: /(`|#?'|~@?)[\w-.\/]+/g,
			css: 'color1' },
		// keywords
		{ regex: /:[A-Za-z0-9_\-]+/g,
			css: 'constants' },
		// special forms
		{ regex: new ClojureRegExp(this.getKeywords(special_forms)),
			css: 'preprocessor' },
		// type hints
		{ regex: /\#\^[A-Za-z]\w*/g,
			css: 'preprocessor' },
		// clojure.core
		{ regex: new ClojureRegExp(this.getKeywords(clojure_core)),
			css: 'functions' }
	];

	this.forHtmlScript(SyntaxHighlighter.regexLib.scriptScriptTags);
};

SyntaxHighlighter.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
SyntaxHighlighter.brushes.Clojure.aliases   = ['clojure', 'Clojure', 'clj'];

// vim: ts=2 sw=2 noet
</script><script type="text/javascript">
// hackity-hack

$(document).ready(function() {
    var ft = $("#floating-toc")
    var ul = ft.find('ul')
    var lis = ft.find('li')

    ul.css('maring', '0px')

    var liHeight = $(lis.get(0)).height()

    ft.css('height', (liHeight) + 'px')


    showNs = function(ns) {
        //this is killing performance, lookup table.
        //var el = $("[id='floating-toc_" + ns + "']")
        //var index = lis.index(el)

        var index = 0

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i
        }

        console.log(index)

        if(index == lastNsIndex) return;

        lastNsIndex = index


        ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300)
        //        ul.css('margin-top', (-1 * liHeight * index) + 'px')

    }

    var calcNsPositions = function() {
        var nss = []
        var anchors = []
        var positions = []
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1]
            nss.push(ns)
            var a = $("a[name='"+ns+"']")
            anchors.push(a)
            positions.push(a.offset().top)
            console.log(a.offset().top)
        });

        return {nss: nss, positions: positions}
    }

    var nsPositions = calcNsPositions()

    console.log(nsPositions)

    var lastNsIndex = -1

    var $window = $(window)

    var currentSection = function(nsp) {

        var ps = nsp.positions
        var nss = nsp.nss
        var scroll = $window.scrollTop() + 300
        var nsIndex = -1
        for(var i in ps) {
            var p = ps[i]
            if(p >= scroll) {
                nsIndex = i-1
                break;
            }
                
        }

        if(nsIndex == -1 && scroll >= ps[0]) {
            nsIndex = ps.length-1
        }

        if(nsIndex == -1) nsIndex = 0

        return nss[nsIndex]
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions))
    })

    ul.css('margin-top', '0px')

})
</script><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
  margin: 0 !important;
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .keyword {
  font-weight: bold !important;
}
.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}
</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;}h1{font-size:20px;margin-top:0;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><title>pallet -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">pallet</h1><h2 class="project-version">0.6.2-SNAPSHOT</h2><br /><p>Pallet - agile provisioning and configuration of compute nodes. A devops tool.</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.2.1</td></tr><tr><td class="dep-name">org.clojure/clojure-contrib</td><td class="dotted"><hr /></td><td class="dep-version">1.2.0</td></tr><tr><td class="dep-name">org.clojure/core.logic</td><td class="dotted"><hr /></td><td class="dep-version">0.6.1-20110615.050108-25</td></tr><tr><td class="dep-name">org.cloudhoist/thread-expr</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.cloudhoist/pallet-common</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0</td></tr><tr><td class="dep-name">org.cloudhoist/stevedore</td><td class="dotted"><hr /></td><td class="dep-version">0.5.0</td></tr><tr><td class="dep-name">clj-http/clj-http</td><td class="dotted"><hr /></td><td class="dep-version">0.1.1</td></tr><tr><td class="dep-name">clj-ssh/clj-ssh</td><td class="dotted"><hr /></td><td class="dep-version">0.2.5-SNAPSHOT</td></tr><tr><td class="dep-name">log4j/log4j</td><td class="dotted"><hr /></td><td class="dep-version">1.2.14</td></tr><tr><td class="dep-name">jline/jline</td><td class="dotted"><hr /></td><td class="dep-version">0.9.94</td></tr><tr><td class="dep-name">enlive/enlive</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.apache.maven/maven-settings</td><td class="dotted"><hr /></td><td class="dep-version">2.0.10</td></tr><tr><td class="dep-name">vmfest/vmfest</td><td class="dotted"><hr /></td><td class="dep-version">0.2.3-SNAPSHOT</td></tr><tr><td class="dep-name">swank-clojure/swank-clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.2.1</td></tr><tr><td class="dep-name">autodoc/autodoc</td><td class="dotted"><hr /></td><td class="dep-version">0.7.1</td></tr><tr><td class="dep-name">marginalia/marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.5.0-alpha</td></tr><tr><td class="dep-name">org.jclouds/jclouds-compute</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.jclouds/jclouds-blobstore</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.jclouds/jclouds-all</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.jclouds.driver/jclouds-jsch</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.jclouds.driver/jclouds-log4j</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.jclouds.driver/jclouds-enterprise</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr></table></div><div class="dependencies"><h3>dev dependencies</h3><table><tr><td class="dep-name">org.clojure/core.logic</td><td class="dotted"><hr /></td><td class="dep-version">0.6.1-20110615.050108-25</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#pallet.action.conditional">pallet.action.conditional</a></li><li><a href="#pallet.action.directory">pallet.action.directory</a></li><li><a href="#pallet.action.environment">pallet.action.environment</a></li><li><a href="#pallet.action.exec-script">pallet.action.exec-script</a></li><li><a href="#pallet.action.file">pallet.action.file</a></li><li><a href="#pallet.action.filesystem">pallet.action.filesystem</a></li><li><a href="#pallet.action.package.centos">pallet.action.package.centos</a></li><li><a href="#pallet.action.package.debian-backports">pallet.action.package.debian-backports</a></li><li><a href="#pallet.action.package.epel">pallet.action.package.epel</a></li><li><a href="#pallet.action.package.jpackage">pallet.action.package.jpackage</a></li><li><a href="#pallet.action.package.rpmforge">pallet.action.package.rpmforge</a></li><li><a href="#pallet.action.package">pallet.action.package</a></li><li><a href="#pallet.action.remote-directory">pallet.action.remote-directory</a></li><li><a href="#pallet.action.remote-file">pallet.action.remote-file</a></li><li><a href="#pallet.action.rsync">pallet.action.rsync</a></li><li><a href="#pallet.action.service">pallet.action.service</a></li><li><a href="#pallet.action.user">pallet.action.user</a></li><li><a href="#pallet.action">pallet.action</a></li><li><a href="#pallet.action-plan">pallet.action-plan</a></li><li><a href="#pallet.argument">pallet.argument</a></li><li><a href="#pallet.blobstore.implementation">pallet.blobstore.implementation</a></li><li><a href="#pallet.blobstore.jclouds">pallet.blobstore.jclouds</a></li><li><a href="#pallet.blobstore.url-blobstore">pallet.blobstore.url-blobstore</a></li><li><a href="#pallet.blobstore">pallet.blobstore</a></li><li><a href="#pallet.command-line">pallet.command-line</a></li><li><a href="#pallet.command-script">pallet.command-script</a></li><li><a href="#pallet.compute.implementation">pallet.compute.implementation</a></li><li><a href="#pallet.compute.jclouds">pallet.compute.jclouds</a></li><li><a href="#pallet.compute.jvm">pallet.compute.jvm</a></li><li><a href="#pallet.compute.node-list">pallet.compute.node-list</a></li><li><a href="#pallet.compute.vmfest">pallet.compute.vmfest</a></li><li><a href="#pallet.compute">pallet.compute</a></li><li><a href="#pallet.config-file.format">pallet.config-file.format</a></li><li><a href="#pallet.configure">pallet.configure</a></li><li><a href="#pallet.core">pallet.core</a></li><li><a href="#pallet.crate.network-service">pallet.crate.network-service</a></li><li><a href="#pallet.crate.session-store">pallet.crate.session-store</a></li><li><a href="#pallet.crate">pallet.crate</a></li><li><a href="#pallet.debug">pallet.debug</a></li><li><a href="#pallet.enlive">pallet.enlive</a></li><li><a href="#pallet.environment">pallet.environment</a></li><li><a href="#pallet.execute">pallet.execute</a></li><li><a href="#pallet.futures">pallet.futures</a></li><li><a href="#pallet.heynote">pallet.heynote</a></li><li><a href="#pallet.logging">pallet.logging</a></li><li><a href="#pallet.main">pallet.main</a></li><li><a href="#pallet.main-invoker">pallet.main-invoker</a></li><li><a href="#pallet.maven">pallet.maven</a></li><li><a href="#pallet.md5crypt">pallet.md5crypt</a></li><li><a href="#pallet.parameter">pallet.parameter</a></li><li><a href="#pallet.phase">pallet.phase</a></li><li><a href="#pallet.repl">pallet.repl</a></li><li><a href="#pallet.request-map">pallet.request-map</a></li><li><a href="#pallet.resource.directory">pallet.resource.directory</a></li><li><a href="#pallet.resource.exec-script">pallet.resource.exec-script</a></li><li><a href="#pallet.resource.file">pallet.resource.file</a></li><li><a href="#pallet.resource.filesystem">pallet.resource.filesystem</a></li><li><a href="#pallet.resource.filesystem-layout">pallet.resource.filesystem-layout</a></li><li><a href="#pallet.resource.format">pallet.resource.format</a></li><li><a href="#pallet.resource.hostinfo">pallet.resource.hostinfo</a></li><li><a href="#pallet.resource.lib">pallet.resource.lib</a></li><li><a href="#pallet.resource.network-service">pallet.resource.network-service</a></li><li><a href="#pallet.resource.package">pallet.resource.package</a></li><li><a href="#pallet.resource.remote-directory">pallet.resource.remote-directory</a></li><li><a href="#pallet.resource.remote-file">pallet.resource.remote-file</a></li><li><a href="#pallet.resource.resource-when">pallet.resource.resource-when</a></li><li><a href="#pallet.resource.rsync">pallet.resource.rsync</a></li><li><a href="#pallet.resource.service">pallet.resource.service</a></li><li><a href="#pallet.resource.shell">pallet.resource.shell</a></li><li><a href="#pallet.resource.user">pallet.resource.user</a></li><li><a href="#pallet.resource">pallet.resource</a></li><li><a href="#pallet.script.lib">pallet.script.lib</a></li><li><a href="#pallet.session">pallet.session</a></li><li><a href="#pallet.shell">pallet.shell</a></li><li><a href="#pallet.strint">pallet.strint</a></li><li><a href="#pallet.target">pallet.target</a></li><li><a href="#pallet.task.add-service">pallet.task.add-service</a></li><li><a href="#pallet.task.containers">pallet.task.containers</a></li><li><a href="#pallet.task.converge">pallet.task.converge</a></li><li><a href="#pallet.task.converge-cluster">pallet.task.converge-cluster</a></li><li><a href="#pallet.task.describe-node">pallet.task.describe-node</a></li><li><a href="#pallet.task.destroy-cluster">pallet.task.destroy-cluster</a></li><li><a href="#pallet.task.feedback">pallet.task.feedback</a></li><li><a href="#pallet.task.help">pallet.task.help</a></li><li><a href="#pallet.task.lift">pallet.task.lift</a></li><li><a href="#pallet.task.new-project">pallet.task.new-project</a></li><li><a href="#pallet.task.nodes">pallet.task.nodes</a></li><li><a href="#pallet.task.providers">pallet.task.providers</a></li><li><a href="#pallet.task.to-blob">pallet.task.to-blob</a></li><li><a href="#pallet.task.version">pallet.task.version</a></li><li><a href="#pallet.template.properties">pallet.template.properties</a></li><li><a href="#pallet.template">pallet.template</a></li><li><a href="#pallet.utils">pallet.utils</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.conditional" name="pallet.action.conditional"><h1 class="project-name">pallet.action.conditional</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Conditional action execution.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.conditional
  (:refer-clojure :exclude [when when-not])
  (:require
   [pallet.action :as action]
   [pallet.action.exec-script :as exec-script])
  (:use
   clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro when
  [session condition & crate-fns-or-actions]
  `(->
    ~session
    (action/enter-scope)
    (exec-script/exec-script ("if [" ~condition "]; then"))
    ~@crate-fns-or-actions
    (exec-script/exec-script "fi")
    (action/leave-scope)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro when-not
  [session condition & crate-fns-or-actions]
  `(->
    ~session
    (action/enter-scope)
    (exec-script/exec-script ("if [ !" ~condition "]; then"))
    ~@crate-fns-or-actions
    (exec-script/exec-script "fi")
    (action/leave-scope)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.directory" name="pallet.action.directory"><h1 class="project-name">pallet.action.directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A directory manipulation action, to create and remove directories
   with given ownership and mode.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.directory
  (:require
   [pallet.action :as action]
   [pallet.action.file :as file]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn adjust-directory
  "Script to set the ownership and mode of a directory."
  [path {:keys [owner group mode recursive] :as opts}]
  (stevedore/chain-commands*
   (filter
    identity
    [(when owner
       (stevedore/script
        (~lib/chown ~owner ~path :recursive ~recursive)))
     (when group
       (stevedore/script
        (~lib/chgrp ~group ~path :recursive ~recursive)))
     (when mode
       (stevedore/script
        (~lib/chmod ~mode ~path)))])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-directory
  "Script to create a directory."
  [dir-path & {:keys [path verbose mode recursive] :as opts}]
  (stevedore/checked-commands
   (str "Directory " dir-path)
   (stevedore/script
    (~lib/mkdir ~dir-path :path ~path :verbose ~verbose :mode ~mode))
   (adjust-directory dir-path opts)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action directory
  "Directory management.
   For :create and :touch, all components of path are effected.
   Options are:
    - :action     One of :create, :touch, :delete
    - :recursive  Flag for recursive delete
    - :force      Flag for forced delete
    - :path       flag to create all path elements
    - :owner      set owner
    - :group      set group
    - :mode       set mode"
  [session dir-path & {:keys [action recursive force path mode verbose owner
                              group]
                       :or {action :create recursive true force true path true}
                       :as options}]
  (case action
    :delete (stevedore/checked-script
             (str "Delete directory " dir-path)
             (~lib/rm ~dir-path :recursive ~recursive :force ~force))
    :create (make-directory
             dir-path
             :path path :mode mode :verbose verbose
             :owner owner :group group :recursive recursive)
    :touch (make-directory
            dir-path
            :path path :mode mode :verbose verbose
            :owner owner :group group :recursive recursive)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action directories
  "Directory management of multiple directories with the same
   owner/group/permissions.
   `options` are as for `directory` and are applied to each directory in
   `paths`"
  [session paths & options]
  (stevedore/chain-commands*
   (map #(apply (action/action-fn directory) session % options) paths)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.environment" name="pallet.action.environment"><h1 class="project-name">pallet.action.environment</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Set up the system environment.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.environment
  (:require
   [clojure.string :as string]
   [pallet.action.exec-script :as exec-script]
   [pallet.action.remote-file :as remote-file]
   [pallet.session :as session]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn system-environment
  "Define system wide default environment.
   On redhat based systems, this is set in /etc/profile.d, so is only
   valid within a login shell. On debian based systems, /etc/environment
   is used."
  [session env-name key-value-pairs & {:keys [path shared] :as options}]
  (let [os-family (session/os-family session)
        [path shared] (if (and path shared)
                        [path shared]
                        (if (#{:rhel :centos :fedora} os-family)
                          ["/etc/profile.d/java.sh" false]
                          ["/etc/environment" true]))]
    (if shared
      (exec-script/exec-script*
       session
       (stevedore/checked-commands*
        (format "Add %s environment to %s" env-name path)
        (conj
         (for [[k v] key-value-pairs]
           (stevedore/script
            (pallet_set_env
             ~k ~v
             ~(str (name k) "=" (pr-str v)))))
         (stevedore/script
          (defn pallet_set_env [k v s]
            (if (not @(grep (quoted @s) ~path))
              (sed -i
                   -e (quoted "/${k}/ d")
                   -e (quoted "$ a \\\\\n${s}")
                   ~path)))))))
      (remote-file/remote-file
       session
       path
       :owner "root"
       :group "root"
       :mode 644
       :content (string/join
                 \newline
                 (for [[k v] key-value-pairs]
                   (str (name k) "=" (pr-str v))))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.exec-script" name="pallet.action.exec-script"><h1 class="project-name">pallet.action.exec-script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Script execution. Script generation occurs with the correct script context.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.exec-script
  (:require
   [pallet.action :as action]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def exec-script* (action/bash-action [session script] script))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro exec-script
  "Execute a bash script remotely"
  [session & script]
  `(exec-script* ~session (stevedore/script ~@script)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro exec-checked-script
  "Execute a bash script remotely, throwing if any element of the
   script fails."
  [session name & script]
  `(exec-script* ~session (stevedore/checked-script ~name ~@script)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.file" name="pallet.action.file"><h1 class="project-name">pallet.action.file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>File manipulation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.file
  (:require
   [pallet.action :as action]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.utils :as utils]
   [clojure.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn adjust-file [path options]
  (stevedore/chain-commands*
   (filter
    identity
    [(when (:owner options)
       (stevedore/script (~lib/chown ~(options :owner) ~path)))
     (when (:group options)
       (stevedore/script (~lib/chgrp ~(options :group) ~path)))
     (when (:mode options)
       (stevedore/script (chmod ~(options :mode) ~path)))])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn write-md5-for-file
  "Create a .md5 file for the specified input file"
  [path md5-path]
  (stevedore/script
   ((~lib/md5sum ~path) > ~md5-path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn touch-file [path {:keys [force] :as options}]
  (stevedore/chain-commands
   (stevedore/script
    (~lib/touch ~path :force ~force))
   (adjust-file path options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action file
  "File management."
  [session path & {:keys [action owner group mode force]
                   :or {action :create force true}
                   :as options}]
  (case action
    :delete (stevedore/checked-script
             (str "delete file " path)
             (~lib/rm ~path :force ~force))
    :create (stevedore/checked-commands
             (str "file " path)
             (touch-file path options))
    :touch (stevedore/checked-commands
             (str "file " path)
             (touch-file path options))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action symbolic-link
  "Symbolic link management."
  [session from name & {:keys [action owner group mode force]
                        :or {action :create force true}}]
  (case action
    :delete (stevedore/checked-script
             (str "Link %s " name)
             (~lib/rm ~name :force ~force))
    :create (stevedore/checked-script
             (format "Link %s as %s" from name)
             (~lib/ln ~from ~name :force ~force :symbolic ~true))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action fifo
  "FIFO pipe management."
  [session path & {:keys [action] :or {action :create} :as options}]
  (case action
    :delete (stevedore/checked-script
             (str "fifo " path)
             (~lib/rm ~path :force ~force))
    :create (stevedore/checked-commands
             (str "fifo " path)
             (stevedore/script
              (if-not (file-exists? ~path)
                (mkfifo ~path)))
             (adjust-file path options))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action sed
  "Execute sed on a file.  Takes a path and a map for expr to replacement."
  [session path exprs-map & {:keys [seperator no-md5 restriction] :as options}]
  (stevedore/checked-script
   (format "sed file %s" path)
   (~lib/sed-file ~path ~exprs-map ~options)
   ~(when-not no-md5
      (write-md5-for-file path (str path ".md5")))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.filesystem" name="pallet.action.filesystem"><h1 class="project-name">pallet.action.filesystem</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Filesystem action</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.filesystem
  (:require
   [pallet.action.directory :as directory]
   [pallet.action.exec-script :as exec-script]
   [clojure.string :as string])
  (:use
   pallet.thread-expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-xfs-filesytem
  "Format a device as an XFS filesystem."
  [session device]
  (-> session
      (exec-script/exec-checked-script
       (format "Format %s as XFS" device)
       (mkfs.xfs -f ~device))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti format-mount-option
  (fn [[key value]] (class value)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-mount-option :default
  [[key value]]
  (format "%s=%s" (name key) value))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-mount-option java.lang.Boolean
  [[key value]]
  (when value
    (format "%s" (name key))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- mount-cmd-options [options]
  (let [option-string (string/join ","
                       (filter identity (map format-mount-option options)))]
    (if (string/blank? option-string)
      (str "-o " option-string))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn mount
  "Mount a device."
  [session device mount-point
   & {:keys [fs-type device-type automount no-automount dump-frequency
             boot-check-pass]
      :or {dump-frequency 0 boot-check-pass 0}
      :as options}]
  (->
   session
   (directory/directory mount-point)
   (exec-script/exec-checked-script
    (format "Mount %s at %s" device mount-point)
    (if-not @(mountpoint -q ~mount-point)
      (mount ~(if fs-type (str "-t " fs-type) )
             ~(mount-cmd-options
               (dissoc options :device-type :dump-frequency :boot-check-pass
                       :fs-type))
             ~device (quoted ~mount-point))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.package.centos" name="pallet.action.package.centos"><h1 class="project-name">pallet.action.package.centos</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the centos repositories</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.package.centos
  (:require
   [pallet.action.package :as package]
   [pallet.parameter :as parameter]
   [pallet.session :as session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} centos-repo
  "http://mirror.centos.org/centos/%s/%s/%s/repodata/repomd.xml")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} centos-repo-key
  "http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-%s")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn arch
  "Return the centos package architecture for the target node."
  [session]
  (if (session/is-64bit? session) "x86_64" "i386"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-repository
  "Add a centos repository. By default, ensure that it has a lower than default
  priority."
  [session & {:keys [version repository enabled priority]
              :or {version "5.5" repository "os" enabled 0 priority 50}}]
  (->
   session
   (package/package "yum-priorities")
   (package/package-source
    (format "Centos %s %s %s" version repository (arch session))
    :yum {:url (format centos-repo version repository (arch session))
          :gpgkey (format centos-repo-key (str (first version)))
          :priority priority
          :enabled enabled})))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.package.debian-backports" name="pallet.action.package.debian-backports"><h1 class="project-name">pallet.action.package.debian-backports</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the debian backports repository</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.package.debian-backports
  (:require
   [pallet.action.package :as package]
   [pallet.parameter :as parameter]
   [pallet.script.lib :as lib]
   [pallet.session :as session]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-debian-backports
  "Add debian backport package repository"
  [session]
  (package/package-source
   session
   "debian-backports"
   :aptitude {:url "http://backports.debian.org/debian-backports"
              :release (str
                        (stevedore/script (~lib/os-version-name)) "-backports")
              :scopes ["main"]}))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.package.epel" name="pallet.action.package.epel"><h1 class="project-name">pallet.action.package.epel</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the epel repository</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.package.epel
  (:require
   [pallet.action :as action]
   [pallet.action.package :as package]
   [pallet.parameter :as parameter]
   [pallet.session :as session]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs"><p>this is an aggregate so that it can come before the aggragate package-manager</p>
</td><td class="codes" /><pre class="brush: clojure">(action/def-aggregated-action add-epel
  "Add the EPEL repository"
  [session args]
  {:arglists '([session & {:keys [version] :or {version "5-4"}}])
   :always-before #{`package/package-manager `package/package}}
  (let [{:keys [version] :or {version "5-4"}} (apply
                                               merge {}
                                               (map #(apply hash-map %) args))]
    (stevedore/script
     ;; "Add EPEL package repository"
     ("rpm"
      -U --quiet
      ~(format
        "http://download.fedora.redhat.com/pub/epel/5/%s/epel-release-%s.noarch.rpm"
        "$(uname -i)"
        version)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.package.jpackage" name="pallet.action.package.jpackage"><h1 class="project-name">pallet.action.package.jpackage</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the jpackage repository</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.package.jpackage
  (:require
   [pallet.action :as action]
   [pallet.action.package :as package]
   [pallet.parameter :as parameter]
   [pallet.session :as session]
   [pallet.thread-expr :as thread-expr]))</pre></tr><tr><td class="docs"><p>The source for this rpm is available here:
http://plone.lucidsolutions.co.nz/linux/centos/
jpackage-rpm-repository-for-centos-rhel-5.x
http://plone.lucidsolutions.co.nz/linux/centos/images/
jpackage-utils-compat-el5-0.0.1-1.noarch.rpm/at_download/file</p>
</td><td class="codes" /><pre class="brush: clojure">(def jpackage-utils-compat-rpm
  (str "https://github.com/downloads/pallet/pallet/"
       "jpackage-utils-compat-el5-0.0.1-1.noarch.rpm"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn jpackage-utils
  "Add jpackge-utils. Due to incompatibilities on RHEL derived distributions,
   a compatability package is required.
   https://bugzilla.redhat.com/show_bug.cgi?id=260161
   https://bugzilla.redhat.com/show_bug.cgi?id=497213"
  [session]
  (->
   session
   (thread-expr/when->
    (or
     (= :fedora (session/os-family session))
     (and
      (#{:rhel :centos} (session/os-family session))
      (re-matches #"5\.[0-5]" (session/os-version session))))
    (action/with-precedence {:action-id ::install-jpackage-compat}
      (package/add-rpm
       "jpackage-utils-compat-el5-0.0.1-1"
       :url jpackage-utils-compat-rpm)))
   (package/package "jpackage-utils")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jpackage-mirror-fmt
  "http://www.jpackage.org/mirrorlist.php?dist=%s&type=%s&release=%s")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn mirrorlist
  [dist type release]
  (format jpackage-mirror-fmt dist type release))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-jpackage
  "Add the jpackage repository.  component should be one of:
     fedora
     redhat-el
   Installs the jpackage-utils package from the base repos at a
   pritority of 25."
  [session & {:keys [version component releasever enabled]
              :or {component "redhat-el"
                   releasever "$releasever"
                   version "5.0"
                   enabled 0}}]
  (let [no-updates (and                 ; missing updates for fedora 13, 14
                    (= version "5.0")
                    (= :fedora (session/os-family session))
                    (try
                      (< 12 (Integer/decode
                             (str (session/os-version session))))
                      (catch NumberFormatException _)))
        jpackage-repos (vec
                        (filter
                         identity
                         ["jpackage-generic"
                          "jpackage-generic-updates"
                          "jpackage-generic-non-free"
                          "jpackage-generic-updates-non-free"
                          (format "jpackage-%s" component)
                          (when-not no-updates
                            (format "jpackage-%s-updates" component))]))]
    (->
     session
     (package/package-source
      "jpackage-generic"
      :yum {:mirrorlist (mirrorlist "generic" "free" version)
            :failovermethod "priority"
            ;;gpgkey "http://www.jpackage.org/jpackage.asc"
            :enabled enabled})
     (package/package-source
      "jpackage-generic-non-free"
      :yum {:mirrorlist (mirrorlist "generic" "non-free" version)
            :failovermethod "priority"
            ;;gpgkey "http://www.jpackage.org/jpackage.asc"
            :enabled enabled})
     (package/package-source
      (format "jpackage-%s" component)
      :yum {:mirrorlist (mirrorlist
                         (str component "-" releasever) "free" version)
            :failovermethod "priority"
            ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
            :enabled enabled})
     (package/package-source
      "jpackage-generic-updates"
      :yum {:mirrorlist (mirrorlist "generic" "free" (str version "-updates"))
            :failovermethod "priority"
            ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
            :enabled enabled})
     (package/package-source
      "jpackage-generic-updates-non-free"
      :yum {:mirrorlist (mirrorlist
                         "generic" "non-free" (str version "-updates"))
            :failovermethod "priority"
            ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
            :enabled enabled})
     (thread-expr/when-not->
      no-updates
      (package/package-source
       (format "jpackage-%s-updates" component)
       :yum {:mirrorlist (mirrorlist
                          (str component "-" releasever)
                          "free"
                          (str version "-updates"))
             :failovermethod "priority"
             ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
             :enabled enabled}))
     (parameter/assoc-for-target [:jpackage-repos] jpackage-repos))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn package-manager-update-jpackage
  "Update the package lists for the jpackage repositories"
  [request]
  (package/package-manager
   request :update
   :disable ["*"]
   :enable (parameter/get-for-target request [:jpackage-repos])))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.package.rpmforge" name="pallet.action.package.rpmforge"><h1 class="project-name">pallet.action.package.rpmforge</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the rpmforge repository</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.package.rpmforge
  (:require
   [pallet.action :as action]
   [pallet.action.package :as package]
   [pallet.action.remote-file :as remote-file]
   [pallet.parameter :as parameter]
   [pallet.session :as session]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true}
  remote-file* (action/action-fn remote-file/remote-file-action))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true}
  rpmforge-url-pattern
  "http://packages.sw.be/rpmforge-release/rpmforge-release-%s.%s.rf.%s.rpm")</pre></tr><tr><td class="docs"><p>this is an aggregate so that it can come before the aggragate package-manager</p>
</td><td class="codes" /><pre class="brush: clojure">(action/def-aggregated-action add-rpmforge
  "Add the rpmforge repository"
  [session args]
  {:always-before #{`package/package-manager `package/package}
   :arglists '([session & {:keys [version distro arch]
                           :or {version "0.5.2-2" distro "el5" arch "i386"}}])}
  (let [{:keys [version distro arch]
         :or {version "0.5.2-2"
              distro "el5"
              arch "i386"}} (apply hash-map (first args))]
    (stevedore/checked-script
     "Add rpmforge repositories"
     (chain-or
      (if (= "0" @(pipe (rpm -qa) (grep rpmforge) (wc -l)))
        (do
          ~(remote-file*
            session
            "rpmforge.rpm"
            :url (format rpmforge-url-pattern version distro arch))
          ("rpm" -U --quiet "rpmforge.rpm")))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.package" name="pallet.action.package"><h1 class="project-name">pallet.action.package</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Package management action.</p>

<p>   <code>package</code> is used to install or remove a package.</p>

<p>   <code>package-source</code> is used to specify a non-standard source for packages.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.package
  (:require
   [pallet.action :as action]
   [pallet.action.file :as file]
   [pallet.action.remote-file :as remote-file]
   [pallet.action.exec-script :as exec-script]
   [pallet.action.exec-script :as exec-script]
   [pallet.parameter :as parameter]
   [pallet.script.lib :as lib]
   [pallet.session :as session]
   [pallet.stevedore :as stevedore]
   [pallet.script :as script]
   [pallet.utils :as utils]
   [clojure.string :as string])
  (:use
   pallet.thread-expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true}
  remote-file* (action/action-fn remote-file/remote-file-action))
(def ^{:private true}
  sed* (action/action-fn file/sed))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti adjust-packages
  (fn [session & _]
    (session/packager session)))</pre></tr><tr><td class="docs"><p>aptitude can install, remove and purge all in one command, so we just need to
split by enable/disable options.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod adjust-packages :aptitude
  [session packages]
  (stevedore/checked-commands
   "Packages"
   (stevedore/script (~lib/package-manager-non-interactive))
   (stevedore/chain-commands*
    (for [[opts packages] (->>
                           packages
                           (group-by #(select-keys % [:enable]))
                           (sort-by #(apply min (map :priority (second %)))))]
      (stevedore/script
       (aptitude
        install -q -y
        ~(string/join " " (map #(str "-t " %) (:enable opts)))
        ~(string/join
          " "
          (for [[action packages] (group-by :action packages)
                {:keys [package force purge]} packages]
            (case action
              :install (format "%s+" package)
              :remove (if purge
                        (format "%s_" package)
                        (format "%s-" package))
              :upgrade (format "%s+" package)
              (throw
               (IllegalArgumentException.
                (str
                 action " is not a valid action for package action"))))))))))
   (stevedore/script (~lib/list-installed-packages))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true :doc "Define the order of actions"}
  action-order {:install 10 :remove 20 :upgrade 30})</pre></tr><tr><td class="docs"><p><code>yum</code> has separate install, remove and purge commands, so we just need to
split by enable/disable options and by command.  We install before removing.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod adjust-packages :yum
  [session packages]
  (stevedore/checked-commands
   "Packages"
   (stevedore/chain-commands*
    (conj
     (vec
      (for [[action packages] (->> packages
                                   (sort-by #(action-order (:action %)))
                                   (group-by :action))
            [opts packages] (->>
                             packages
                             (group-by
                              #(select-keys % [:enable :disable :exclude]))
                             (sort-by #(apply min (map :priority (second %)))))]
        (stevedore/script
         (yum
          ~(name action) -q -y
          ~(string/join " " (map #(str "--disablerepo=" %) (:disable opts)))
          ~(string/join " " (map #(str "--enablerepo=" %) (:enable opts)))
          ~(string/join " " (map #(str "--exclude=" %) (:exclude opts)))
          ~(string/join
            " "
            (distinct (map :package packages)))))))
     (stevedore/script (~lib/list-installed-packages))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod adjust-packages :default
  [session packages]
  (stevedore/checked-commands
   "Packages"
   (stevedore/chain-commands*
    (list*
     (stevedore/script (~lib/package-manager-non-interactive))
     (for [[action packages] (group-by :action packages)
           {:keys [package force purge]} packages]
       (case action
         :install (stevedore/script
                   (~lib/install-package ~package :force ~force))
         :remove (if purge
                   (stevedore/script (~lib/purge-package ~package))
                   (stevedore/script (~lib/remove-package ~package)))
         :upgrade (stevedore/script (~lib/upgrade-package ~package))
         (throw
          (IllegalArgumentException.
           (str action " is not a valid action for package action")))))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- package-map
  "Convert the args into a single map"
  [session package-name
   & {:keys [action y force purge priority enable disable] :as options}]
  (letfn [(as-seq [x] (if (or (string? x) (symbol? x) (keyword? x))
                        [(name x)] x))]
    (->
     {:action :install :y true :priority 50}
     (merge options)
     (assoc :package package-name)
     (update-in [:enable] as-seq)
     (update-in [:disable] as-seq))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-aggregated-action package
  "Install or remove a package.
   Options
    - :action [:install | :remove | :upgrade]
    - :purge [true|false]         when removing, whether to remove all config
    - :enable [repo|(seq repo)]   enable specific repository
    - :disable [repo|(seq repo)]  disable specific repository
    - :priority n                 priority (0-100, default 50)
   Package management occurs in one shot, so that the package manager can
   maintain a consistent view."
  [session args]
  {:arglists '([session package-name
                & {:keys [action y force purge enable disable priority]
                   :or {action :install
                        y true
                        priority 50}
                   :as options}])}
  (adjust-packages session (map #(apply package-map session %) args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn packages
  "Install a list of packages keyed on packager.
       (packages session
         :yum [\"git\" \"git-email\"]
         :aptitude [\"git-core\" \"git-email\"])"
  [session & {:keys [yum aptitude pacman brew] :as options}]
  (->
   session
   (for->
    [package-name (options (session/packager session))]
    (package package-name))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def source-location
  {:aptitude "/etc/apt/sources.list.d/%s.list"
   :yum "/etc/yum.repos.d/%s.repo"})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti format-source
  "Format a package source definition"
  (fn [packager & _] packager))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-source :aptitude
  [_ name options]
  (format
   "%s %s %s %s\n"
   (:source-type options "deb")
   (:url options)
   (:release options (stevedore/script (~lib/os-version-name)))
   (string/join " " (:scopes options ["main"]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-source :yum
  [_ name {:keys [url mirrorlist gpgcheck gpgkey priority failovermethod
                  enabled]
           :or {enabled 1}
           :as options}]
  (string/join
   "\n"
   (filter
    identity
    [(format "[%s]\nname=%s" name name)
     (when url (format "baseurl=%s" url))
     (when mirrorlist (format "mirrorlist=%s" mirrorlist))
     (format "gpgcheck=%s" (or (and gpgkey 1) 0))
     (when gpgkey (format "gpgkey=%s" gpgkey))
     (when priority (format "priority=%s" priority))
     (when failovermethod (format "failovermethod=%s" failovermethod))
     (format "enabled=%s" enabled)
     ])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn package-source*
  "Add a packager source."
  [session name & {:as options}]
  (let [packager (session/packager session)]
    (stevedore/checked-commands
     "Package source"
     (let [key-url (-> options :aptitude :url)]
       (if (and key-url (.startsWith key-url "ppa:"))
         (stevedore/chain-commands
          (stevedore/script (~lib/install-package "python-software-properties"))
          (stevedore/script (add-apt-repository ~key-url)))
         (remote-file*
          session
          (format (source-location packager) name)
          :content (format-source packager name (packager options))
          :literal (= packager :yum))))
     (if (and (-> options :aptitude :key-id)
              (= packager :aptitude))
       (stevedore/script
        (apt-key adv
                 "--keyserver subkeys.pgp.net --recv-keys"
                 ~(-> options :aptitude :key-id))))
     (if (and (-> options :aptitude :key-url)
              (= packager :aptitude))
       (stevedore/chain-commands
        (remote-file*
         session
         "aptkey.tmp"
         :url (-> options :aptitude :key-url))
        (stevedore/script (apt-key add aptkey.tmp))))
     (when-let [key (and (= packager :yum) (-> options :yum :gpgkey))]
       (stevedore/script (rpm "--import" ~key))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(declare package-manager)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-aggregated-action package-source
  "Control package sources.
   Options are the package manager keywords, each specifying a map of
   packager specific options.
   :aptitude
     - :source-type string   - source type (deb)
     - :url url              - repository url
     - :scopes seq           - scopes to enable for repository
     - :key-url url          - url for key
     - :key-id id            - id for key to look it up from keyserver
   :yum
     - :name                 - repository name
     - :url url          - repository base url
     - :gpgkey url           - gpg key url for repository
   Example
       (package-source \"Partner\"
         :aptitude {:url \"http://archive.canonical.com/\"
                    :scopes [\"partner\"]})"
  [session args]
  {:arglists (:arglists (meta pallet.action.package/package-source*))
   :always-before #{`package-manager `package}}
  (stevedore/do-script*
   (map (fn [x] (apply package-source* session x)) args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-scope*
  "Add a scope to all the existing package sources. Aptitude specific."
  [type scope file]
  (stevedore/chained-script
   (var tmpfile @(mktemp -t addscopeXXXX))
   (~lib/cp ~file @tmpfile :preserve true)
   (awk "'{if ($1 ~" ~(str "/^" type "/") "&& !" ~(str "/" scope "/")
        " ) print $0 \" \" \ ~scope  "\" ; else print; }'"
        ~file > @tmpfile)
   (~lib/mv @tmpfile ~file :force ~true)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-scope
  "Add a scope to an apt source"
  [opts]
  (add-scope*
   (or (opts :type) "deb.*")
   (:scope opts)
   (or (opts :file) "/etc/apt/sources.list")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti configure-package-manager
  "Configure the package manager"
  (fn [session packager options] packager))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti package-manager-option
  "Provide packager specific options"
  (fn [session packager option value] [packager option]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:aptitude :proxy]
  [session packager proxy proxy-url]
  (format "ACQUIRE::http::proxy \"%s\";" proxy-url))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:yum :proxy]
  [session packager proxy proxy-url]
  (format "proxy=%s" proxy-url))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:pacman :proxy]
  [session packager proxy proxy-url]
  (format
   (str "XferCommand = /usr/bin/wget "
        "-e \"http_proxy = %s\" -e \"ftp_proxy = %s\" "
        "--passive-ftp --no-verbose -c -O %%o %%u")
   proxy-url proxy-url))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def default-installonlypkgs
  (str "kernel kernel-smp kernel-bigmem kernel-enterprise kernel-debug "
       "kernel-unsupported"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:yum :installonlypkgs]
  [session packager installonly packages]
  (format
   "installonlypkgs=%s %s" (string/join " " packages) default-installonlypkgs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :aptitude
  [session packager {:keys [priority prox] :or {priority 50} :as options}]
  (remote-file*
   session
   (format "/etc/apt/apt.conf.d/%spallet" priority)
   :content (string/join
             \newline
             (map
              #(package-manager-option session packager (key %) (val %))
              (dissoc options :priority)))
   :literal true))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :yum
  [session packager {:keys [proxy] :as options}]
  (stevedore/chain-commands
   (remote-file*
    session
    "/etc/yum.pallet.conf"
    :content (string/join
              \newline
              (map
               #(package-manager-option session packager (key %) (val %))
               (dissoc options :priority)))
    :literal true)
   ;; include yum.pallet.conf from yum.conf
   (stevedore/script
    (if (not @("fgrep" "yum.pallet.conf" "/etc/yum.conf"))
      (do
        ("cat" ">>" "/etc/yum.conf" " <<'EOFpallet'")
        "include=file:///etc/yum.pallet.conf"
        "EOFpallet")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :pacman
  [session packager {:keys [proxy] :as options}]
  (stevedore/chain-commands
   (remote-file*
    session
    "/etc/pacman.pallet.conf"
    :content (string/join
              \newline
              (map
               #(package-manager-option session packager (key %) (val %))
               (dissoc options :priority)))
    :literal true)
   ;; include pacman.pallet.conf from pacman.conf
   (stevedore/script
    (if (not @("fgrep" "pacman.pallet.conf" "/etc/pacman.conf"))
      (do
        ~(sed*
          session
          "/etc/pacman.conf"
          "a Include = /etc/pacman.pallet.conf"
          :restriction "/\\[options\\]/"))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :default
  [session packager {:as options}]
  (comment "do nothing"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn package-manager*
  "Package management."
  [session action & options]
  (let [packager (session/packager session)]
    (stevedore/checked-commands
     (format "package-manager %s %s" (name action) (string/join " " options))
     (case action
       :update (stevedore/script (apply ~lib/update-package-list ~options))
       :upgrade (stevedore/script (~lib/upgrade-all-packages))
       :list-installed (stevedore/script (~lib/list-installed-packages))
       :add-scope (add-scope (apply hash-map options))
       :multiverse (add-scope (apply hash-map :scope "multiverse" options))
       :universe (add-scope (apply hash-map :scope "universe" options))
       :debconf (if (= :aptitude packager)
                  (stevedore/script
                   (apply ~lib/debconf-set-selections ~options)))
       :configure (configure-package-manager session packager options)
       (throw (IllegalArgumentException.
               (str action
                    " is not a valid action for package-manager action")))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-aggregated-action package-manager
  "Package manager controls.
   `action` is one of the following:
   - :update          - update the list of available packages
   - :list-installed  - output a list of the installed packages
   - :add-scope       - enable a scope (eg. multiverse, non-free)
   To refresh the list of packages known to the pakage manager:
       (package-manager session :update)
   To enable multiverse on ubuntu:
       (package-manager session :add-scope :scope :multiverse)
   To enable non-free on debian:
       (package-manager session :add-scope :scope :non-free)"
  [session package-manager-args]
  {:copy-arglist (:arglists (meta pallet.action.package/package-manager*))
   :always-before `package}
  (stevedore/do-script*
   (map #(apply package-manager* session %) (distinct package-manager-args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action add-rpm
  "Add an rpm.  Source options are as for remote file."
  [request rpm-name & {:as options}]
  (stevedore/do-script
   (apply remote-file* request rpm-name (apply concat options))
   (stevedore/checked-script
    (format "Install rpm %s" rpm-name)
    (if-not (rpm -q @(rpm -pq ~rpm-name) > "/dev/null" "2>&1")
      (do (rpm -U --quiet ~rpm-name))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action minimal-packages
  "Add minimal packages for pallet to function"
  [session]
  {:always-before #{`package-manager `package-source `package}}
  (let [os-family (session/os-family session)]
    (cond
     (#{:ubuntu :debian} os-family) (stevedore/checked-script
                                     "Add minimal packages"
                                     (~lib/update-package-list)
                                     (~lib/install-package "coreutils")
                                     (~lib/install-package "sudo"))
     (= :arch os-family) (stevedore/checked-script
                          "Add minimal packages"
                          ("{" pacman-db-upgrade "||" true "; } "
                           "2> /dev/null")
                          (~lib/update-package-list)
                          (~lib/upgrade-package "pacman")
                          (println "  checking for pacman-db-upgrade")
                          ("{" pacman-db-upgrade
                           "&&" (~lib/update-package-list)
                           "||" true "; } "
                           "2> /dev/null")
                          (~lib/install-package "sudo")))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.remote-directory" name="pallet.action.remote-directory"><h1 class="project-name">pallet.action.remote-directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Action to specify the content of a remote directory.  At present the
   content can come from a downloaded tar or zip file.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.remote-directory
  (:require
   [pallet.action :as action]
   [pallet.action.directory :as directory]
   [pallet.action.file :as file]
   [pallet.action.remote-file :as remote-file]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.thread-expr :as thread-expr]
   [clojure.java.io :as io]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true}
  directory* (action/action-fn directory/directory))
(def ^{:private true}
  remote-file* (action/action-fn remote-file/remote-file-action))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- source-to-cmd-and-path
  [session path url local-file remote-file md5 md5-url]
  (cond
   url (let [tarpath (str
                      (stevedore/script (~lib/tmp-dir)) "/"
                      (.getName
                       (java.io.File. (.getFile (java.net.URL. url)))))]
         [(remote-file* session tarpath :url url :md5 md5 :md5-url md5-url)
          tarpath])
   local-file [ (str path "-content")]
   remote-file [ remote-file]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action remote-directory-action
  [session path & {:keys [action url local-file remote-file
                          unpack tar-options unzip-options jar-options
                          strip-components md5 md5-url owner group recursive]
                   :or {action :create
                        tar-options "xz"
                        unzip-options "-o"
                        jar-options "xf"
                        strip-components 1
                        recursive true}
                   :as options}]
  (case action
    :create (let [url (options :url)
                  unpack (options :unpack :tar)]
              (when (and (or url local-file remote-file) unpack)
                (let [[cmd tarpath] (source-to-cmd-and-path
                                     session path
                                     url local-file remote-file md5 md5-url)]
                  (stevedore/checked-commands
                   "remote-directory"
                   (directory*
                    session path :owner owner :group group :recursive false)
                   cmd
                   (condp = unpack
                       :tar (stevedore/checked-script
                             (format "Untar %s" tarpath)
                             (var rdf @(readlink -f ~tarpath))
                             (cd ~path)
                             (tar ~tar-options
                                  ~(str "--strip-components=" strip-components)
                                  -f @rdf)
                             (cd -))
                       :unzip (stevedore/checked-script
                               (format "Unzip %s" tarpath)
                               (var rdf @(readlink -f ~tarpath))
                               (cd ~path)
                               (unzip ~unzip-options @rdf)
                               (cd -))
                       :jar (stevedore/checked-script
                             (format "Unjar %s" tarpath)
                             (var rdf @(readlink -f ~tarpath))
                             (cd ~path)
                             (jar ~jar-options @rdf)
                             (cd -)))
                   (if recursive
                     (directory*
                      session path
                      :owner owner
                      :group group
                      :recursive recursive))))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn remote-directory
  "Specify the contents of remote directory.
   Options:
    - :url              - a url to download content from
    - :unpack           - how download should be extracts (default :tar)
    - :tar-options      - options to pass to tar (default \"xz\")
    - :unzip-options    - options to pass to unzip (default \"-o\")
    - :jar-options      - options to pass to unzip (default \"xf\")
                          jar does not support stripping path components
    - :strip-components - number of path compnents to remove when unpacking
    - :md5              - md5 of file to unpack
    - :md5-url          - url of md5 file for file to unpack
   Ownership options:
    - :owner            - owner of files
    - :group            - group of files
    - :recursive        - flag to recursively set owner and group
   To install the content of an url pointing at a tar file, specify the :url
   option.
       (remote-directory session path
          :url \"http://a.com/path/file.tgz\")
   If there is an md5 url with the tar file's md5, you can specify that as well,
   to prevent unecessary downloads and verify the content.
       (remote-directory session path
          :url \"http://a.com/path/file.tgz\"
          :md5-url \"http://a.com/path/file.md5\")
   To install the content of an url pointing at a zip file, specify the :url
   option and :unpack :unzip.
       (remote-directory session path
          :url \"http://a.com/path/file.\"
          :unpack :unzip)"
  [session path & {:keys [action url local-file remote-file
                          unpack tar-options unzip-options jar-options
                          strip-components md5 md5-url owner group recursive
                          force-overwrite
                          local-file-options]
                   :or {action :create
                        tar-options "xz"
                        unzip-options "-o"
                        jar-options "xf"
                        strip-components 1
                        recursive true}
                   :as options}]
  (when-let [f (and local-file (io/file local-file))]
    (when (not (and (.exists f) (.isFile f) (.canRead f)))
      (throw (IllegalArgumentException.
              (format
               (str "'%s' does not exist, is a directory, or is unreadable; "
                    "cannot register it for transfer.")
               local-file)))))
  (->
   session
   (thread-expr/when-> local-file
           ;; transfer local file to remote system if required
           (remote-file/transfer-file
            local-file
            (str path "-content")
            local-file-options))
   (action/with-precedence local-file-options
     (thread-expr/apply-map->
      remote-directory-action path
      (merge
       {:overwrite-changes force-overwrite} ;; capture the value of the flag
       options)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.remote-file" name="pallet.action.remote-file"><h1 class="project-name">pallet.action.remote-file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Action to specify remote file content.</p>

<p>   <code>remote-file</code> has many options for the content of remote files.  Ownership
   and mode can of course be specified. By default the remote file is versioned,
   and multiple versions are kept.</p>

<p>   Modification of remote files outside of pallet cause an error to be raised
   by default.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.remote-file
  (:require
   [pallet.action :as action]
   [pallet.action.directory :as directory]
   [pallet.action.file :as file]
   [pallet.blobstore :as blobstore]
   [pallet.environment :as environment]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.template :as templates]
   [pallet.utils :as utils]
   [clojure.contrib.def :as def]
   [clojure.java.io :as io])
  (:use
   pallet.thread-expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def install-new-files true)
(def force-overwrite false)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn set-install-new-files
  "Set boolean flag to control installation of new files"
  [flag]
  (alter-var-root #'install-new-files (fn [_] flag)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn set-force-overwrite
  "Globally force installation of new files, even if content on node has
  changed."
  [flag]
  (alter-var-root #'force-overwrite (fn [_] flag)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  content-options
  [:local-file :remote-file :url :md5 :content :literal :template :values
   :action :blob :blobstore]
  "A vector of the options accepted by remote-file.  Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  version-options
  [:overwrite-changes :no-versioning :max-versions :flag-on-changed]
  "A vector of options for controlling versions. Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  ownership-options
  [:owner :group :mode]
  "A vector of options for controlling ownership. Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  all-options
  (concat content-options version-options ownership-options)
  "A vector of the options accepted by remote-file.  Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- get-session
  "Build a curl or wget command from the specified session object."
  [session]
  (stevedore/script
   (if (test @(~lib/which curl))
     (curl -s "--retry" 20
           ~(apply str (map
                        #(format "-H \"%s: %s\" " (first %) (second %))
                        (.. session getHeaders entries)))
           ~(.. session getEndpoint toASCIIString))
     (if (test @(~lib/which wget))
       (wget -nv "--tries" 20
             ~(apply str (map
                          #(format "--header \"%s: %s\" " (first %) (second %))
                          (.. session getHeaders entries)))
             ~(.. session getEndpoint toASCIIString))
       (do
         (println "No download utility available")
         (~lib/exit 1))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- arg-vector
  "Return the non-session arguments."
  [_ & args]
  args)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- delete-local-path
  [session local-path]
  (.delete local-path)
  session)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn with-remote-file
  "Function to call f with a local copy of the sessioned remote path.
   f should be a function taking [session local-path & _], where local-path will
   be a File with a copy of the remote file (which will be unlinked after
   calling f."
  [session f path & args]
  (let [local-path (utils/tmpfile)]
    (->
     session
     (action/schedule-action
      arg-vector
      {}
      [path (.getPath local-path)]
      :in-sequence :transfer/to-local :origin)
     (apply-> f local-path args)
     (action/schedule-action
      delete-local-path
      {}
      [local-path]
      :in-sequence :fn/clojure :origin))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn transfer-file
  "Function to transfer a local file."
  [session local-path remote-path {:as options}]
  (action/schedule-action
   session
   arg-vector
   options
   [local-path remote-path]
   :in-sequence :transfer/from-local :origin))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action remote-file-action
  [session path & {:keys [action url local-file remote-file link
                          content literal
                          template values
                          md5 md5-url
                          owner group mode force
                          blob blobstore
                          overwrite-changes no-versioning max-versions
                          flag-on-changed
                          force]
                   :or {action :create max-versions 5}
                   :as options}]
  (let [new-path (str path ".new")
        md5-path (str path ".md5")
        versioning (if no-versioning nil :numbered)
        proxy (environment/get-for session [:proxy] nil)]
    (case action
      :create
      (stevedore/checked-commands
       (str "remote-file " path)
       (cond
        (and url md5) (stevedore/chained-script
                       (if (|| (not (file-exists? ~path))
                               (!= ~md5 @((pipe
                                           (~lib/md5sum ~path)
                                           (~lib/cut
                                             :fields 1 :delimiter " ")))))
                         ~(stevedore/chained-script
                           (~lib/download-file ~url ~new-path :proxy ~proxy))))
        ;; Download md5 to temporary directory.
        (and url md5-url) (stevedore/chained-script
                           (var tmpdir (quoted (~lib/make-temp-dir "rf")))
                           (var basefile
                                (quoted
                                 (str @tmpdir "/" @(~lib/basename ~path))))
                           (var newmd5path (quoted (str @basefile ".md5")))
                           (~lib/download-file
                            ~md5-url @newmd5path :proxy ~proxy)
                           (~lib/normalise-md5 @newmd5path)
                           (if (|| (not (file-exists? ~md5-path))
                                   (~lib/diff @newmd5path ~md5-path))
                             (do
                               (~lib/download-file ~url ~new-path :proxy ~proxy)
                               (~lib/ln ~new-path @basefile)
                               (if-not (~lib/md5sum-verify @newmd5path)
                                 (do
                                   (println ~(str "Download of " url
                                                  " failed to match md5"))
                                   (~lib/exit 1)))))
                           (~lib/rm @tmpdir :force ~true :recursive ~true))
        url (stevedore/chained-script
             (~lib/download-file ~url ~new-path :proxy ~proxy))
        content (stevedore/script
                 (~lib/heredoc
                  ~new-path ~content ~(select-keys options [:literal])))
        local-file nil
        ;; (let [temp-path (action/register-file-transfer!
        ;;                   local-file)]
        ;;    (stevedore/script
        ;;     (mv -f (str "~/" ~temp-path) ~new-path)))
        remote-file (stevedore/script
                     (~lib/cp ~remote-file ~new-path :force ~true))
        template (stevedore/script
                  (~lib/heredoc
                   ~new-path
                   ~(templates/interpolate-template
                     template (or values {}) session)
                   ~(select-keys options [:literal])))
        link (stevedore/script
              (~lib/ln ~link ~path :force ~true :symbolic ~true))
        blob (stevedore/checked-script
              "Download blob"
              (~lib/download-request
               ~new-path
               ~(blobstore/sign-blob-request
                 (or blobstore (environment/get-for session [:blobstore] nil)
                     (throw (IllegalArgumentException.
                             "No :blobstore given for blob content.") ))
                 (:container blob) (:path blob)
                 {:method :get})))
        :else (throw
               (IllegalArgumentException.
                (str "remote-file " path " specified without content."))))
       ;; process the new file accordingly
       (when install-new-files
         (stevedore/chain-commands
          (if (or overwrite-changes no-versioning force-overwrite)
            (stevedore/script
             (if (file-exists? ~new-path)
               (do
                 ~(stevedore/chain-commands
                   (stevedore/script
                    (~lib/mv ~new-path ~path :backup ~versioning :force ~true))
                   (if flag-on-changed
                     (stevedore/script (~lib/set-flag ~flag-on-changed)))))))
            (stevedore/script
             (var md5diff )
             (if (&& (file-exists? ~path) (file-exists? ~md5-path))
               (do
                 (~lib/md5sum-verify ~md5-path)
                 (set! md5diff "$?")))
             (var contentdiff )
             (if (&& (file-exists? ~path) (file-exists? ~new-path))
               (do
                 (~lib/diff ~path ~new-path :unified true)
                 (set! contentdiff "$?")))
             (if (== @md5diff 1)
               (do
                 (println "Existing content did not match md5:")
                 (~lib/exit 1)))
             (if (!= @contentdiff "0")
               (do
                 ~(stevedore/chain-commands
                   (stevedore/script
                    (~lib/mv ~new-path ~path :force ~true :backup ~versioning))
                   (if flag-on-changed
                     (stevedore/script (~lib/set-flag ~flag-on-changed))))))
             (if-not (file-exists? ~path)
               (do
                 ~(stevedore/chain-commands
                   (stevedore/script (~lib/mv ~new-path ~path))
                   (if flag-on-changed
                     (stevedore/script (~lib/set-flag ~flag-on-changed))))))))
          (file/adjust-file path options)
          (when-not no-versioning
            (stevedore/chain-commands
             (file/write-md5-for-file path md5-path)
             (stevedore/script
              (println "MD5 sum is" @(~lib/cat ~md5-path)))))))
       ;; cleanup
       (if (and (not no-versioning) (pos? max-versions))
         (stevedore/script
          (pipe
           ((~lib/ls (str ~path ".~[0-9]*~") :sort-by-time ~true)
            "2>" "/dev/null")
           (~lib/tail  :max-lines ~(str "+" (inc max-versions)))
           (~lib/xargs (~lib/rm  :force ~true))))))
      :delete (stevedore/checked-script
               (str "delete remote-file " path)
               (~lib/rm ~path :force ~force)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn remote-file
  "Remote file content management.
The `remote-file` action can specify the content of a remote file in a number
different ways.
By default, the remote-file is versioned, and 5 versions are kept.
The remote content is also verified against it's md5 hash.  If the contents
of the remote file have changed (e.g. have been edited on the remote machine)
then by default the file will not be overwritten, and an error will be raised.
To force overwrite, call `set-force-overwrite` before running `converge` or
`lift`.
Options for specifying the file's content are:
  :url url          - download the specified url to the given filepath
  :content string   - use the specified content directly
  :local-file path  - use the file on the local machine at the given path
  :remote-file path - use the file on the remote machine at the given path
  :link             - file to link to
  :literal          - prevent shell expansion on content
  :md5              - md5 for file
  :md5-url          - a url containing file's md5
  :template         - specify a template to be interpolated
  :values           - values for interpolation
  :blob             - map of :container, :path
  :blobstore        - a jclouds blobstore object (override blobstore in session)
Options for version control are:
  :overwrite-changes - flag to force overwriting of locally modified content
  :no-versioning    - do not version the file
  :max-versions     - specfy the number of versions to keep (default 5)
  :flag-on-changed  - flag to set if file is changed
Options for specifying the file's permissions are:
  :owner user-name
  :group group-name
  :mode  file-mode
To copy the content of a local file to a remote file:
    (remote-file session \"remote/path\" :local-file \"local/path\")
To copy the content of one remote file to another remote file:
    (remote-file session \"remote/path\" :remote-file \"remote/source/path\")
To link one remote file to another remote file:
    (remote-file session \"remote/path\" :link \"remote/source/path\")
To download a url to a remote file:
    (remote-file session \"remote/path\" :url \"http://a.com/path\")
If a url to a md5 file is also available, then it can be specified to prevent
unnecessary downloads and to verify the download.
    (remote-file session \"remote/path\"
      :url \"http://a.com/path\"
      :md5-url \"http://a.com/path.md5\")
If the md5 of the file to download, it can be specified to prevent unnecessary
downloads and to verify the download.
    (remote-file session \"remote/path\"
      :url \"http://a.com/path\"
      :md5 \"6de9439834c9147569741d3c9c9fc010\")
Content can also be copied from a blobstore.
    (remote-file session \"remote/path\"
      :blob {:container \"container\" :path \"blob\"})"
  [session path & {:keys [action url local-file remote-file link
                          content literal
                          template values
                          md5 md5-url
                          owner group mode force
                          blob blobstore
                          overwrite-changes no-versioning max-versions
                          flag-on-changed
                          local-file-options]
                   :as options}]
  (when-let [f (and local-file (io/file local-file))]
    (when (not (and (.exists f) (.isFile f) (.canRead f)))
      (throw (IllegalArgumentException.
              (format
               (str "'%s' does not exist, is a directory, or is unreadable; "
                    "cannot register it for transfer.")
               local-file)))))
  (->
   session
   (when-> local-file
           ;; transfer local file to remote system if required
           (transfer-file local-file (str path ".new") local-file-options))
   (action/with-precedence local-file-options
     (apply-map->
      remote-file-action path
      (merge
       {:overwrite-changes force-overwrite} ;; capture the value of the flag
       options)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.rsync" name="pallet.action.rsync"><h1 class="project-name">pallet.action.rsync</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.rsync
  (:require
   [pallet.action :as action]
   [pallet.action.directory :as directory]
   [pallet.action.package :as package]
   [pallet.compute :as compute]
   [pallet.execute :as execute]
   [pallet.session :as session]
   [pallet.utils :as utils]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def cmd "/usr/bin/rsync -e '%s' -rP --delete --copy-links -F -F %s %s@%s:%s")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-clj-action rsync
  [session from to {:keys [port]}]
  (logging/info (format "rsync %s to %s" from to))
  (let [ssh (str "/usr/bin/ssh -o \"StrictHostKeyChecking no\" "
                 (if port (format "-p %s" port)))
        cmd (format
             cmd ssh from (:username utils/*admin-user*)
             (compute/primary-ip (session/target-node session)) to)]
    (execute/sh-script cmd)
    session))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn rsync-directory
  "Rsync from a local directory to a remote directory."
  [session from to & {:keys [owner group mode port] :as options}]
  (->
   session
   (package/package "rsync")
   (directory/directory to :owner owner :group group :mode mode)
   (rsync from to options)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.service" name="pallet.action.service"><h1 class="project-name">pallet.action.service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Service control.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.service
  (:use clojure.contrib.logging)
  (:require
   [pallet.action :as action]
   [pallet.action.remote-file :as remote-file]
   [pallet.script :as script]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [clojure.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action service
  "Control services.
   - :action  accepts either startstop, restart, enable or disable keywords.
   - :if-flag  makes start, stop, and restart confitional on the specified flag
               as set, for example, by remote-file :flag-on-changed
   - :sequence-start  a sequence of [sequence-number level level ...], where
                      sequence number determines the order in which services
                      are started within a level."
  [session service-name & {:keys [action if-flag]
                           :or {action :start}
                           :as options}]
  (if (#{:enable :disable :start-stop} action)
    (stevedore/checked-script
     (format "Configure service %s" service-name)
     (~lib/configure-service ~service-name ~action ~options))
    (if if-flag
      (stevedore/script
       (if (== "1" (lib/flag? ~if-flag))
         (~(str (stevedore/script (~lib/etc-init)) "/" service-name)
          ~(name action))))
      (stevedore/script
       (~(str (stevedore/script (~lib/etc-init)) "/" service-name)
        ~(name action))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-restart
  "Stop the given service, execute the body, and then restart."
  [session service-name & body]
  `(let [service# ~service-name]
     (-> ~session
         (service service# :action :stop)
         ~@body
         (service service# :action :start))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn init-script
  "Install an init script.  Sources as for remote-file."
  [session name & {:keys [action url local-file remote-file link
                          content literal template values md5 md5-url force]
                   :or {action :create}
                   :as options}]
  (apply
   remote-file/remote-file
   session
   (str (stevedore/script (~lib/etc-init)) "/" name)
   :action action :owner "root" :group "root" :mode "0755"
   (apply concat options)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action.user" name="pallet.action.user"><h1 class="project-name">pallet.action.user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>User management action.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action.user
  (:use
   [pallet.script :only [defscript]]
   [clojure.contrib.def :only [defvar-]])
  (:require
   [pallet.action :as action]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [clojure.contrib.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defvar- shell-names
  {:bash "/bin/bash" :csh "/bin/csh" :ksh "/bin/ksh" :rsh "/bin/rsh"
   :sh "/bin/sh" :tcsh "/bin/tcsh" :zsh "/bin/zsh" :false "/bin/false"}
  "Map for looking up shell path based on keyword.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn user*
  "Require a user"
  [session username & {:keys [action shell base-dir home system create-home
                              password shell comment groups remove force]
                       :or {action :manage}
                       :as options}]
  (let [opts (merge options {:shell (get shell-names shell shell)})]
    (case action
      :create
      (stevedore/script
       (if-not (~lib/user-exists? ~username)
         (~lib/create-user
          ~username ~(select-keys opts [:base-dir :home :system :comment
                                        :create-home :password :shell
                                        :group :groups]))))
      :manage
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/modify-user
          ~username ~(select-keys opts [:home :shell :comment :group :groups]))
         (~lib/create-user
          ~username ~(select-keys opts [:base-dir :home :system :comment
                                        :create-home :pasword :shell
                                        :group :groups]))))
      :lock
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/lock-user ~username)))
      :unlock
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/unlock-user ~username)))
      :remove
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/remove-user ~username ~(select-keys opts [:remove :force]))))
      (throw (IllegalArgumentException.
              (str action " is not a valid action for user action"))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-aggregated-action user
  "User management."
  [session user-args]
  {:arglists (:arglists (meta pallet.action.user/user*))
   :always-after #{`group}}
  (string/join \newline (map #(apply user* session %) user-args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-bash-action group
  "User Group Management."
  [session groupname & {:keys [action system gid password]
                        :or {action :manage}
                        :as options}]
  (case action
    :create
    (stevedore/script
     (if-not (~lib/group-exists? ~groupname)
       (~lib/create-group
        ~groupname ~(select-keys options [:system :gid :password]))))
    :manage
    (stevedore/script
     (if (~lib/group-exists? ~groupname)
       (~lib/modify-group
        ~groupname ~(select-keys options [:gid :password]))
       (~lib/create-group
        ~groupname ~(select-keys options [:system :gid :password]))))
    :remove
    (stevedore/script
     (if (~lib/group-exists? ~groupname)
       (~lib/remove-group ~groupname {})))
    (throw (IllegalArgumentException.
            (str action " is not a valid action for group action")))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action" name="pallet.action"><h1 class="project-name">pallet.action</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions implement the conversion of phase functions to script and other
   execution code.</p>

<p>   An action has a :action-type. Known types include :script/bash
   and :fn/clojure.</p>

<p>   An action has a :location, :origin for execution on the node running
   pallet, and :target for the target node.</p>

<p>   An action has an :execution, which is one of :aggregated, :in-sequence or
   :collected. Calls to :aggregated actions will be grouped, and run before
   :in-sequence actions. Calls to :collected actions will be grouped, and run
   after :in-sequence actions.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action
  {:author "Hugo Duncan"}
  (:require
   [pallet.action-plan :as action-plan]
   [pallet.argument :as argument]
   [pallet.session :as session]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.def :as ccdef]
   [clojure.contrib.logging :as logging]
   [clojure.contrib.seq :as seq]
   [clojure.set :as set]
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>action defining functions</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn schedule-action
  "Registers an action in the action plan. The action is generated by the
   specified action function and arguments that will be applied to the function
   when the action plan is executed.
   The action can be scheduled within one of three 'executions'
   (conceptually, sub-phases):
   :in-sequence - The generated action will be applied to the node
        \"in order\", as it is defined lexically in the source crate.
        This is the default.
   :aggregated - All aggregated actions are applied to the node
        in the order they are defined, but before all :in-sequence
        actions. Note that all of the arguments to any given
        action function are gathered such that there is only ever one
        invocation of each fn within each phase.
   :collected - All collected actions are applied to the node
        in the order they are defined, but after all :in-sequence
        action. Note that all of the arguments to any given
        action function are gathered such that there is only ever one
        invocation of each fn within each phase.
   The action-type determines how the action should be handled:
   :script/bash - action produces bash script for execution on remote machine
   :fn/clojure  - action is a function for local execution
   :transfer/to-local - action is a function specifying remote source
                        and local destination.
   :transfer/from-local - action is a function specifying local source
                          and remote destination."
  [session action-fn metadata args execution action-type location]
  {:pre [session
         (keyword? (session/phase session))
         (keyword? (session/target-id session))]}
  (update-in
   session
   (action-plan/target-path session)
   action-plan/add-action
   (action-plan/action-map
    action-fn metadata args execution action-type location)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def precedence-key :action-precedence)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-precedence
  "Set up local precedence relations between actions"
  [request m & body]
  `(let [request# ~request]
     (->
      request#
      (update-in [precedence-key] merge ~m)
      ~@body
      (assoc-in [precedence-key] (get-in request# [precedence-key])))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- force-set [x] (if (or (set? x) (nil? x)) x #{x}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn action-metadata
  "Compute action metadata from precedence specification in session"
  [session f]
  (merge-with
   #(set/union
     (force-set %1)
     (force-set %2))
   (:meta f)
   (precedence-key session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro action
  "Define an anonymous action"
  [execution action-type location [session & args] & body]
  (let [meta-map (when (and (map? (first body)) (> (count body) 1))
                   (first body))
        body (if meta-map (rest body) body)]
    `(let [f# (vary-meta
               (fn ~@(when-let [an (:action-name meta-map)]
                       [(symbol (str an "-action-fn"))])
                 [~session ~@args] ~@body) merge ~meta-map)]
       (vary-meta
        (fn [& [session# ~@args :as argv#]]
          (schedule-action
           session#
           f#
           (action-metadata session# f#)
           (rest argv#) ~execution ~action-type ~location))
        merge
        ~meta-map
        {::action-fn f#}))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn action-fn
  "Retrieve the action-fn that is used to execute the specified action."
  [action]
  (::action-fn (meta action)))</pre></tr><tr><td class="docs"><p>Convenience action definers for common cases</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro bash-action
  "Define a remotely executed bash action function."
  [[session & args] & body]
  `(action :in-sequence :script/bash :target [~session ~@args] ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro clj-action
  "Define a clojure action to be executed on the origin machine."
  [[session & args] & body]
  `(action :in-sequence :fn/clojure :origin [~session ~@args] ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro aggregated-action
  "Define a remotely executed aggregated action function, which will
   be executed before :in-sequence actions."
  [[session & args] & body]
  `(action :aggregated :script/bash :target [~session ~@args] ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro collected-action
  "Define a remotely executed collected action function, which will
   be executed after :in-sequence actions."
  [[session & args] & body]
  `(action :collected :script/bash :target [~session ~@args] ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro as-clj-action
  "An adaptor for using a normal function as a local action function"
  ([f [session & args]]
     `(clj-action
       [~session ~@(map (comp symbol name) args)]
       (~f ~session ~@(map (comp symbol name) args))))
  ([f]
     `(as-clj-action
       ~f [~@(first (:arglists (meta (var-get (resolve f)))))])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro def-action-def
  "Define a macro for definining action defining vars"
  [name actionfn1]
  `(defmacro ~name
     {:arglists '(~'[name [session & args] & body]
                  ~'[name [session & args] meta? & body])}
     [name# ~'& args#]
     (let [[name# args#] (ccdef/name-with-attributes name# args#)
           arglist# (first args#)
           body# (rest args#)
           [meta-map# body#] (if (and (map? (first body#))
                                        (> (count body#) 1))
                               [(merge
                                 {:action-name (name name#)} (first body#))
                                (rest body#)]
                               [{:action-name (name name#)} body#])
           name# (vary-meta
                  name#
                  #(merge
                    {:arglists (list 'quote (list arglist#))}
                    meta-map#
                    %))]
       `(def ~name# (~'~actionfn1 [~@arglist#] ~meta-map# ~@body#)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def-action-def def-bash-action pallet.action/bash-action)
(def-action-def def-clj-action pallet.action/clj-action)
(def-action-def def-aggregated-action pallet.action/aggregated-action)
(def-action-def def-collected-action pallet.action/collected-action)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn enter-scope
  "Enter a new action scope."
  [session]
  (update-in session (action-plan/target-path session) action-plan/push-block))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn leave-scope
  "Leave the current action scope."
  [session]
  (update-in session (action-plan/target-path session) action-plan/pop-block))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action-plan" name="pallet.action-plan"><h1 class="project-name">pallet.action-plan</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>An action plan contains actions for execution.</p>

<p>   The action plan is built by executing a phase function. Each phase function
   calls actions which insert themselves into the action plan.</p>

<p>   The action plan is transformed to provide aggregated operations, and to
   resolve precedence relations between actions.</p>

<p>   A translated plan is executed by passing an executor, which is a map
   from action type to function.  The executor functions are called with the
   result of evaluating the action with it's arguments.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.action-plan
  {:author "Hugo Duncan"}
  (:require
   [pallet.argument :as argument]
   [pallet.phase :as phase]
   [pallet.script :as script]
   [pallet.session :as session]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging]
   [clojure.set :as set]
   [clojure.string :as string])
  (:use
   [clojure.contrib.def :only [defunbound defvar defvar- name-with-attributes]]
   clojure.contrib.core))</pre></tr><tr><td class="docs"><p>The action plan is a stack of actions, where the action could itself
be a stack of actions (ie a tree of stacks)</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Push a block onto the action-plan</p>
</td><td class="codes" /><pre class="brush: clojure">(defn push-block
  [action-plan]
  (conj (or action-plan '(nil nil)) nil))</pre></tr><tr><td class="docs"><p>Take the last block and add it to the scope below it in the stack.
   The block is reversed to put it into the order in which elements
   were added. Once pop'd, nothing should be added to the block.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pop-block
  [action-plan]
  (let [block (peek action-plan)
        stack (pop action-plan)]
    (if-let [stem (next stack)]
      (conj stem (conj (first stack) (reverse block)))
      (if-let [stem (seq (first stack))]
        (conj stem (reverse block))
        (reverse block)))))</pre></tr><tr><td class="docs"><p>Add an action to the plan</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-action
  [action-plan action]
  (let [action-plan (or action-plan '(nil nil))
        block (peek action-plan)
        stack (pop action-plan)]
    (conj stack (conj block action))))</pre></tr><tr><td class="docs"><p>Return an action map for the given args. The action plan is a tree of
   action maps.</p>

<p>   precedence specifies naming and dependencies, with :action-id, :always-before
   and :always-after. If a precedence is supplied, an action-id is generated
   if none present, to ensure that the standard action precedence is not
   altered.</p>

<ul>
<li>:f            the action function</li>
<li>:args         the arguments to pass to the action function</li>
<li>:location     where to execute the action - :orgin or :target</li>
<li>:action-type  the type of action - :script/bash, :fn/clojure, etc</li>
<li>:execution    the execution type - :in-sequence, :aggregated, :collected</li>
<li>:value        the result of calling the action function, :f, with :args</li>
<li>:session      the session map after calling the action function.</li>
</ul>

<p>pallet specific action</p>
</td><td class="codes" /><pre class="brush: clojure">(defn action-map
  [action-fn precedence args execution action-type location]
  (let [precedence (and precedence (seq precedence)
                        (update-in precedence [:action-id]
                                   #(or % (gensym "action-id"))))]
    (merge
     (select-keys (meta action-fn) [:action-id :always-after :always-before])
     precedence
     {:f action-fn
      :args args
      :location location
      :action-type action-type
      :execution execution})))</pre></tr><tr><td class="docs"><p>utilities</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Concatenate multiple scripts, removing blank lines</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- script-join
  [scripts]
  (str
   (->>
    scripts
    (map #(when % (string/trim %)))
    (filter (complement string/blank?))
    (string/join \newline))
   \newline))</pre></tr><tr><td class="docs"><p>transform functions for working with an action-plan containing action-maps
with :nested-scope types</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Traverses an action-plan structure.  leaf-fn is applied to leaf
   action, list-fn to sequences of actions, and nested-fn to
   a nested scope. nested-fn takes the existing nested scope and a transformed
   arg list</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- walk-action-plan
  [leaf-fn list-fn nested-fn action-plan]
  (cond
   (sequential? action-plan) (list-fn
                              (map
                               #(walk-action-plan leaf-fn list-fn nested-fn %)
                               action-plan))
   (= :nested-scope (:action-type action-plan)) (nested-fn
                                                 action-plan
                                                 (walk-action-plan
                                                  leaf-fn list-fn nested-fn
                                                  (:args action-plan)))
   :else (leaf-fn action-plan)))</pre></tr><tr><td class="docs"><p>transform input nested scopes into action maps with :action-type of
:nested-scope</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>A scope combining action.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- scope-action
  [session & args]
  (script-join (map #((:f %) session) args)))</pre></tr><tr><td class="docs"><p>Transform a nested scope into an action-map with :action-type :nested-scope</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- nested-scope-transform
  [x]
  {:pre [(sequential? x)]}
  {:f scope-action
   :args x
   :action-type :nested-scope
   :execution :in-sequence
   :location :target})</pre></tr><tr><td class="docs"><p>Traverses an action-plan structure. Converting nested scopes into
   action-map's.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn transform-nested-scopes
  [action-plan]
  (cond
   (sequential? action-plan) (nested-scope-transform
                              (vec (map transform-nested-scopes action-plan)))
   :else action-plan))</pre></tr><tr><td class="docs"><p>Transforms nexted scopes into an action map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- transform-scopes
  [action-plan]
  (map transform-nested-scopes action-plan))</pre></tr><tr><td class="docs"><p>transform executions</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Transforms a seq of actions, generally some with identical :f values into a
   sequence of actions where the :args are the concatenation of all of the :args
   of associated with each :f in the original seq.  Sequence order from the
   original seq is retained. Keys over than :f and :args are assumed identical
   for a given :f value.</p>

<p>   e.g. (group-by-function
           [{:f :a :args [1 2]}
            {:f :b :args [3 4]}
            {:f :a :args [5 6]}
            {:f :c :args [7 8]]])
        => ({:f :a :args ([1 2] [5 6])}
            {:f :c :args ([7 8])}
            {:f :b :args ([3 4])})</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- group-by-function
  [action-plan]
  (->>
   action-plan
   (group-by (juxt :f :action-id))
   (map (fn [[_ action-calls]]
          (reduce
           #(update-in %1 [:args] conj (:args %2))
           (assoc (first action-calls) :args [])
           action-calls)))))</pre></tr><tr><td class="docs"><p>Execution specifc transforms</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc  :private true}
  execution-transforms
  {:aggregated [group-by-function]
   :collected [group-by-function]})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defvar- execution-ordering [:aggregated :in-sequence :collected])</pre></tr><tr><td class="docs"><p>Transform an execution by applying execution-transforms.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- transform-execution
  [execution action-plan]
  (if-let [transforms (execution-transforms execution)]
    (reduce #(%2 %1) action-plan transforms)
    action-plan))</pre></tr><tr><td class="docs"><p>Sort an action plan scope into different executions, applying execution
   specific transforms.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- transform-scope-executions
  [action-plan]
  (let [executions (group-by :execution action-plan)]
    (mapcat
     #(transform-execution % (% executions))
     execution-ordering)))</pre></tr><tr><td class="docs"><p>Sort an action plan into different executions, applying execution specific
   transforms.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- transform-executions
  [action-plan]
  (walk-action-plan
   identity
   transform-scope-executions
   #(assoc %1 :args %2)
   action-plan))</pre></tr><tr><td class="docs"><p>Lookup the action-fn from a symbol</p>

<p>enforce declared precedence rules</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- symbol-action-fn
  [sym]
  (if-let [v (find-var sym)]
    (-> v var-get meta :pallet.action/action-fn)))</pre></tr><tr><td class="docs"><p>Extract an action's id to function mapping</p>
</td><td class="codes" /><pre class="brush: clojure">(defn collect-action-id
  [m action]
  (if-let [id (:action-id action)]
    (assoc m id (:f action))
    m))</pre></tr><tr><td class="docs"><p>Merge-with clojure.set/union</p>
</td><td class="codes" /><pre class="brush: clojure">(defn merge-union
  [& m]
  (apply merge-with set/union m))</pre></tr><tr><td class="docs"><p>Extract an action's dependencies.  Actions are id'd with keywords,
   and dependencies are declared on an action's id or function.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn action-dependencies
  [action-id-map action]
  (let [as-set (fn [x] (if (or (nil? x) (set? x)) x #{x}))
        before (as-set (:always-before action))
        after (as-set (:always-after action))
        self-id (select-keys action [:action-id :f])]
    (reduce
     (fn [m [id deps]] (update-in m [id] #(conj (or % #{}) deps)))
     {}
     (concat
      ;; before symbol
      (map
       #(vector {:f %} self-id)
       (map symbol-action-fn (filter symbol? before)))
      ;; before id
      (map
       #(vector {:action-id % :f (action-id-map %)} self-id)
       (filter keyword? before))
      ;; after symbol
      (map
       #(vector self-id {:f %})
       (map symbol-action-fn (filter symbol? after)))
      ;; after id
      (map
       #(vector self-id {:action-id % :f (action-id-map %)})
       (filter keyword? after))))))</pre></tr><tr><td class="docs"><p>Given a map of dependencies, each with an :f and maybe a :action-id,
   returns a map where the values are all matching action instances</p>
</td><td class="codes" /><pre class="brush: clojure">(defn action-instances
  [actions dependencies]
  (let [action-id-maps (reduce set/union (vals dependencies))]
    (reduce
     (fn [instances instance]
       (let [id (select-keys instance [:f :action-id])]
         (if (action-id-maps id)
           (update-in instances [id] #(conj (or % #{}) instance))
           instances)))
     {}
     actions)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn action-scope-dependencies
  [actions]
  (let [action-id-map (reduce collect-action-id {} actions)
        dependencies (reduce
                      #(merge-union %1 (action-dependencies action-id-map %2))
                      {} actions)
        instances (action-instances actions dependencies)
        dependents (zipmap (keys dependencies)
                           (map
                            (fn [d] (set (mapcat instances d)))
                            (vals dependencies)))]
    [action-id-map dependencies instances dependents]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn action-with-dependents
  [actions dependents seen action]
  {:pre [(vector? actions) (set? seen) (map? action)]}
  (if (seen action)
    [actions dependents seen]
    (let [ids (distinct [(select-keys action [:f :action-id])
                         (select-keys action [:f])])
          action-deps (mapcat dependents ids)]
      (let [[add-actions dependents seen]
            (reduce
             (fn add-a-w-d [[actions dependents seen] action]
               {:pre [(vector? actions) (set? seen) (map? action)]}
               (if (seen action)
                 [actions dependents seen]
                 (action-with-dependents actions dependents seen action)))
             [actions (reduce dissoc dependents ids) seen]
             action-deps)]
        [(conj add-actions action) dependents (conj seen action)]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn enforce-scope-dependencies
  [actions]
  (let [[action-id-map dependencies instances dependents]
        (action-scope-dependencies actions)]
    (first (reduce
            (fn add-as-w-d [[actions dependents seen] action]
              {:pre [(vector? actions) (set? seen) (map? action)]}
              (if (seen action)
                [actions dependents seen]
                (action-with-dependents actions dependents seen action)))
            [[] dependents #{}]
            actions))))</pre></tr><tr><td class="docs"><p>Enforce precedence relations between actions.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- enforce-precedence
  [action-plan]
  (walk-action-plan
   identity
   enforce-scope-dependencies
   #(assoc %1 :args %2)
   action-plan))</pre></tr><tr><td class="docs"><p>convert nested-scopes to script functions</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Convert a scope to a single script function</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- script-type-scope
  [action-map]
  (if (= :nested-scope (:action-type action-map))
    (assoc action-map :action-type :script/bash :target)
    action-map))</pre></tr><tr><td class="docs"><p>Reduce a nested scopes of a single scope to a compound action</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- script-type-scopes-in-scope
  [action-plan]
  (map script-type-scope action-plan))</pre></tr><tr><td class="docs"><p>Reduce nested scopes to a compound action</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- script-type-scopes
  [action-plan]
  (walk-action-plan
   identity
   script-type-scopes-in-scope
   (fn [action _] action)
   action-plan))</pre></tr><tr><td class="docs"><p>Bind arguments</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Evaluate an argument sequence</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- evaluate-args
  [session args]
  (map (fn [arg] (when arg (argument/evaluate arg session))) args))</pre></tr><tr><td class="docs"><p>Returns a function that applies args to the function f,
   evaluating the arguments.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-action
  [f args]
  (fn [session]
    (apply f session (evaluate-args session args))))</pre></tr><tr><td class="docs"><p>Apply args-seq to the function f, evaluating each argument list in args-seq.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-aggregated-action
  [f args-seq]
  (fn [session]
    (f session (map #(evaluate-args session %) args-seq))))</pre></tr><tr><td class="docs"><p>Bind an action's arguments.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti bind-action-arguments
  (fn [{:keys [execution]}] execution))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod bind-action-arguments :in-sequence
  [{:keys [f args] :as action-map}]
  (->
   action-map
   (update-in [:f] apply-action args)
   (dissoc :args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod bind-action-arguments :aggregated
  [{:keys [f args] :as action-map}]
  (->
   action-map
   (update-in [:f] apply-aggregated-action args)
   (dissoc :args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod bind-action-arguments :collected
  [{:keys [f args] :as action-map}]
  (->
   action-map
   (update-in [:f] apply-aggregated-action args)
   (dissoc :args)))</pre></tr><tr><td class="docs"><p>Takes an action plan scope and binds each actions arguments</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- bind-scope-arguments
  [action-plan]
  (map bind-action-arguments action-plan))</pre></tr><tr><td class="docs"><p>Takes an action plan and binds each actions arguments</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- bind-arguments
  [action-plan]
  (walk-action-plan
   identity
   bind-scope-arguments
   #(assoc %1 :args %2)
   action-plan))</pre></tr><tr><td class="docs"><p>Combine actions by action-type</p>

<p>combine by location and action-type</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti combine-actions
  (fn [actions] (:action-type (first actions))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod combine-actions :default
  [actions]
  (reduce
   (fn combine-actions-compose [combined action]
     (update-in combined [:f] #(comp (:f action) %)))
   actions))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod combine-actions :script/bash
  [actions]
  (assoc (first actions)
    :f (fn [session] (script-join (map #((:f %) session) actions)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod combine-actions :transfer/to-local
  [actions]
  (assoc (first actions)
    :f (fn [session] (map #((:f %) session) actions))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod combine-actions :transfer/from-local
  [actions]
  (assoc (first actions)
    :f (fn [session] (map #((:f %) session) actions))))</pre></tr><tr><td class="docs"><p>Combines the bound actions of a scope by location and action-type, producing
  compound actions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- combine-scope-by-location-and-action-type
  [action-plan]
  (->>
   action-plan
   (partition-by (juxt :location :action-type))
   (map combine-actions)))</pre></tr><tr><td class="docs"><p>Combines bound actions by location and action-type, producing compound
  actions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- combine-by-location-and-action-type
  [action-plan]
  (walk-action-plan
   identity
   combine-scope-by-location-and-action-type
   #(assoc %1 :args %2)
   action-plan))</pre></tr><tr><td class="docs"><p>Change the return type of an action, to be an action map with
   :value and :session keys that are the value of the action, and the updated
   session map for the next action.  This creates a consistent return value for
   all action types (effectively creating a monadic value which is a map).</p>

<p>augment return</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti augment-return
  (fn [{:keys [action-type] :as action}] action-type))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod augment-return :default
  [{:keys [f] :as action}]
  (assoc action
    :f (fn [session]
         (assoc action
           :session session
           :value (f session)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod augment-return :fn/clojure
  [{:keys [f] :as action}]
  (assoc action
    :f (fn [session]
         (let [session (f session)]
           (assoc action
             :session session
             :value session)))))</pre></tr><tr><td class="docs"><p>Augment the return values of each action in a scope.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- augment-scope-return-values
  [action-plan]
  (map augment-return action-plan))</pre></tr><tr><td class="docs"><p>Augment the return values of each action.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- augment-return-values
  [action-plan]
  (walk-action-plan
   identity
   augment-scope-return-values
   #(assoc %1 :args %2)
   action-plan))</pre></tr><tr><td class="docs"><p>Process the action-plan, applying groupings and precedence, producing
   an action plan with fully bound functions, ready for execution.</p>

<p>   This is equivalent to using an identity monad with a monadic value
   that is a tree of action maps.</p>

<p>translate action plan</p>
</td><td class="codes" /><pre class="brush: clojure">(defn translate
  [action-plan]
  (->
   action-plan
   pop-block ;; pop the default block
   transform-scopes
   transform-executions
   enforce-precedence
   bind-arguments
   combine-by-location-and-action-type
   script-type-scopes
   augment-return-values))</pre></tr><tr><td class="docs"><p>Predicate to test if an action plan has been translated</p>

<p>execute action plan</p>
</td><td class="codes" /><pre class="brush: clojure">(defn translated?
  [action-plan]
  (not (and (= 2 (count action-plan))
            (list? (first action-plan))
            (nil? (second action-plan)))))</pre></tr><tr><td class="docs"><p>Execute a single action</p>
</td><td class="codes" /><pre class="brush: clojure">(defn execute-action
  [executor [results session] {:keys [f action-type location] :as action}]
  (let [[result session] (executor session f action-type location)]
    [(conj results result) session]))</pre></tr><tr><td class="docs"><p>Execute actions by passing the un-evaluated actions to the <code>executor</code>
   function (a function with an arglist of [session f action-type location]).</p>
</td><td class="codes" /><pre class="brush: clojure">(defn execute
  [action-plan session executor]
  (when-not (translated? action-plan)
    (condition/raise
     :type :pallet/execute-called-on-untranslated-action-plan
     :message "Attempt to execute an action plan that has not been translated"))
  (reduce #(execute-action executor %1 %2) [[] session] action-plan))</pre></tr><tr><td class="docs"><p>Return the vector path of the action plan for the specified phase an
  target-id.</p>

<p>Target specific functions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- target-path*
  [phase target-id]
  [:action-plan phase target-id])</pre></tr><tr><td class="docs"><p>Return the vector path of the action plan for the current session target
   node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-path
  [session]
  {:pre [(keyword? (session/phase session))
         (keyword? (session/target-id session))]}
  (target-path* (session/phase session) (session/target-id session)))</pre></tr><tr><td class="docs"><p>Return the script template for the specified server.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn script-template-for-server
  [server]
  (let [family (-> server :image :os-family)]
    (filter identity
            [family
             (:packager server)
             (when-let [version (-> server :image :os-version)]
               (keyword (format "%s-%s" (name family) version)))])))</pre></tr><tr><td class="docs"><p>Return the script template for the current group node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn script-template
  [session]
  (script-template-for-server (:server session)))</pre></tr><tr><td class="docs"><p>action plan functions based on session</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Reset the action plan for the current phase and target node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn reset-for-target
  [session]
  {:pre [(:phase session)]}
  (reduce
   #(assoc-in %1 (target-path* %2 (session/target-id session)) nil)
   session
   (phase/all-phases-for-phase (:phase session))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn build-for-target
  "Create the action plan by calling the current phase for the target group."
  [session]
  {:pre [(:phase session)]}
  (let [phase (:phase session)]
    (if-let [f (or
                (phase (-> session :server :phases))
                (phase (:inline-phases session)))]
      (script/with-script-context (script-template session)
        (f (reset-for-target session)))
      session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-for-target
  "Get the action plan for the current phase and target node."
  [session]
  (get-in session (target-path session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn translate-for-target
  "Build the action plan and translate for the current phase and target node."
  [session]
  {:pre [(:phase session)]}
  (update-in session (target-path session) translate))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn execute-for-target
  "Execute the translated action plan for the current target."
  [session executor]
  {:pre [(:phase session)]}
  (script/with-script-context (script-template session)
    (execute
     (get-in session (target-path session)) session executor)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.argument" name="pallet.argument"><h1 class="project-name">pallet.argument</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Arguments to actions.  Adds capability of evaluating arguments at
   action application</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.argument)</pre></tr><tr><td class="docs"><p>A protocol for passing arguments, with delayed evaluation.</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol DelayedArgument
  (evaluate [x session]))</pre></tr><tr><td class="docs"><p>By default, arguments should evaluate to themeselves</p>
</td><td class="codes" /><pre class="brush: clojure">(extend-type
 Object
 DelayedArgument
 (evaluate [x session] x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype DelayedFunction
  [f]
  DelayedArgument
  (evaluate [_ session] (f session)))</pre></tr><tr><td class="docs"><p>Pass a function with a single argument, to be used to compute an argument at
   action application time.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn delayed-fn
  [f]
  (DelayedFunction. f))</pre></tr><tr><td class="docs"><p>Pass an argument to be evaluated at action application time.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro delayed
  [[session-sym] & body]
  `(DelayedFunction. (fn [~session-sym] ~@body)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.implementation" name="pallet.blobstore.implementation"><h1 class="project-name">pallet.blobstore.implementation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation details</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore.implementation
  (:require
   [pallet.utils :as utils]
   [clojure.contrib.find-namespaces :as find-namespaces]))</pre></tr><tr><td class="docs"><p>Instantiate a blobstore. Providers should implement a method for this.
   See pallet.blobstore/blobstore-service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti service
  (fn [provider-name & _] (keyword provider-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def blobstore-regex #"^pallet\.blobstore\.[a-z-]+")
(def exclude-blobstore-ns
  #{'pallet.blobstore.implementation})
(def exclude-regex #".*test.*")
(def provider-list (atom nil))</pre></tr><tr><td class="docs"><p>Find the available providers.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- providers
  []
  (try
    (binding [clojure.contrib.classpath/classpath utils/classpath]
      (->> (find-namespaces/find-namespaces-on-classpath)
           (filter #(re-find blobstore-regex (name %)))
           (remove #(re-find exclude-regex (name %)))
           (remove exclude-blobstore-ns)
           (set)))
    (catch java.io.FileNotFoundException _)))</pre></tr><tr><td class="docs"><p>Require all providers, ensuring no errors if individual providers can not be
   loaded</p>
</td><td class="codes" /><pre class="brush: clojure">(defn load-providers
  []
  (when-not @provider-list
    (reset! provider-list (providers))
    (let [loaded (filter
                  identity
                  (doall
                   (for [provider @provider-list]
                     (try
                       (require provider)
                       provider
                       (catch Throwable _)))))]
      (reset! provider-list loaded)))
  @provider-list)</pre></tr><tr><td class="docs"><p>Create a list of supported providers</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers
  []
  (->>
   (doall
    (for [provider (load-providers)]
      (when-let [providers (ns-resolve provider 'supported-providers)]
        (@providers))))
   (filter identity)
   (apply concat)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.jclouds" name="pallet.blobstore.jclouds"><h1 class="project-name">pallet.blobstore.jclouds</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>jclouds blobstore implementation</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore.jclouds
  (:require
   [org.jclouds.blobstore :as jclouds-blobstore]
   [pallet.blobstore.implementation :as implementation]
   [pallet.compute.jvm :as jvm]))</pre></tr><tr><td class="docs"><p>Default extensions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-jclouds-extensions
  []
  (if (jvm/log4j?)
    [:log4j]
    []))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :default
  [provider {:keys [identity credential extensions]
             :or {identity 
                  credential 
                  extensions (default-jclouds-extensions)}}]
  (apply jclouds-blobstore/blobstore
         provider identity credential extensions))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type org.jclouds.blobstore.BlobStore
  pallet.blobstore/Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   (let [request (jclouds-blobstore/sign-blob-request
                  container path request-map blobstore)]
     {:endpoint (.getEndpoint request)
      :headers (.. request getHeaders entries)}))
  (put-file
   [blobstore container path file]
   (when-not (jclouds-blobstore/container-exists? container blobstore)
     (jclouds-blobstore/create-container container nil blobstore))
   (jclouds-blobstore/upload-blob
    container path (java.io.File. file) blobstore))
  (containers [blobstore] (jclouds-blobstore/containers blobstore))
  (close [blobstore] (.. blobstore getContext close)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.url-blobstore" name="pallet.blobstore.url-blobstore"><h1 class="project-name">pallet.blobstore.url-blobstore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A url based blobstore implementation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore.url-blobstore
  (:require
   [pallet.blobstore :as blobstore]
   [pallet.blobstore.implementation :as implementation]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord UrlBlobstore
    [base-url]
  pallet.blobstore/Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   {:endpoint (format "%s/%s/%s" base-url container path)
    :headers nil})
  (close
   [blobstore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :url-blobstore
  [provider {:keys [base-url]
             :or {base-url "http://localhost"}}]
  (UrlBlobstore. base-url))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore" name="pallet.blobstore"><h1 class="project-name">pallet.blobstore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Blobstore abstraction</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore
  (:require
   [pallet.blobstore.implementation :as implementation]
   [pallet.configure :as configure]))</pre></tr><tr><td class="docs"><p>Instantiate a blobstore service based on the given arguments</p>

<p>Compute Service instantiation</p>
</td><td class="codes" /><pre class="brush: clojure">(defn service
  [provider-name
   & {:keys [identity credential extensions] :as options}]
  (implementation/load-providers)
  (implementation/service provider-name options))</pre></tr><tr><td class="docs"><p>Translate compute provider to associated blobstore provider</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc }
  blobstore-lookup
  {"cloudservers" "cloudfiles"
   "cloudservers-us" "cloudfiles-us"
   "cloudservers-eu" "cloudfiles-eu"
   "ec2" "s3"
   "aws-ec2" "aws-s3"})</pre></tr><tr><td class="docs"><p>Create a blobstore service from a credentials map.
   Uses :provider, :identity, :credential and
   :blobstore-provider, :blobstore-identity and :blobstore-credential.
   Blobstore keys fall back to the compute keys</p>
</td><td class="codes" /><pre class="brush: clojure">(defn blobstore-from-map
  [credentials]
  (when-let [provider (or (:blobstore-provider credentials)
                          (blobstore-lookup (:provider credentials)))]
    (service
     provider
     :identity (or (:blobstore-identity credentials)
                   (:identity credentials))
     :credential (or (:blobstore-credential credentials)
                     (:credential credentials)))))</pre></tr><tr><td class="docs"><p>Create a blobstore service from ~/.m2/settings.xml propery settings.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn blobstore-from-settings
  [& profiles]
  (try
    (require 'pallet.maven) ; allow running without maven jars
    (when-let [f (ns-resolve 'pallet.maven 'credentials)]
      (blobstore-from-map (f profiles)))
    (catch ClassNotFoundException _)
    (catch clojure.lang.Compiler$CompilerException _)))</pre></tr><tr><td class="docs"><p>Create a blobstore service form a configuration map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn blobstore-from-config
  [config profiles]
  (let [config (configure/compute-service-properties config profiles)
        {:keys [provider identity credential]} (merge
                                                (update-in
                                                 config [:provider]
                                                 (fn [p]
                                                   (blobstore-lookup p)))
                                                (:blobstore config))]
    (when provider
      (service provider :identity identity :credential credential))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   "Create a signed request")
  (put-file
   [blobstore container path file]
   "Upload a file")
  (containers
   [blobstore]
   "List containers")
  (close
   [blobstore]
   "Close the blobstore"))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.command-line" name="pallet.command-line"><h1 class="project-name">pallet.command-line</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Taken from clojure.contrib</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Process command-line arguments according to a given cmdspec</p>
</td><td class="codes" /><pre class="brush: clojure">(ns #^{:author "Chris Houser"}
    pallet.command-line
  (:refer-clojure :exclude [group-by]))</pre></tr><tr><td class="docs"><p>Returns a string of all elements in coll, separated by
  separator.  Like Perl's join.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn #^String join
  [#^String separator coll]
  (apply str (interpose separator coll)))</pre></tr><tr><td class="docs"><p>Returns a sorted map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn group-by ;; in clojure 1.2 core
  [f coll]
  (reduce
   (fn [ret x]
     (let [k (f x)]
       (assoc ret k (conj (get ret k []) x))))
   (sorted-map) coll))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-map [args cmdspec]
  (let [{spec true [rest-sym] false} (group-by vector? cmdspec)
        rest-str (str rest-sym)
        key-data (into {} (for [[syms [_ default]] (map #(split-with symbol? %)
                                                        (conj spec '[help? h?]))
                                sym syms]
                            [(re-find #"^.*[^?]" (str sym))
                             {:sym (str (first syms)) :default default}]))
        defaults (into {} (for [[_ {:keys [default sym]}] key-data
                                :when default]
                            [sym default]))]
    (loop [[argkey & [argval :as r]] args
           cmdmap (assoc defaults :cmdspec cmdspec rest-str [])]
      (if argkey
        (let [[_ & [keybase]] (re-find #"^--?(.*)" argkey)]
          (cond
            (= keybase nil) (recur r (update-in cmdmap [rest-str] conj argkey))
            (= keybase )  (update-in cmdmap [rest-str] #(apply conj % r))
            :else (if-let [found (key-data keybase)]
                    (if (= \? (last (:sym found)))
                      (recur r (assoc cmdmap (:sym found) true))
                      (recur (next r) (assoc cmdmap (:sym found)
                                             (if (or (nil? r) (= \- (ffirst r)))
                                               (:default found)
                                               (first r)))))
                    (throw (Exception. (str "Unknown option " argkey))))))
        cmdmap))))</pre></tr><tr><td class="docs"><p>Align strings given as vectors of columns, with first vector
   specifying right or left alignment (:r or :l) for each column.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- align
   [spec & rows]
   (let [maxes (vec (for [n (range (count (first rows)))]
                      (apply max (map (comp count #(nth % n)) rows))))
         fmt (join " "
                   (for [n (range (count maxes))]
                     (str "%"
                          (when-not (zero? (maxes n))
                            (str (when (= (spec n) :l) "-") (maxes n)))
                          "s")))]
     (join "\n"
           (for [row rows]
             (apply format fmt row)))))</pre></tr><tr><td class="docs"><p>Remove ?</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- rmv-q
   [#^String s]
   (if (.endsWith s "?")
      (.substring s 0 (dec (count s)))
      s))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn print-help [desc cmdmap]
  (println desc)
  (println "Options")
  (println
     (apply align [:l :l :l]
        (for [spec (:cmdspec cmdmap) :when (vector? spec)]
            (let [[argnames [text default]] (split-with symbol? spec)
                  [_ opt q] (re-find #"^(.*[^?])(\??)$"
                                 (str (first argnames)))
                  argnames  (map (comp rmv-q str) argnames)
                  argnames
                        (join ", "
                          (for [arg argnames]
                            (if (= 1 (count arg))
                              (str "-" arg)
                              (str "--" arg))))]
               [(str "  " argnames (when (=  q) " <arg>") " ")
                text
                (if-not default
                  (str " [default " default "]"))])))))</pre></tr><tr><td class="docs"><p>Bind locals to command-line args.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-command-line
  [args desc cmdspec & body]
  (let [locals (vec (for [spec cmdspec]
                      (if (vector? spec)
                        (first spec)
                        spec)))]
    `(let [{:strs ~locals :as cmdmap#} (make-map ~args '~cmdspec)]
       (if (cmdmap# "help?")
         (print-help ~desc cmdmap#)
         (do ~@body)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(comment

; example of usage:

(with-command-line *command-line-args*
  "tojs -- Compile ClojureScript to JavaScript"
  [[simple? s? "Runs some simple built-in tests"]
   [serve      "Starts a repl server on the given port" 8081]
   [mkboot?    "Generates a boot.js file"]
   [verbose? v? "Includes extra fn names and comments in js"]
   filenames]
  (binding [*debug-fn-names* verbose? *debug-comments* verbose?]
    (cond
      simple? (simple-tests)
      serve   (start-server (Integer/parseInt serve))
      mkboot? (mkboot)
      :else   (doseq [filename filenames]
                 (filetojs filename)))))

)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.command-script" name="pallet.command-script"><h1 class="project-name">pallet.command-script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Produce a shell script for launching Pallet, possibly customised for extra jars</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.command-script
  (:require
   [pallet.stevedore :as stevedore]
   [pallet.action.user :as user]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn path
  [components]
  (apply str (interpose "/" components)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn normalize-scriptname
  "normalize $0 on certain BSDs"
  []
  (stevedore/script
   (if (= @(dirname $0) ".")
     (defvar SCRIPT "$(which $(basename $0))")
     (defvar SCRIPT "$0"))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn resolve-symlinks
  "resolve symlinks to the script itself portably"
  []
  (stevedore/script
   (while (symlink? @SCRIPT)
          (defvar ls @(ls -ld (quoted @SCRIPT)))
          (defvar link @(expr (quoted @ls) ":" "'.*-> \\(.*\\)$'"))
          (if (expr (quoted @link) ":" "'/.*'" > "/dev/null")
            (defvar SCRIPT (quoted @link))
            (defvar SCRIPT (quoted (str @(dirname @SCRIPT) "/" @link)))))
   (defvar BIN_DIR (quoted @(dirname (quoted @SCRIPT))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn http-client
  "Script to set HTTP client options."
  []
  (stevedore/script
   (defvar HTTP_CLIENT (quoted "wget "))
   (defvar HTTP_OUTFILE (quoted "-O "))
   (defvar HTTP_STDOUT (quoted "-q -O - "))
   (if (type -p curl ">/dev/null 2>&1")
     (do
       (defvar HTTP_CLIENT (quoted "curl -L "))
       (defvar HTTP_OUTFILE (quoted "-o "))
       (defvar HTTP_STDOUT (quoted ))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-snapshot-path
  [artifacts]
  (stevedore/script
   (defn snapshot-path [version metafile base_path]
     (defvar METADATA
       @(@HTTP_CLIENT @HTTP_STDOUT @metafile))
     (defvar JARDATE
       @(pipe
         (echo @META)
         (egrep (quoted "[0-9]{8}\\.[0-9]{6}") -o)))
     (defvar JARBUILD
       @(pipe
         (echo @META)
         (fgrep "buildNumber")
         (egrep (quoted "[0-9]+") -o)))
     (defvar JARVERSION
       ~(.replace (:version (first artifacts)) "-SNAPSHOT" ))
     (println (str @base_path @JARVERSION "-" @JARDATE "-" @JARBUILD ".jar")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Artifact
  (local-path [x] "Local path for installing the artifact")
  (remote-path [x] "Remote path for downloading the artifact")
  (jar-name [x] "jar name for the artifact"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord MavenArtifact
  [group-id artifact-id version repository]
  Artifact
  (local-path
   [artifact]
   (path [(stevedore/script @repo) (.replace group-id "." "/") artifact-id version
          (jar-name artifact)]))
  (remote-path
   [artifact]
   (if (.contains version "SNAPSHOT")
     (let [metafile (path [repository (.replace group-id "." "/") artifact-id version
                           "maven-metadata.xml"])]
       (stevedore/script
        @(snapshot-path
          ~version
          ~metafile
          ~(path [repository group-id (.replace group-id "." "/") version
                  (str artifact-id "-")]))))
     (path [repository (.replace group-id "." "/") artifact-id version
            (jar-name artifact)])))
  (jar-name
   [_]
   (str artifact-id "-" version ".jar")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn m2-repository-path
  "Return a script fragment setting $repo to the local maven repository path"
  []
  (stevedore/script
   (defvar settings (str @HOME "/.m2/settings.xml"))
   (defvar default_repo (str @HOME "/.m2/repository"))
   (if (file-exists? @settings)
     (do
       (defvar repo
         @(chain-or
           (group
            (pipe
             (cat @settings)
             (tr -d "'\n\t '")
             (egrep -o (quoted "<localRepository>(.*)</localRepository>"))
             (sed -e (quoted "s%\\${user.home}%${HOME}%")
                  -e (quoted "s%<localRepository>%%")
                  -e (quoted "s%</localRepository>%%"))))
           (println @default_repo)))
       (if (= @repo )
         (defvar repo @default_repo)))
     (defvar repo (str @user-home "/.m2/repository")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn download-artifact
  [artifact]
  (stevedore/script
   (@HTTP_CLIENT $HTTP_OUTFILE
                 (quoted ~(local-path artifact))
                 (quoted ~(remote-path artifact)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-download
  "Produces a function to unconditionaly download artifacts"
  [artifacts]
  (stevedore/script
   (defn do-download []
     ~(apply stevedore/checked-commands
       "Downloading dependencies"
       (map download-artifact artifacts)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-install
  []
  (stevedore/script
   (defn do-install []
     (do-download)
     (exit 0))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-upgrade
  [artifacts]
  (stevedore/script
   (defn do-upgrade []
     (if-not (writeable? $SCRIPT)
       (do
         (println "You do not have permission to upgrade the installation in "
                  @SCRIPT)
         (exit 1)))
     (echo
      "The script at " @SCRIPT " will be upgraded to the latest stable version.")
     (echo -n "Do you want to continue [Y/n]? ")
     (read RESPONSE)
     (case @RESPONSE
         "y|Y|\"\ (do
                      (println)
                      (println "Upgrading...")
                      (defvar BRANCH
                        ~(if (.contains (:version (first artifacts)) "SNAPSHOT")
                           "master"
                           "stable"))
                      (defvar PALLET_SCRIPT_URL
                        (quoted
                         (str "http://github.com/hugoduncan/pallet/raw/"
                              @BRANCH
                              "/bin/pallet")))
                      (chain-and
                       (@HTTP_CLIENT
                        $HTTP_OUTFILE
                        (quoted @SCRIPT) (quoted @PALLET_SCRIPT_URL))
                       ("chmod" +x (quoted @SCRIPT))
                       (println)
                       (@SCRIPT self-install)
                       (println)
                       (println "Now running" @(@SCRIPT version)))
                      (exit "$?"))
         * (do
             (println "Aborted")
             (exit 1))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn run-from-checkout
  []
  (stevedore/script
   (defvar PALLET_DIR
     (quoted @(dirname (quoted @BIN_DIR))))
   (defvar PALLET_LIBS
     (quoted
      @(pipe
        (find -H (str @PALLET_DIR "/lib") -mindepth 1 -maxdepth 1 -print0
              "2> /dev/null")
        (tr "\\\\0" "\\:"))))
   (defvar CLASSPATH
     (quoted (str (str @PALLET_DIR "/src") ":" (str @PALLET_DIR "/pallet/src") ":" @PALLET_LIBS ":" @CLASSPATH)))
   (defvar BOOTPATH (quoted ))
   (if (&& (= @PALLET_LIBS ) (!= "$1" "self-install" ))
     (do
       (println "Your Pallet development checkout is missing its dependencies.")
       (println "Please use you maven or lein to download the dependencies.")
       (println (quoted "   cd " @PALLET_DIR))
       (println (quoted " and either:"))
       (println (quoted "   lein deps"))
       (println (quoted "   mvn -Dmaven.test.skip=true assembly:directory"))
       (exit 1)))))</pre></tr><tr><td class="docs"><p>We want to run from the first of:
nested pallet project
current project
mvn repo</p>
</td><td class="codes" /><pre class="brush: clojure">(defn run-from-jar
  [artifacts]
  (stevedore/script
   (if (readable? (str "./pallet/lib/" ~(jar-name (first artifacts)) ))
     (do
       (defvar PALLET_LIBS
         (quoted
          @(pipe
            (find -H "./pallet/lib/" -mindepth 1 -maxdepth 1 -print0
                  "2> /dev/null")
            (tr "\\\\0" "\\:"))))
       (defvar CLASSPATH
         (quoted (str @PALLET_LIBS ":./pallet/src/:" @CLASSPATH)))
       (defvar BOOTPATH (quoted )))
     (if (readable? (str "./lib/" ~(jar-name (first artifacts)) ))
       (do
         (defvar PALLET_LIBS
         (quoted
          @(pipe
            (find -H "./lib/" -mindepth 1 -maxdepth 1 -print0 "2> /dev/null")
            (tr "\\\\0" "\\:"))))
         (defvar CLASSPATH
           (quoted (str @PALLET_LIBS ":./pallet/src/:" @CLASSPATH)))
         (defvar BOOTPATH (quoted )))
       (do
         (defvar CLASSPATH
           (quoted
            (str
             ~(apply
               str (interpose ":" (map local-path artifacts)))
             ":" @CLASSPATH))))))
   (defvar BOOTPATH (quoted ))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn paths-for-cygwin
  []
  (stevedore/script
   (when (type -p cygpath ">/dev/null 2>&1")
     (defvar CLOJURE_JAR
       @(cygpath -w (quoted @CLOJURE_JAR)))
     (defvar CLASSPATH
       @(cygpath -w (quoted @CLASSPATH))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn process-commands
  [artifacts]
  (stevedore/script
   (if (= "$1" "self-install")
     (do-install))
   (if (= "$1" "upgrade")
     (do-upgrade))
   (if (readable? (str @BIN_DIR "/../src/pallet/core.clj"))
     (do ~(run-from-checkout))
     (do ~(run-from-jar artifacts)))
   ~(paths-for-cygwin)
   (if "[ $DEBUG ]"
     (println @CLASSPATH))
   (exec
    @RLWRAP
    java -client @JAVA_OPTS -cp (quoted @CLASSPATH)
    (str "-Dpallet.version=" ~(:version (first artifacts)))
    @JLINE
    clojure.main -e (quoted "(use 'pallet.main)(-main)")
    "/dev/null"
    "$@")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn command-script
  [pallet-version artifacts]
  (stevedore/do-script
   "#!/usr/bin/env bash"
   (normalize-scriptname)
   (resolve-symlinks)
   (http-client)
   (m2-repository-path)
   (defn-snapshot-path artifacts)
   (defn-download artifacts)
   (defn-upgrade artifacts)
   (defn-install)
   (process-commands artifacts)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def clojars-repo "http://clojars.org/repo")
(def clojure-release-repo "http://build.clojure.org/releases/")
(def clojure-snapshot-repo "http://build.clojure.org/snapshots")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn write-script
  []
  (println
   (command-script
    "0.0.1-SNAPSHOT"
    [(MavenArtifact. "pallet" "pallet" "0.0.1-SNAPSHOT" clojars-repo)
     (MavenArtifact. "org.clojure" "clojure" "1.2.0-master-SNAPSHOT"
                     clojure-snapshot-repo)])))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.implementation" name="pallet.compute.implementation"><h1 class="project-name">pallet.compute.implementation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation details</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.implementation
  (:require
   [pallet.utils :as utils]
   [clojure.contrib.find-namespaces :as find-namespaces]
   [clojure.contrib.logging :as logging]
   [clojure.contrib.classpath :as cp]))</pre></tr><tr><td class="docs"><p>Instantiate a compute service. Providers should implement a method for this.
   See pallet.compute/compute-service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti service
  (fn [provider-name & _] (keyword provider-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def compute-regex #"^pallet\.compute\.[a-z-]+")
(def exclude-compute-ns
  #{'pallet.compute.jvm
    'pallet.compute.implementation})
(def exclude-regex #".*test.*")
(def provider-list (atom nil))</pre></tr><tr><td class="docs"><p>Find the available providers.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- providers
  []
  (try
    (binding [cp/classpath utils/classpath
              cp/classpath-jarfiles utils/classpath-jarfiles]
      (->> (find-namespaces/find-namespaces-on-classpath)
           (filter #(re-find compute-regex (name %)))
           (remove #(re-find exclude-regex (name %)))
           (remove exclude-compute-ns)
           (set)))
    (catch java.io.FileNotFoundException _)))</pre></tr><tr><td class="docs"><p>Require all providers, ensuring no errors if individual providers can not be
   loaded</p>
</td><td class="codes" /><pre class="brush: clojure">(defn load-providers
  []
  (when-not @provider-list
    (reset! provider-list (providers))
    (let [loaded (filter
                  identity
                  (doall
                   (for [provider @provider-list]
                     (try
                       (require provider)
                       provider
                       (catch Throwable e
                         (logging/warn
                          (format
                           "%s provider failed to load: %s"
                           provider
                           (.getMessage e))))))))]
      (reset! provider-list loaded)))
  @provider-list)</pre></tr><tr><td class="docs"><p>Create a list of supported providers</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers
  []
  (->>
   (doall
    (for [provider (load-providers)]
      (when-let [providers (ns-resolve provider 'supported-providers)]
        (@providers))))
   (filter identity)
   (apply concat)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.jclouds" name="pallet.compute.jclouds"><h1 class="project-name">pallet.compute.jclouds</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>jclouds compute service implementation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.jclouds
  (:require
   [org.jclouds.compute :as jclouds]
   [pallet.compute.implementation :as implementation]
   [pallet.compute.jvm :as jvm]
   [pallet.compute :as compute]
   [pallet.environment :as environment]
   [pallet.script :as script]
   [pallet.utils :as utils]
   [pallet.execute :as execute]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging])
  (:import
   [org.jclouds.compute.domain.internal HardwareImpl ImageImpl NodeMetadataImpl]
   org.jclouds.compute.util.ComputeServiceUtils
   org.jclouds.compute.ComputeService
   org.jclouds.compute.options.RunScriptOptions
   org.jclouds.compute.options.TemplateOptions
   [org.jclouds.compute.domain
    NodeState NodeMetadata Image OperatingSystem OsFamily Hardware Template]
   org.jclouds.domain.Location
   org.jclouds.io.Payload
   org.jclouds.scriptbuilder.domain.Statement
   com.google.common.base.Predicate))</pre></tr><tr><td class="docs"><p>Meta</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers []
  (ComputeServiceUtils/getSupportedProviders))</pre></tr><tr><td class="docs"><p>Compute service</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-jclouds-extensions
  "Default extensions"
  [provider]
  (concat
   (if (jvm/log4j?) [:log4j] [])
   (if (= (name provider) "stub")
     (try
       (require 'pallet.compute.jclouds-ssh-test)
       (when-let [f (ns-resolve
                     'pallet.compute.jclouds-ssh-test 'ssh-test-client)]
         [(f (ns-resolve 'pallet.compute.jclouds-ssh-test 'no-op-ssh-client))])
       (catch java.io.FileNotFoundException _))
     [:ssh])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true :doc "translate option names"}
  option-keys
  {:endpoint :jclouds.endpoint})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn option-key
  [provider key]
  (case key
    :endpoint (keyword (format (str provider ".endpoint")))
    (option-keys key key)))</pre></tr><tr><td class="docs"><p>Node utilities</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro impl-fns
  []
  (let [ctors (.getDeclaredConstructors HardwareImpl)]
    (if (= 10 (count (.getParameterTypes (first ctors))))
      ;; jclouds up to beta-9c
      `(do
         (defn hardware-impl
           [~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'processors ~'ram ~'volumes ~'image-supported-fn]
           (HardwareImpl.
            ~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata
            ~'processors ~'ram ~'volumes ~'image-supported-fn))
         (defn node-metadata-impl
           [~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'group-name ~'hardware ~'image-id ~'os ~'state ~'login-port
            ~'public-ips ~'private-ips ~'admin-password ~'credentials]
           (NodeMetadataImpl.
            ~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata
            ~'group-name ~'hardware ~'image-id ~'os ~'state ~'login-port
            ~'public-ips ~'private-ips ~'admin-password ~'credentials))
         (defn image-impl
           [~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'os ~'description ~'version ~'admin-password ~'credentials]
           (ImageImpl.
            ~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata
            ~'os ~'description ~'version ~'admin-password ~'credentials)))
      ;; jclouds after beta-9c (added tags)
      `(do
         (defn hardware-impl
           [~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'processors ~'ram ~'volumes ~'image-supported-fn]
           (HardwareImpl.
            ~'provider-id ~'name ~'id ~'location ~'uri
            ~'user-metadata ~'tags
            ~'processors ~'ram ~'volumes ~'image-supported-fn))
         (defn node-metadata-impl
           [~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'group-name ~'hardware ~'image-id ~'os ~'state ~'login-port
            ~'public-ips ~'private-ips ~'admin-password ~'credentials]
           (NodeMetadataImpl.
            ~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'group-name ~'hardware ~'image-id ~'os ~'state ~'login-port
            ~'public-ips ~'private-ips ~'admin-password ~'credentials))
         (defn image-impl
           [~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'os ~'description ~'version ~'admin-password ~'credentials]
           (ImageImpl.
            ~'provider-id ~'name ~'id ~'location ~'uri ~'user-metadata ~'tags
            ~'os ~'description ~'version ~'admin-password ~'credentials))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(impl-fns)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-operating-system
  [{:keys [family name version arch description is-64bit]
    :or {family OsFamily/UBUNTU
         name "Ubuntu"
         version "Some version"
         arch "Some arch"
         description "Desc"
         is-64bit true}}]
  (OperatingSystem. family name version arch description is-64bit))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jvm-os-family-map
  {"AIX" OsFamily/AIX
   "ARCH" OsFamily/ARCH
   "Mac OS" OsFamily/DARWIN
   "Mac OS X" OsFamily/DARWIN
   "FreeBSD" OsFamily/FREEBSD
   "HP UX" OsFamily/HPUX
   "Linux"   OsFamily/UBUNTU ;; guess for now
   "Solaris" OsFamily/SOLARIS
   "Windows 2000" OsFamily/WINDOWS
   "Windows 7" OsFamily/WINDOWS
   "Windows 95" OsFamily/WINDOWS
   "Windows 98" OsFamily/WINDOWS
   "Windows NT" OsFamily/WINDOWS
   "Windows Vista" OsFamily/WINDOWS
   "Windows XP" OsFamily/WINDOWS})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn local-operating-system
  "Create an OperatingSystem object for the local host"
  []
  (let [os-name (System/getProperty "os.name")]
    (make-operating-system
     {:family (or (jvm-os-family-map (jvm/os-name)) OsFamily/UNRECOGNIZED)
      :name os-name
      :description os-name
      :version (System/getProperty "os.version")
      :arch (System/getProperty "os.arch")
      :is-64bit (= "64" (System/getProperty "sun.arch.data.model"))})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-hardware
  [{:keys [provider-id name id location uri user-metadata processors ram
           volumes supports-image tags]
    :or {provider-id "provider-hardware-id"
         name "Some Hardware"
         id "Some id"
         user-metadata {}
         processors []
         ram 512
         volumes []
         supports-image (fn [&] true)
         tags (java.util.HashSet.)}}]
  (let [image-supported-fn (reify com.google.common.base.Predicate
                             (apply [_ i] (supports-image i))
                             (equals [_ i] (= supports-image i)))]
    (hardware-impl provider-id name id location uri user-metadata tags
                   processors ram volumes image-supported-fn)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn local-hardware
  "Create an Hardware object for the local host"
  []
  (let [os-name (System/getProperty "os.name")]
    (make-hardware {})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-node [group-name & options]
  (let [options (apply hash-map options)]
    (node-metadata-impl
     (options :provider-id (options :id group-name))
     (options :name group-name)                ; name
     (options :id group-name)                   ; id
     (options :location)
     (java.net.URI. group-name)                ; uri
     (options :user-metadata {})
     (options :tags #{})
     group-name
     (if-let [hardware (options :hardware)]
       (if (map? hardware) (make-hardware hardware) hardware)
       (make-hardware {}))
     (options :image-id)
     (if-let [os (options :operating-system)]
       (if (map? os) (make-operating-system os) os)
       (make-operating-system {}))
     (options :state NodeState/RUNNING)
     (options :login-port 22)
     (options :public-ips [])
     (options :private-ips [])
     (options :admin-password)
     (options :credentials nil))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-unmanaged-node
  "Make a node that is not created by pallet's node management.
   This can be used to manage configuration of any machine accessable over
   ssh, including virtual machines."
  [group-name host-or-ip & options]
  (let [options (apply hash-map options)
        meta (dissoc options :location :user-metadata :state :login-port
                     :public-ips :private-ips :extra :admin-password
                     :credentials)]
    (node-metadata-impl
     (options :provider-id (options :id group-name))
     (options :name group-name)
     (options :id (str group-name (rand-int 65000)))
     (options :location)
     (java.net.URI. group-name)                ; uri
     (merge (get options :user-metadata {}) meta)
     (options :tags #{})
     group-name
     (if-let [hardware (options :hardware)]
       (if (map? hardware) (make-hardware hardware) hardware)
       (make-hardware {}))
     (options :image-id)
     (if-let [os (options :operating-system)]
       (if (map? os) (make-operating-system os) os)
       (make-operating-system {}))
     (get options :state NodeState/RUNNING)
     (options :login-port 22)
     (conj (get options :public-ips []) host-or-ip)
     (options :private-ips [])
     (options :admin-password)
     (options :credentials nil))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-image
  [id & options]
  (let [options (apply hash-map options)
        meta (dissoc options :name :location :uri :user-metadata
                     :version :operating-system :default-credentials
                     :description)]
    (image-impl
     id ; providerId
     (options :name)
     id
     (options :location)
     (options :uri)
     (merge (get options :user-metadata {}) meta)
     (options :tags #{})
     (options :operating-system)
     (options :description "image description")
     (options :version "image version")
     (options :admin-password)
     (options :default-credentials))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn compute-node? [object]
  (instance? NodeMetadata object))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type org.jclouds.compute.domain.NodeMetadata
  pallet.compute/Node

  (ssh-port
    [node]
    (let [md (into {} (.getUserMetadata node))
          port (:ssh-port md)]
      (if port (Integer. port))))

  (primary-ip [node] (first (jclouds/public-ips node)))
  (private-ip [node] (first (jclouds/private-ips node)))
  (is-64bit? [node] (.. node getOperatingSystem is64Bit))
  (group-name [node] (jclouds/tag node))

  (os-family
    [node]
    (when-let [operating-system (.getOperatingSystem node)]
      (keyword (str (.getFamily operating-system)))))

  (os-version
    [node]
    (when-let [operating-system (.getOperatingSystem node)]
      (.getVersion operating-system)))

  (hostname [node] (.getName node))
  (id [node] (.getId node))
  (running? [node] (jclouds/running? node))
  (terminated? [node] (jclouds/terminated? node)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-node-template
  "Build the template for specified target node and compute context"
  [compute group public-key-path init-script]
  {:pre [(map? group) (:group-name group)]}
  (logging/info
   (str "building node template for " (:group-name group)))
  (when public-key-path
    (logging/info (str "  authorizing " public-key-path)))
  (when init-script
    (logging/debug (str "  init script\n" init-script)))
  (let [options (->> [:image :hardware :location :network :qos]
                     (select-keys group)
                     vals
                     (reduce merge))
        options (if (:default-os-family group)
                  (dissoc options :os-family) ; remove if we added in
                                              ; ensure-os-family
                  options)]
    (logging/info (str "  options " options))
    (let [options (if (and public-key-path
                           (not (:authorize-public-key options)))
                    (assoc options
                      :authorize-public-key (slurp public-key-path))
                    options)
          options (if (not (:run-script options))
                    (if init-script
                      (assoc options :run-script (.getBytes init-script))
                      options)
                    options)]
      (jclouds/build-template compute options))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype JcloudsService
    [^org.jclouds.compute.ComputeService compute environment]
  ;; implement jclouds ComputeService by forwarding
  org.jclouds.compute.ComputeService
  (getContext [_] (.getContext compute))
  (templateBuilder [_] (.templateBuilder compute))
  (templateOptions [_] (.templateOptions compute))
  (listHardwareProfiles [_] (.listHardwareProfiles compute))
  (listImages [_] (.listImages compute))
  (listNodes [_] (.listNodes compute))
  (listAssignableLocations [_] (.listAssignableLocations compute))
  ;; (createNodesInGroup [_ group count template]
  ;;                     (.createNodesInGroup compute group count template))
  ;; (createNodesInGroup [_ group count]
  ;;                     (.createNodesInGroup compute group count))
  (^java.util.Set runNodesWithTag
   [_ ^String group ^int count ^Template template]
   (.createNodesInGroup compute group count template))
  (^java.util.Set runNodesWithTag
   [_ ^String group ^int count ^TemplateOptions template-options]
   (.createNodesInGroup compute group count template-options))
  (^java.util.Set runNodesWithTag
   [_ ^String group ^int count]
   (.createNodesInGroup compute group count))
  (resumeNode [_ id] (.resumeNode compute id))
  (resumeNodesMatching [_ predicate] (.resumeNodesMatching compute predicate))
  (suspendNode [_ id] (.suspendNode compute id))
  (suspendNodesMatching [_ predicate] (.suspendNodesMatching compute predicate))
  (rebootNode [_ id] (.rebootNode compute id))
  (rebootNodesMatching [_ predicate] (.rebootNodesMatching compute predicate))
  (getNodeMetadata [_ id] (.getNodeMetadata compute id))
  (listNodesDetailsMatching [_ predicate]
                            (.listNodesDetailsMatching compute predicate))
  (^java.util.Map runScriptOnNodesMatching
   [_ ^Predicate predicate ^Payload script]
   (.runScriptOnNodesMatching compute predicate script))
  (^java.util.Map runScriptOnNodesMatching
   [_ ^Predicate predicate ^Payload script ^RunScriptOptions options]
   (.runScriptOnNodesMatching compute predicate script options))
  ;; (^java.util.Map runScriptOnNodesMatching
  ;;  [_ ^Predicate predicate ^String script]
  ;;  (.runScriptOnNodesMatching compute predicate script))
  ;; (^java.util.Map runScriptOnNodesMatching
  ;;  [_ ^Predicate predicate ^String script ^RunScriptOptions options]
  ;;  (.runScriptOnNodesMatching compute predicate script options))
  ;; (^java.util.Map runScriptOnNodesMatching
  ;;  [_ ^Predicate predicate ^Statement script]
  ;;  (.runScriptOnNodesMatching compute predicate script))
  ;; (^java.util.Map runScriptOnNodesMatching
  ;;  [_ ^Predicate predicate ^Statement script ^RunScriptOptions options]
  ;;  (.runScriptOnNodesMatching compute predicate script options))
  pallet.compute.ComputeService
  (nodes [_] (jclouds/nodes-with-details compute))
  (ensure-os-family
   [_ group]
   (if (-> group :image :os-family)
     group
     (let [template (jclouds/build-template compute (:image group))
           family (-> (.. template getImage getOperatingSystem getFamily)
                      str keyword)]
       (logging/info (format "OS is %s" (pr-str family)))
       (when (or (nil? family) (= family OsFamily/UNRECOGNIZED))
         (condition/raise
          :type :unable-to-determine-os-type
          :message (format
                    (str "jclouds was unable to determine the os-family "
                         "of the template %s")
                    (pr-str (:image group)))))
       (->
        group
        (assoc-in [:image :os-family] family)
        (assoc-in [:default-os-family] true)))))
  (run-nodes
   [_ group-spec node-count user init-script]
   (->>
    (jclouds/run-nodes
     (name (:group-name group-spec))
     node-count
     (build-node-template
      compute
      group-spec
      (:public-key-path user)
      init-script)
     compute)
    ;; The following is a workaround for terminated nodes.
    ;; See http://code.google.com/p/jclouds/issues/detail?id=501
    (filter compute/running?)))
  (reboot
   [_ nodes]
   (doseq [node nodes]
     (jclouds/reboot-node node compute)))
  (boot-if-down
   [_ nodes]
   (map #(jclouds/reboot-node % compute)
        (filter jclouds/terminated? nodes)))
  (shutdown-node
   [_ node user]
   (let [ip (compute/primary-ip node)]
     (if ip
       (execute/remote-sudo ip "shutdown -h 0" user {:pty false}))))
  (shutdown
   [self nodes user]
   (doseq [node nodes]
     (compute/shutdown-node self node user)))
  (destroy-nodes-in-group
    [_ group-name]
    (jclouds/destroy-nodes-with-tag (name group-name) compute))
  (destroy-node
   [_ node]
   (jclouds/destroy-node (compute/id node) compute))
  (close [_] (.. compute getContext close))
  pallet.environment.Environment
  (environment [_] environment))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-locations
  "Return locations of a node as a seq."
  [#^NodeMetadata node]
  (letfn [(loc [#^Location l]
               (when l (cons l (loc (.getParent l)))))]
    (loc (.getLocation node))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn image-string
  [#^Image image]
  (when image
    (let [name (.getName image)
          description (.getDescription image)]
      (format "%s %s %s %s"
              (.getFamily (.getOperatingSystem image))
              (.getArch (.getOperatingSystem image))
              name
              (if (= name description)  description)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn os-string
  [#^OperatingSystem os]
  (when os
    (let [name (.getName os)
          description (.getDescription os)]
      (format "%s %s %s %s"
              (.getFamily os)
              (.getArch os)
              name
              (if (= name description)  description)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn location-string
  [#^Location location]
  (when location
    (format "%s/%s" (.getScope location) (.getId location))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method Location
  [location writer]
  (.write writer (location-string location)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method NodeMetadata
  [node writer]
  (.write
   writer
   (format
    "%14s\t %s %s\n\t\t %s\n\t\t %s\n\t\t public: %s  private: %s"
    (jclouds/tag node)
    (apply str (interpose "." (map location-string (node-locations node))))
    (let [location (.getLocation node)]
      (when (and location
                 (not (= (.getDescription location) (.getId location))))
        (.getDescription location)))
    (os-string (.getOperatingSystem node))
    (.getState node)
    (apply
     str (interpose ", " (.getPublicAddresses node)))
    (apply
     str (interpose ", " (.getPrivateAddresses node))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jvm-os-map
     { "Mac OS X" :os-x })</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-localhost-node
  "Make a node representing the local host"
  []
  (make-node "localhost"
             :public-ips ["127.0.0.1"]
             :operating-system (local-operating-system)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn local-session
  "Create a session map for localhost"
  []
  (let [node (make-localhost-node)]
    {:all-nodes [node]
     :server {:image [(get jvm-os-map (System/getProperty "os.name"))]
              :node node}}))</pre></tr><tr><td class="docs"><p>service factory implementation for jclouds</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :default
  [provider {:keys [identity credential extensions endpoint environment]
             :or {extensions (default-jclouds-extensions provider)}
             :as options}]
  (logging/debug (format "extensions %s" (pr-str extensions)))
  (let [options (dissoc
                 options
                 :identity :credential :extensions :blobstore :environment)]
    (JcloudsService.
     (apply
      jclouds/compute-service
      (name provider) identity credential
      :extensions extensions
      (interleave
       (map #(option-key provider %) (keys options))
       (vals options)))
     environment)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.jvm" name="pallet.compute.jvm"><h1 class="project-name">pallet.compute.jvm</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Information from local jvm</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.jvm)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jvm-os-map
  {"Mac OS X" :os-x})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn os-name []
  (System/getProperty "os.name"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn os-family []
  (or (jvm-os-map (os-name)) :ubuntu))</pre></tr><tr><td class="docs"><p>Predicate to test for log4j on the classpath.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn log4j?
  []
  (try
    (import org.apache.log4j.Logger)
    true
    (catch java.lang.ClassNotFoundException _
      false)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.node-list" name="pallet.compute.node-list"><h1 class="project-name">pallet.compute.node-list</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A simple node list provider</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.node-list
  (:require
   [pallet.compute :as compute]
   [pallet.compute.jvm :as jvm]
   [pallet.compute.implementation :as implementation]
   [pallet.environment :as environment]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers []
  ["node-list"])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord Node
    [name group-name ip os-family os-version id ssh-port private-ip is-64bit
     running]
  pallet.compute.Node
  (ssh-port [node] ssh-port)
  (primary-ip [node] ip)
  (private-ip [node] private-ip)
  (is-64bit? [node] (:is-64bit node))
  (group-name [node] group-name)
  (running? [node] running)
  (terminated? [node] (not running))
  (os-family [node] os-family)
  (os-version [node] os-version)
  (hostname [node] name)
  (id [node] id))</pre></tr><tr><td class="docs"><p>Node utilities</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-node [name group-name ip os-family
                 & {:keys [id ssh-port private-ip is-64bit running os-version]
                    :or {ssh-port 22 is-64bit true running true}
                    :as options}]
  (Node.
   name
   group-name
   ip
   os-family
   os-version
   (or id (str name "-" (string/replace ip #"\." "-")))
   ssh-port
   private-ip
   is-64bit
   running))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype NodeList
    [node-list environment]
  pallet.compute.ComputeService
  (nodes [compute-service] @node-list)
  (ensure-os-family
    [compute-service group-spec]
    (when (not (-> group-spec :image :os-family))
      (condition/raise
       :type :no-os-family-specified
       :message "Node list contains a node without os-family")))
  ;; Not implemented
  ;; (run-nodes [node-type node-count request init-script])
  ;; (reboot "Reboot the specified nodes")
  (boot-if-down [compute nodes] nil)
  ;; (shutdown-node "Shutdown a node.")
  ;; (shutdown "Shutdown specified nodes")
  ;; this forgets about the nodes
  (destroy-nodes-in-group [_ group]
    (swap! node-list (fn [nl] (remove #(= (compute/group-name %) group) nl))))
  (close [compute])
  pallet.environment.Environment
  (environment [_] environment))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method Node
  [^Node node writer]
  (.write
   writer
   (format
    "%14s\t %s %s public: %s  private: %s  %s"
    (:group-name node)
    (:os-family node)
    (:running node)
    (:ip node)
    (:private-ip node)
    (:id node))))</pre></tr><tr><td class="docs"><p>Make a node representing the local host</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-localhost-node
  [& {:keys [name group-name ip os-family id]
      :or {name "localhost"
           group-name "local"
           ip "127.0.0.1"
           os-family (jvm/os-family)}
      :as options}]
  (apply
   make-node name group-name ip os-family
   (apply concat (merge {:id "localhost"} options))))</pre></tr><tr><td class="docs"><p>Compute service</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :node-list
  [_ {:keys [node-list environment]}]
  (NodeList.
   (atom (vec
          (map
           #(if (vector? %)
              (apply make-node %)
              %)
           node-list)))
   environment))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.vmfest" name="pallet.compute.vmfest"><h1 class="project-name">pallet.compute.vmfest</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A vmfest provider.</p>

<p>   An example service configuration in ~/.pallet/config.clj</p>

<pre><code>   :vb {:provider "virtualbox"
        :images {:centos-5-3 {:description "CentOS 5.3 32bit"
                              :uuid "4697bdf7-7acf-4a20-8c28-e20b6bb58e25"
                              :os-family :centos
                              :os-version "5.3"
                              :os-type-id "RedHat"}
                 :ubuntu-10-04 {:description "Ubuntu 10.04 32bit"
                                :uuid "8a31e3aa-0d46-41a5-936d-25130dcb16b7"
                                :os-family :ubuntu
                                :os-version "10.04"
                                :os-type-id "Ubuntu"
                                :username
                                :password}}
        :model-path "/Volumes/My Book/vms/disks"
        :node-path "/Volumes/My Book/vms/nodes"}
</code></pre>

<p>   The uuid's can be found using vboxmanage
       vboxmanage list hdds</p>

<p>   The images are disks that are immutable.  The virtualbox extensions need
   to be installed on the image.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.vmfest
  (:require
   [vmfest.virtualbox.virtualbox :as virtualbox]
   [vmfest.virtualbox.machine :as machine]
   [vmfest.virtualbox.model :as model]
   [vmfest.virtualbox.session :as session]
   [vmfest.manager :as manager]
   [vmfest.virtualbox.session :as session]
   [vmfest.virtualbox.enums :as enums]
   [pallet.action-plan :as action-plan]
   [pallet.compute :as compute]
   [pallet.compute.jvm :as jvm]
   [pallet.compute.implementation :as implementation]
   [pallet.environment :as environment]
   [pallet.execute :as execute]
   [pallet.futures :as futures]
   [pallet.script :as script]
   [pallet.utils :as utils]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers []
  ["virtualbox"])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def os-family-name
  {:ubuntu "Ubuntu"
   :centos "RedHat"
   ;:rhel "RedHat"
   :rhel "RedHat_64"})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ip-tag "/pallet/ip")
(def group-name-tag "/pallet/group-name")
(def os-family-tag "/pallet/os-family")
(def os-version-tag "/pallet/os-version")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def *vm-session-type* "headless") ; gui, headless or sdl</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def os-family-from-name
  (zipmap (vals os-family-name) (keys os-family-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type vmfest.virtualbox.model.Machine
  pallet.compute/Node
  (ssh-port [node] 22)
  (primary-ip
   [node]
   (condition/handler-case
    :type
    (manager/get-ip node)
    (handle :vbox-runtime
      (manager/get-extra-data node ip-tag))))
  (private-ip [node] nil)
  (is-64bit?
   [node]
   (let [os-type-id (session/with-no-session node [m] (.getOSTypeId m))]
     (boolean (re-find #"_64" os-type-id))))
  (group-name
   [node]
   (let [group-name (manager/get-extra-data node group-name-tag)]
     (if (string/blank? group-name)
       (manager/get-extra-data node group-name-tag)
       group-name)))
  (hostname
   [node]
   (session/with-no-session node [m]
     (.getName m)))
  (os-family
   [node]
   (let [os-name (session/with-no-session node [m] (.getOSTypeId m))]
     (or
      (when-let [os-family (manager/get-extra-data node os-family-tag)]
        (when-not (string/blank? os-family)
          (keyword os-family)))
      (os-family-from-name os-name os-name)
      :centos) ;; hack!
     ))
  (os-version
   [node]
   (or
    (manager/get-extra-data node os-version-tag)
    "5.3"))
  (running?
   [node]
   (and
    (session/with-no-session node [vb-m] (.getAccessible vb-m))
    (= :running (manager/state node))))
  (terminated? [node] false)
  (id [node] (:id node)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nil-if-blank [x]
  (if (string/blank? x) nil x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- current-time-millis []
  (System/currentTimeMillis))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-ip
  "Wait for the machines IP to become available."
  ([machine] (wait-for-ip machine 300000))
  ([machine timeout]
     (let [timeout (+ (current-time-millis) timeout)]
       (loop []
         (try
           (let [ip (try (manager/get-ip machine)
                         (catch org.virtualbox_4_0.VBoxException e
                           (logging/warn
                            (format
                             "wait-for-ip: Machine %s not started yet..."
                             machine)))
                         (catch clojure.contrib.condition.Condition e
                           (logging/warn
                            (format
                             "wait-for-ip: Machine %s is not accessible yet..."
                             machine))))]
             (if (and (string/blank? ip) (< (current-time-millis) timeout))
               (do
                 (Thread/sleep 2000)
                 (recur))
               ip)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn machine-name
  "Generate a machine name"
  [group-name n]
  (format "%s-%s" group-name n))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defprotocol VirtualBoxService
  (os-families [compute] "Return supported os-families")
  (medium-formats [compute] "Return supported medium-formats"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-data [m]
  (let [attributes (session/with-no-session m [im]
                     [(.getName im)
                      (.getDescription im)
                      (.getSessionState im)])
        open? (= :open
                 (session/with-no-session m [im]
                   (enums/session-state-to-key
                    (.getSessionState im))))
        ip (when open? (manager/get-ip m))
        group-name (when open? (manager/get-extra-data m group-name-tag))]
    (into attributes {:ip ip :group-name group-name}) ))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-infos [compute-service]
  (let [nodes (manager/machines compute-service)]
    (map node-data nodes)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-sata-controller [m]
  {:pre [(model/IMachine? m)]}
  (machine/add-storage-controller m "SATA Controller" :sata))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn basic-config [m {:keys [memory-size cpu-count] :as parameters}]
  (let [parameters (merge {:memory-size 512 :cpu-count 1} parameters)]
    (manager/configure-machine m parameters)
    (manager/set-bridged-network m "en1: AirPort")
    (manager/add-ide-controller m)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def hardware-parameters
  {:min-ram :memory-size
   :min-cores :cpu-count})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def hardware-config
  {:bridged-network (fn [m iface] (manager/set-bridged-network m iface))})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn machine-model-with-parameters
  "Set a machine basic parameters and default configuration"
  [m image]
  (let [hw-keys (filter hardware-parameters (keys image))]
    (basic-config
     m (zipmap (map hardware-parameters hw-keys) (map image hw-keys)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn machine-model
  "Construct a machine model function from a node image spec"
  [image]
  (fn [m]
    (machine-model-with-parameters m image)
    (doseq [kw (filter hardware-config (keys image))]
      ((hardware-config kw) m (image kw)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn create-node
  [compute node-path node-spec machine-name images image-id machine-models
   group-name init-script user]
  {:pre [image-id]}
  (logging/trace (format "Creating node from image-id: %s" image-id))
  (let [machine (binding [manager/*images* images
                          manager/*machine-models* machine-models]
                  (manager/instance
                   compute machine-name image-id :micro node-path))
        image (image-id images)]
    (manager/set-extra-data machine group-name-tag group-name)
    (manager/set-extra-data machine os-family-tag (name (:os-family image)))
    (manager/set-extra-data machine os-version-tag (:os-version image))
    ;; (manager/add-startup-command machine 1 init-script )
    (manager/start
     machine
     :session-type (or
                    (:session-type node-spec)
                    *vm-session-type*))
    (logging/trace "Wait to allow boot")
    (Thread/sleep 15000)                ; wait minimal time for vm to boot
    (logging/trace "Waiting for ip")
    (when (string/blank? (wait-for-ip machine))
      (condition/raise
       :type :no-ip-available
       :message "Could not determine IP address of new node"))
    (Thread/sleep 4000)
    (logging/trace (format "Bootstrapping %s" (manager/get-ip machine)))
    (script/with-script-context
      (action-plan/script-template-for-server {:image image})
      (let [user (if (:username image)
                   (pallet.utils/make-user
                    (:username image)
                    :password (:password image)
                    :no-sudo (:no-sudo image)
                    :sudo-password (:sudo-password image))
                   user)]
        (execute/remote-sudo
         (manager/get-ip machine) init-script user
         {:pty (not (#{:arch :fedora} (:os-family image)))})))
    machine))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- equality-match
  [image-properties kw arg]
  (= (image-properties kw) arg))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- regexp-match
  [image-properties kw arg]
  (re-matches (re-pattern arg) (image-properties kw)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def template-matchers
  {:os-version-matches (fn [image-properties kw arg]
                         (regexp-match image-properties :os-version arg))})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn image-from-template
  "Use the template to select an image from the image map."
  [images template]
  (if-let [image-id (:image-id template)]
    (image-id images)
    (->
     (filter
      (fn image-matches? [[image-name image-properties]]
        (every?
         #(((first %) template-matchers equality-match)
           image-properties (first %) (second %))
         (utils/dissoc-keys
          template
          (concat
           [:image-id :inbound-ports]
           (keys hardware-config)
           (keys hardware-parameters)))))
      images)
     ffirst)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn serial-create-nodes
  "Create all nodes for a group in parallel."
  [target-machines-to-create server node-path node-spec images image-id
   machine-models group-name init-script user]
  (doall
   (for [name target-machines-to-create]
     (create-node
      server node-path node-spec name images image-id machine-models group-name
      init-script user))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn parallel-create-nodes
  "Create all nodes for a group in parallel."
  [target-machines-to-create server node-path node-spec images image-id
   machine-models group-name init-script user]
  ;; the doseq ensures that all futures are completed before
  ;; returning
  (->>
   (for [name target-machines-to-create]
     (future
       (create-node
        server node-path node-spec name images image-id
        machine-models group-name init-script user)))
   doall ;; doall forces creation of all futures before any deref
   futures/add
   (map #(futures/deref-with-logging % "Start of node"))
   (filter identity)
   doall))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype VmfestService
    [server images locations environment]
  pallet.compute/ComputeService
  (nodes [compute-service] (manager/machines server))
  (ensure-os-family [compute-service group] group)
  (run-nodes
   [compute-service group-spec node-count user init-script]
   (try
     (let [image-id (or (image-from-template images (:image group-spec))
                        (throw (RuntimeException.
                                (format "No matching image for %s"
                                        (pr-str (:image group-spec))))))
           group-name (name (:group-name group-spec))
           machines (filter
                     #(session/with-no-session % [vb-m] (.getAccessible vb-m))
                     (manager/machines server))
           current-machines-in-group (filter
                                      #(= group-name
                                          (manager/get-extra-data
                                           % group-name-tag))
                                      machines)
           current-machine-names (into #{}
                                       (map
                                        #(session/with-no-session % [m]
                                           (.getName m))
                                        current-machines-in-group))
           target-indices (range (+ node-count
                                    (count current-machines-in-group)))
           target-machine-names (into #{}
                                      (map
                                       #(machine-name group-name %)
                                       target-indices))
           target-machines-already-existing (clojure.set/intersection
                                             current-machine-names
                                             target-machine-names)
           target-machines-to-create (clojure.set/difference
                                      target-machine-names
                                      target-machines-already-existing)]
       (logging/debug (str "current-machine-names " current-machine-names))
       (logging/debug (str "target-machine-names " target-machine-names))
       (logging/debug (str "target-machines-already-existing "
                           target-machines-already-existing))
       (logging/debug (str "target-machines-to-create"
                           target-machines-to-create))
       ((get-in environment [:algorithms :vmfest :create-nodes-fn]
                parallel-create-nodes)
        target-machines-to-create server (:node-path locations)
        group-spec images image-id
        {:micro (machine-model (:image group-spec))}
        group-name init-script user))))
  (reboot
   [compute nodes]
   (compute/shutdown server nodes nil)
   (compute/boot-if-down server nodes))
  (boot-if-down
   [compute nodes]
   (doseq [node nodes]
     (manager/start node)))
  (shutdown-node
   [compute node _]
   ;; todo: wait for completion
   (logging/info (format "Shutting down %s" (pr-str node)))
   (manager/power-down node)
   (if-let [state (manager/wait-for-machine-state node [:powered-off] 300000)]
     (logging/info (format "Machine state is %s" state))
     (logging/warn "Failed to wait for power down completion"))
   (manager/wait-for-lockable-session-state node 2000))
  (shutdown
   [compute nodes user]
   (doseq [node nodes]
     (compute/shutdown-node server node user)))
  (destroy-nodes-in-group
    [compute group-name]
    (let [nodes (locking compute ;; avoid disappearing machines
                  (filter
                   #(and
                     (compute/running? %)
                     (= group-name (manager/get-extra-data % group-name-tag)))
                   (manager/machines server)))]
      (doseq [machine nodes]
        (compute/destroy-node compute machine))))
  (destroy-node
   [compute node]
   {:pre [node]}
   (compute/shutdown-node compute node nil)
   (manager/destroy node))
  (close [compute])
  pallet.environment.Environment
  (environment [_] environment))</pre></tr><tr><td class="docs"><p>Compute service</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :virtualbox
  [_ {:keys [url identity credential images node-path model-path locations
             environment]
      :or {url "http://localhost:18083/"
           identity "test"
           credential "test"}
      :as options}]
  (let [locations (or locations
                      {:local (select-keys options [:node-path :model-path])})]
    (VmfestService.
     (vmfest.virtualbox.model.Server. url identity credential)
     images
     (val (first locations))
     environment)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method vmfest.virtualbox.model.Machine
  [node writer]
  (.write
   writer
   (format
    "%14s\t %14s\t public: %s"
    (try (compute/hostname node) (catch Throwable e "unknown"))
    (try (compute/group-name node) (catch Throwable e "unknown"))
    (try (compute/primary-ip node) (catch Throwable e "unknown")))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute" name="pallet.compute"><h1 class="project-name">pallet.compute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Abstraction of the compute interface</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute
  (:require
   [pallet.compute.implementation :as implementation]
   [pallet.configure :as configure]
   [pallet.environment :as environment]
   [pallet.utils :as utils]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string])
  (:use
   [clojure.contrib.core :only [-?>]]))</pre></tr><tr><td class="docs"><p>A list of supported provider names.  Each name is suitable to be passed
   to compute-service.</p>

<p>Meta</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers
  []
  (implementation/supported-providers))</pre></tr><tr><td class="docs"><p>Instantiate a compute service. The provider name should be a recognised
   jclouds provider, or "node-list". The other arguments are keyword value
   pairs.
   - :identity     username or key
   - :credential   password or secret
   - :extensions   extension modules for jclouds
   - :node-list    a list of nodes for the "node-list" provider.
   - :environment  an environment map with service specific values.</p>

<p>Compute Service instantiation</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service
  [provider-name
   & {:keys [identity credential extensions node-list endpoint environment]
      :as options}]
  (implementation/load-providers)
  (implementation/service provider-name options))</pre></tr><tr><td class="docs"><p>Create a compute service from a credentials map.
   Uses the :provider, :identity, :credential, :extensions and :node-list keys.
   The :extensions and :node-list keys will be read with read-string if they
   are strings.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-map
  [credentials]
  (let [options {:identity (:identity credentials)
                 :credential (:credential credentials)
                 :extensions (when-let [extensions (:extensions credentials)]
                               (if (string? extensions)
                                 (map
                                  read-string
                                  (string/split extensions #" "))
                                 extensions))
                 :node-list (when-let [node-list (:node-list credentials)]
                              (if (string? node-list)
                                (read-string node-list)
                                node-list))
                 :endpoint (:endpoint credentials)
                 :environment
                 (environment/merge-environments
                  (environment/eval-environment
                   (:environment credentials))
                  (-?> 'cake/*project* resolve var-get :environment))}]
    (when-let [provider (:provider credentials)]
      (apply
       compute-service
       provider
       (apply concat (filter second options))))))</pre></tr><tr><td class="docs"><p>Create a compute service from maven property settings.
   In Maven's settings.xml you can define a profile, that contains
   pallet.compute.provider, pallet.compute.identity and
   pallet.compute.credential values.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-settings
  [& profiles]
  (try
    (require 'pallet.maven) ; allow running without maven jars
    (when-let [f (ns-resolve 'pallet.maven 'credentials)]
      (compute-service-from-map (f profiles)))
    (catch ClassNotFoundException _)
    (catch clojure.lang.Compiler$CompilerException _)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- compute-service-from-var
  [ns sym]
  (utils/find-var-with-require ns sym))</pre></tr><tr><td class="docs"><p>Checks to see if pallet.config/service is a var, and if so returns its
  value.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config-var
  []
  (compute-service-from-var 'pallet.config 'service))</pre></tr><tr><td class="docs"><p>If the pallet.config.service property is defined, and refers to a var, then
   return its value.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-property
  []
  (when-let [property (System/getProperty "pallet.config.service")]
    (when-let [sym-names (and (re-find #"/" property)
                              (string/split property #"/"))]
      (compute-service-from-var
       (symbol (first sym-names)) (symbol (second sym-names))))))</pre></tr><tr><td class="docs"><p>Compute service from a configuration map and a list of active profiles
   (provider keys).</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config
  [config profiles]
  (let [{:keys [provider identity credential]
         :as options}
        (configure/compute-service-properties config profiles)]
    (when provider
      (apply compute-service
       provider :identity identity :credential credential
       (apply
        concat
        (->
          options
          (dissoc :provider :identity :credential)
          (update-in
           [:environment]
           environment/merge-environments
           (-?> 'cake/*project* resolve var-get :environment))))))))</pre></tr><tr><td class="docs"><p>Compute service from ~/.pallet/config.clj. Profiles is a sequence of service
   keys to use from the :services map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config-file
  [& profiles]
  (compute-service-from-config
   (configure/pallet-config)
   profiles))</pre></tr><tr><td class="docs"><p>Instantiate a compute service.</p>

<p>   If passed no arguments, then the compute service is looked up in the
   following order:
   - from a var referenced by the pallet.config.service system property
   - from pallet.config/service if defined
   - the first service in config.xlj
   - the service from the first active profile in settings.xml</p>

<p>   If passed a service name, it is looked up in external
   configuration (~/.pallet/config.clj or ~/.m2/settings.xml). A service name is
   one of the keys in the :services map in config.clj, or a profile id in
   settings.xml.</p>

<p>   When passed a provider name and credentials, the service is instantiated
   based on the credentials.  The provider name should be a recognised provider
   name (see <code>pallet.compute/supported-providers</code> to obtain a list of these).</p>

<p>   The other arguments are keyword value pairs.
   - :identity     username or key
   - :credential   password or secret
   - :extensions   extension modules for jclouds
   - :node-list    a list of nodes for the "node-list" provider.
   - :environment  an environment map with service specific values.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn service
  ([]
     (or
      (compute-service-from-property)
      (compute-service-from-config-var)
      (compute-service-from-config-file)
      (compute-service-from-settings)))
  ([service-name]
     (or
      (compute-service-from-config-file service-name)
      (compute-service-from-settings service-name)))
  ([provider-name
    & {:keys [identity credential extensions node-list endpoint environment]
       :as options}]
     (apply compute-service provider-name (apply concat options))))</pre></tr><tr><td class="docs"><p>Nodes</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Node
  (ssh-port [node] "Extract the port from the node's userMetadata")
  (primary-ip [node] "Returns the first public IP for the node.")
  (private-ip [node] "Returns the first private IP for the node.")
  (is-64bit? [node] "64 Bit OS predicate")
  (group-name [node] "Returns the group name for the node.")
  (hostname [node] "TODO make this work on ec2")
  (os-family [node] "Return a node's os-family, or nil if not available.")
  (os-version [node] "Return a node's os-version, or nil if not available.")
  (running? [node])
  (terminated? [node])
  (id [node]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn tag [node] (group-name node))
(defn node-in-group? [group-name node]
  (= (clojure.core/name group-name) (pallet.compute/group-name node)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-address
  [node]
  (if (string? node)
    node
    (primary-ip node)))</pre></tr><tr><td class="docs"><p>Actions</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol ComputeService
  (nodes [compute] "List nodes")
  (run-nodes [compute group-spec node-count user init-script])
  (reboot [compute nodes] "Reboot the specified nodes")
  (boot-if-down
   [compute nodes]
   "Boot the specified nodes, if they are not running.")
  (shutdown-node [compute node user] "Shutdown a node.")
  (shutdown [compute nodes user] "Shutdown specified nodes")
  (ensure-os-family
   [compute group-spec]
   "Called on startup of a new node to ensure group-spec has an os-family
   attached to it.")
  (destroy-nodes-in-group [compute group-name])
  (destroy-node [compute node])
  (close [compute]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-by-tag [nodes]
  (reduce #(assoc %1
             (keyword (tag %2))
             (conj (get %1 (keyword (tag %2)) []) %2)) {} nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-counts-by-tag [nodes]
  (reduce #(assoc %1
             (keyword (tag %2))
             (inc (get %1 (keyword (tag %2)) 0))) {} nodes))</pre></tr><tr><td class="docs"><p>Package manager</p>

<p>target mapping</p>
</td><td class="codes" /><pre class="brush: clojure">(defn packager
  [target]
  (or
   (:packager target)
   (let [os-family (:os-family target)]
     (cond
      (#{:ubuntu :debian :jeos} os-family) :aptitude
      (#{:centos :rhel :amzn-linux :fedora} os-family) :yum
      (#{:arch} os-family) :pacman
      (#{:suse} os-family) :zypper
      (#{:gentoo} os-family) :portage
      (#{:darwin :os-x} os-family) :brew
      :else (condition/raise
             :type :unknown-packager
             :message (format
                       "Unknown packager for %s - :image %s"
                       os-family target))))))</pre></tr><tr><td class="docs"><p>Base distribution for the target.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn base-distribution
  [target]
  (or
   (:base-distribution target)
   (let [os-family (:os-family target)]
     (cond
      (#{:ubuntu :debian :jeos} os-family) :debian
      (#{:centos :rhel :amzn-linux :fedora} os-family) :rh
      (#{:arch} os-family) :arch
      (#{:suse} os-family) :suse
      (#{:gentoo} os-family) :gentoo
      (#{:darwin :os-x} os-family) :os-x
      :else (condition/raise
             :type :unknown-packager
             :message (format
                       "Unknown base-distribution for %s - target is %s"
                       os-family target))))))</pre></tr><tr><td class="docs"><p>User that remote commands are run under</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-group
  [target]
  (case (-> target :image :os-family)
    :centos "wheel"
    :rhel "wheel"
    "adm"))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.config-file.format" name="pallet.config-file.format"><h1 class="project-name">pallet.config-file.format</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Some standard file formating.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.config-file.format
  (:require
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>A sectioned property file.
   This is modeled as vector of maps. The keys of the outer map are the section
   names.  The inner maps are keyword value maps.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sectioned-properties
  [m]
  (letfn [(format-kv
           [[key-name value]]
           (format "%s = %s\n" (name key-name) value))
          (format-section
           [[section-name kv-map]]
           (format
            "[%s]\n%s\n" (name section-name)
            (string/join (map format-kv kv-map))))]
    (string/join (map format-section m))))</pre></tr><tr><td class="docs"><p>A property file.
   The properties are written "key value", one per line.
     m                   a key-value map
     :seperator chars    seperator to use between key and value
                         (default is a single space)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn name-values
  [m & {:keys [separator] :or {separator " "}}]
  (string/join
   (map
    (fn [[key-name value]] (format "%s%s%s\n" (name key-name) separator value))
    m)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.configure" name="pallet.configure"><h1 class="project-name">pallet.configure</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet configuration using ~/.pallet/config.clj</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.configure
  (:require
   [pallet.common.deprecate :as deprecate]
   [pallet.environment :as environment]
   [pallet.utils :as utils]
   [clojure.java.io :as java-io]
   [clojure.walk :as walk]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} config nil)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- unquote-vals [args]
  (walk/walk
   (fn [item]
     (cond (and (seq? item) (= `unquote (first item))) (second item)
           ;; needed if we want fn literals to be usable by eval-in-project
           (and (seq? item) (= 'fn (first item))) (list 'quote item)
           (symbol? item) (list 'quote item)
           :else (unquote-vals item)))
   identity
   args))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defpallet
  [& {:keys [provider identity credential providers admin-user]
      :as config-options}]
  `(let [m# (zipmap
             ~(cons 'list (keys config-options))
             ~(cons 'list (unquote-vals (vals config-options))))]
    (alter-var-root
     #'config
     (fn [_#] m#))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- read-config
  [file]
  (try
    (use '[pallet.configure :only [defpallet]])
    (load-file file)
    config
    (catch java.io.FileNotFoundException _)))</pre></tr><tr><td class="docs"><p>Returns full path to Pallet home dir ($PALLET_HOME or $HOME/.pallet)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- home-dir
  []
  (.getAbsolutePath
   (doto (if-let [pallet-home (System/getenv "PALLET_HOME")]
           (java.io.File. pallet-home)
           (java.io.File. (System/getProperty "user.home") ".pallet"))
     .mkdirs)))</pre></tr><tr><td class="docs"><p>Read pallet configuration file.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pallet-config
  []
  (reduce
   (fn [config service]
     (assoc-in config [:services (key (first service))] (val (first service))))
   (read-config (.getAbsolutePath (java-io/file (home-dir) "config.clj")))
   (for [file (filter
               #(.isFile %)
               (file-seq (java-io/file (home-dir) "services")))]
     (read-string (slurp file)))))</pre></tr><tr><td class="docs"><p>Helper to read compute service properties</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-properties
  [config profiles]
  (when config
    (when (:providers config)
      (deprecate/warn
       (str
        "Use of :providers key in ~/.pallet/config.clj is "
        "deprecated. Please change to use :services.")))
    (let [service (first profiles)
          default-service (map config [:provider :identity :credential])
          services (:services config (:providers config))
          environment (when-let [env (:environment config)]
                        (environment/eval-environment env))]
      (cond
       (and
        (not service)
        (every? identity default-service)) (select-keys
                                            config
                                            [:provider :identity :credential
                                             :blobstore :endpoint :environment])
       (map? services) (->
                        (or
                         (and service
                              (or
                               (services (keyword service))
                               (services service)))
                         (and (not service) ; use default if service unspecified
                              (first services)
                              (-> services first val)))
                        (utils/maybe-update-in
                         [:environment]
                         #(environment/merge-environments
                           environment (environment/eval-environment %))))
       :else nil))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core" name="pallet.core"><h1 class="project-name">pallet.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Core functionality is provided in <code>lift</code> and <code>converge</code>.</p>

<ul>
<li>node           :: A node in the compute service</li>
<li>node-spec      :: A specification for a node. The node-spec provides an image
                hardware, location and network template for starting new
                nodes.</li>
<li>server-spec    :: A specification for a server. This is a map of phases and
                a default node-spec. A server-spec has the following keys
                :phase, :packager and node-spec keys.</li>
<li>group-spec     :: A group of identically configured nodes, represented as a
                map with :group-name, :count and server-spec keys.
                The group-name is used to link running nodes to their
                configuration (via pallet.compute.Node/group-name)</li>
<li>group          :: A group of identically configured nodes, represented as a
                group-spec, together with the servers that are running
                for that group-spec.</li>
<li>group name     :: The name used to identify a group.</li>
<li>server         :: A map used to descibe the node, image, etc of a single
                node running as part of a group. A server has the
                following keys :group-name, :node, :node-id and server-spec
                keys.</li>
<li>phase list     :: A list of phases to be used</li>
<li>action plan    :: A list of actions that should be run.</li>
</ul>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.core
  {:author "Hugo Duncan"}
  (:require
   [pallet.action :as action]
   [pallet.action-plan :as action-plan]
   [pallet.blobstore :as blobstore]
   [pallet.common.deprecate :as deprecate]
   [pallet.common.resource :as resource]
   [pallet.compute :as compute]
   [pallet.environment :as environment]
   [pallet.execute :as execute]
   [pallet.futures :as futures]
   [pallet.parameter :as parameter]
   [pallet.phase :as phase]
   [pallet.script :as script]
   [pallet.thread-expr :as thread-expr]
   [pallet.utils :as utils]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging]
   [clojure.contrib.map-utils :as map-utils]
   [clojure.set :as set]
   [clojure.string :as string])
  (:use
   [clojure.contrib.core :only [-?>]]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(let [v (atom nil)]
  (defn version
    "Returns the pallet version."
    []
    (or
     @v
     (reset! v (System/getProperty "pallet.version"))
     (reset! v (if-let [version (resource/slurp "pallet-version")]
                       (string/trim version))))))</pre></tr><tr><td class="docs"><p>Set the agent string for http requests.</p>
</td><td class="codes" /><pre class="brush: clojure">(. System setProperty "http.agent"
   (str "Pallet " (version)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-admin-user
  "Specify the admin user for running remote commands.  The user is specified
   either as pallet.utils.User record (see the pallet.utils/make-user
   convenience fn) or as an argument list that will be passed to make-user.
   This is mainly for use at the repl, since the admin user can be specified
   functionally using the :user key in a lift or converge call, or in the
   environment."
  {:arglists
   '([user & body]
     [[username & {:keys [public-key-path private-key-path passphrase password
                          sudo-password no-sudo] :as options}] & body])}
  [user & exprs]
  `(let [user# ~user]
     (binding [utils/*admin-user* (if (utils/user? user#)
                                    user#
                                    (apply utils/make-user user#))]
       ~@exprs)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user
  "Set the root binding for the admin user.
   The user arg is a map as returned by make-user, or a username.  When passing
   a username the options can be specified as in `pallet.utils/make-user`.
   This is mainly for use at the repl, since the admin user can be specified
   functionally using the :user key in a lift or converge call, or in the
   environment."
  {:arglists
   '([user]
     [username & {:keys [public-key-path private-key-path passphrase
                         password sudo-password no-sudo] :as options}])}
  [user & options]
  (alter-var-root
   #'utils/*admin-user*
   #(identity %2)
   (if (string? user)
     (apply utils/make-user user options)
     user)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc "Vector of keywords recognised by node-spec"
       :private true}
  node-spec-keys [:image :hardware :location :network])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-spec
  "Create a node-spec.
   Defines the compute image and hardware selector template.
   This is used to filter a cloud provider's image and hardware list to select
   an image and hardware for nodes created for this node-spec.
   :image     a map descirbing a predicate for matching an image:
              os-family os-name-matches os-version-matches
              os-description-matches os-64-bit
              image-version-matches image-name-matches
              image-description-matches image-id
   :location  a map describing a predicate for matching location:
              location-id
   :hardware  a map describing a predicate for matching harware:
              min-cores min-ram smallest fastest biggest architecture
              hardware-id
   :network   a map for network connectivity options:
              inbound-ports
   :qos       a map for quality of service options:
              spot-price enable-monitoring"
  [& {:keys [image hardware location network qos] :as options}]
  {:pre [(or (nil? image) (map? image))]}
  options)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- merge-specs
  "Merge specs, using comp for :phases"
  [a b]
  (let [phases (merge-with #(comp %2 %1) (:phases a) (:phases b))
        roles (set/union (:roles a) (:roles b))]
    (->
     (merge a b)
     (thread-expr/when-not->
      (empty? phases)
      (assoc :phases phases))
     (thread-expr/when-not->
      (empty? roles)
      (assoc :roles roles)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- extend-specs
  "Merge in the inherited specs"
  [spec inherits]
  (if inherits
    (merge-specs
     (if (map? inherits) inherits (reduce merge-specs inherits))
     spec)
    spec))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn server-spec
  "Create a server-spec.
   - :phases a hash-map used to define phases. Standard phases are:
     - :bootstrap    run on first boot of a new node
     - :configure    defines the configuration of the node
   - :extends        takes a server-spec, or sequence thereof, and is used to
                     inherit phases, etc.
   - :roles          defines a sequence of roles for the server-spec
   - :node-spec      default node-spec for this server-spec
   - :packager       override the choice of packager to use"
  [& {:keys [phases packager node-spec extends roles]
      :as options}]
  (->
   node-spec
   (merge options)
   (thread-expr/when-> roles
           (update-in [:roles] #(if (keyword? %) #{%} (into #{} %))))
   (extend-specs extends)
   (dissoc :extends :node-spec)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn group-spec
  "Create a group-spec.
   `name` is used for the group name, which is set on each node and links a node
   to it's node-spec
   - :extends  specify a server-spec, a group-spec, or sequence thereof,
               and is used to inherit phases, etc.
   - :phases used to define phases. Standard phases are:
     - :bootstrap    run on first boot of a new node
     - :configure    defines the configuration of the node.
   - :count    specify the target number of nodes for this node-spec
   - :packager override the choice of packager to use
   - :node-spec      default node-spec for this server-spec"
  [name
   & {:keys [extends count image phases packager node-spec roles] :as options}]
  {:pre [(or (nil? image) (map? image))]}
  (->
   node-spec
   (merge options)
   (thread-expr/when-> roles
           (update-in [:roles] #(if (keyword? %) #{%} (into #{} %))))
   (extend-specs extends)
   (dissoc :extends :node-spec)
   (assoc :group-name (keyword name))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn cluster-spec
  "Create a cluster-spec.
   `name` is used as a prefix for all groups in the cluster.
   - :groups    specify a sequence of groups that define the cluster
   - :extends   specify a server-spec, a group-spec, or sequence thereof,
                for all groups in the cluster
   - :phases    define phases on all groups.
   - :node-spec default node-spec for the nodes in the cluster
   - :roles     roles for the group-spec"
  [cluster-name
   & {:keys [extends groups phases node-spec environment] :as options}]
  (->
   options
   (update-in [:groups]
              (fn [group-specs]
                (map
                 (fn [group-spec]
                   (->
                    node-spec
                    (merge (dissoc group-spec :phases))
                    (update-in
                     [:group-name]
                     #(keyword (str (name cluster-name) "-" (name %))))
                    (update-in
                     [:environment]
                     environment/merge-environments environment)
                    (extend-specs extends)
                    (extend-specs [{:phases phases}])
                    (extend-specs [(select-keys group-spec [:phases])])))
                 group-specs)))
   (dissoc :extends :node-spec)
   (assoc :cluster-cluster-name (keyword cluster-name))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-node
  "Create a node definition.  See defnode."
  {:deprecated "0.5.0"}
  [name image & {:as phase-map}]
  (deprecate/deprecated
   (str
    "pallet.core/make-node is deprecated. "
    "See group-spec, server-spec and node-spec in pallet.core."))
  {:pre [(or (nil? image) (map? image))]}
  (->
   {:group-name (keyword name)
    :image image}
   (thread-expr/when-not->
    (empty? phase-map)
    (assoc :phases phase-map))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn name-with-attributes
  "Modified version, of that found in contrib, to handle the image map."
  [name macro-args]
  (let [[docstring macro-args] (if (string? (first macro-args))
                                 [(first macro-args) (next macro-args)]
                                 [nil macro-args])
        [attr macro-args] (if (and (map? (first macro-args))
                                   (map? (first (next macro-args))))
                            [(first macro-args) (next macro-args)]
                            [{} macro-args])
        attr (if docstring
               (assoc attr :doc docstring)
               attr)
        attr (if (meta name)
               (conj (meta name) attr)
               attr)]
    [(with-meta name attr) macro-args]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defnode
  "Define a node type.  The name is used for the group name.
   image defines the image selector template.  This is a vector of keyword or
          keyword value pairs that are used to filter the image list to select
          an image.
   Options are used to define phases. Standard phases are:
     :bootstrap    run on first boot
     :configure    defines the configuration of the node."
  {:arglists ['(tag doc-str? attr-map? image & phasekw-phasefn-pairs)]
   :deprecated "0.5.0"}
  [group-name & options]
  (let [[group-name options] (name-with-attributes group-name options)]
    `(do
       (deprecate/deprecated-macro
        ~&form
        (str
         "pallet.core/defnode is deprecated. See group-spec, server-spec and "
         "node-spec in pallet.core"))
       (def ~group-name (make-node '~(name group-name) ~@options)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-session-keys-for-0-4-compatibility
  "Add target keys for compatibility.
   This function adds back deprecated keys"
  [session]
  (-> session
      (assoc :node-type (:group session))
      (assoc :target-packager (-> session :server :packager))
      (assoc :target-id (-> session :server :node-id))
      (assoc :target-node (-> session :server :node))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn show-target-keys
  "Middleware that is useful in debugging."
  [handler]
  (fn [session]
    (logging/info
     (format
      "TARGET KEYS :phase %s :node-id %s :group-name %s :packager %s"
      (:phase session)
      (-> session :server :node-id)
      (-> session :server :group-name)
      (-> session :server :packager)))
    (handler session)))</pre></tr><tr><td class="docs"><p>executor</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- executor [session f action-type location]
  (let [exec-fn (get-in session [:executor action-type location])]
    (when-not exec-fn
      (condition/raise
       :type :missing-executor-fn
       :fn-for [action-type location]
       :message (format
                 "Missing executor function for %s %s"
                 action-type location)))
    (exec-fn session f)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(let [raise (fn [message]
              (fn [_ _]
                (condition/raise :type :executor-error :message message)))]
  (def ^{:doc "Default executor map"}
    default-executors
    {:script/bash
     {:origin execute/bash-on-origin
      :target (raise
               (str ":script/bash on :target not implemented.\n"
                    "Add middleware to enable remote execution."))}
     :fn/clojure
     {:origin execute/clojure-on-origin
      :target (raise ":fn/clojure on :target not supported")}
     :transfer/to-local
     {:origin (raise
               (str ":transfer/to-local on :origin not implemented.\n"
                    "Add middleware to enable transfers."))
      :target (raise ":transfer/to-local on :target not supported")}
     :transfer/from-local
     {:origin (raise
               (str ":transfer/to-local on :origin not implemented.\n"
                    "Add middleware to enable transfers."))
      :target (raise ":transfer/from-local on :target not supported")}}))</pre></tr><tr><td class="docs"><p>bootstrap functions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- bootstrap-script
  [session]
  {:pre [(get-in session [:group :image :os-family])
         (get-in session [:group :packager])]}
  (let [error-fn (fn [message]
                   (fn [_ _]
                     (condition/raise
                      :type :booststrap-contains-non-remote-actions
                      :message message)))
        [result session] (->
                          session
                          (assoc
                              :phase :bootstrap
                              :server (assoc (:group session)
                                        :node-id :bootstrap-id))
                          (assoc-in
                           [:executor :script/bash :target]
                           execute/echo-bash)
                          (assoc-in
                           [:executor :transfer/to-local :origin]
                           (error-fn "Bootstrap can not contain transfers"))
                          (assoc-in
                           [:executor :transfer/from-local :origin]
                           (error-fn "Bootstrap can not contain transfers"))
                          (assoc-in
                           [:executor :fn/clojure :origin]
                           (error-fn "Bootstrap can not contain local actions"))
                          add-session-keys-for-0-4-compatibility
                          action-plan/build-for-target
                          action-plan/translate-for-target
                          (action-plan/execute-for-target executor))]
    (string/join \newline result)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- create-nodes
  "Create count nodes based on the template for the group.
   Returns a map with updated server node lists."
  [count session]
  {:pre [(map? (:group session))]}
  (logging/info
   (str "Starting " count " nodes for " (-> session :group :group-name)
        " os-family " (-> session :group :image :os-family)))
  (let [compute (:compute session)
        session (update-in session [:group]
                           #(compute/ensure-os-family compute %))
        session (assoc-in session [:group :packager]
                          (compute/packager (-> session :group :image)))
        init-script (bootstrap-script session)
        _ (logging/trace (format "Bootstrap script:\n%s" init-script))
        new-nodes (compute/run-nodes
                   compute (:group session) count (:user session) init-script)]
    {:new-nodes new-nodes}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- destroy-nodes
  "Destroys the specified number of nodes with the given group.  Nodes are
   selected at random. Returns a map containing removed nodes."
  [destroy-count session]
  (logging/info
   (str "destroying " destroy-count " nodes for "
        (-> session :group :group-name)))
  (let [compute (:compute session)
        group (:group session)
        servers (:servers group)]
    (if (= destroy-count (count servers))
      (do
        (compute/destroy-nodes-in-group compute (name (:group-name group)))
        {:old-nodes (map :node servers)})
      (let [nodes (map :node servers)]
        (doseq [node (take destroy-count nodes)]
          (compute/destroy-node compute node))
        {:old-nodes (vec (take destroy-count nodes))}))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-count-difference
  "Find the difference between the required and actual node counts by group."
  [groups]
  (->>
   groups
   (map
    (fn [group]
      (vector
       (:group-name group) (- (:count group) (count (:servers group))))))
   (into {})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- adjust-node-count
  "Adjust the node by delta nodes."
  [{:keys [group-name environment servers] :as group} delta session]
  (let [session (environment/session-with-environment
                  (assoc session :group group)
                  (environment/merge-environments
                   (:environment session) environment))]
    (logging/info (format "adjust-node-count %s %d" group-name delta))
    (cond
     (pos? delta) (create-nodes delta session)
     (neg? delta) (destroy-nodes (- delta) session))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn serial-adjust-node-counts
  "Start or stop the specified number of nodes."
  [delta-map session]
  (logging/trace (str "serial-adjust-node-counts" delta-map))
  (->>
   (:groups session)
   (map
    (fn [group]
      (adjust-node-count group ((:group-name group) delta-map 0) session)))
   (reduce #(merge-with concat %1 %2))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn parallel-adjust-node-counts
  "Start or stop the specified number of nodes."
  [delta-map session]
  (logging/trace (str "parallel-adjust-node-counts" delta-map))
  (->>
   (:groups session)
   (map
    (fn p-a-n-c-future [group]
      (future
        (adjust-node-count group ((:group-name group) delta-map 0) session))))
   futures/add
   doall ;; force generation of all futures
   (map
    (fn p-a-n-c-deref [f] (futures/deref-with-logging f "Adjust node count")))
   (reduce (fn p-a-n-c-r [m1 m2] (merge-with concat m1 m2)) {})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- converge-node-counts
  "Converge the nodes counts, given a compute facility and a reference number of
   instances. Returns a session object with :original-nodes, :all-nodes,
   :new-nodes and :old-nodes keys."
  [session]
  (logging/info "converging nodes")
  (let [delta-nodes ((environment/get-for session [:algorithms :converge-fn])
                     (node-count-difference (:groups session))
                     session)]
    (->
     session
     (assoc :original-nodes (:all-nodes session))
     (update-in [:all-nodes]
                #(vec (->>
                       %
                       (concat (:new-nodes delta-nodes))
                       (remove
                        (fn [node] (some
                                    (fn [n] (identical? n node))
                                    (:old-nodes delta-nodes)))))))
     (assoc-in [:new-nodes] (vec (:new-nodes delta-nodes)))
     (assoc-in [:old-nodes] (vec (:old-nodes delta-nodes))))))</pre></tr><tr><td class="docs"><p>middleware</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn log-session
  "Log the session state"
  [msg]
  (fn [session]
    (logging/info (format "%s Session is %s" msg session))
    session))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn log-message
  "Log the message"
  [msg]
  (fn [session]
    (logging/info (format "%s" msg))
    session))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- log-nodes
  "Log the node lists in the session state"
  [msg]
  (fn [session]
    (logging/info
     (format
      "%s nodes  %s with %s old nodes"
      msg
      (pr-str
       (select-keys
        session [:all-nodes :selected-nodes :new-nodes]))
      (count (:old-nodes session))))
    session))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-environment
  "Apply the effective environment"
  [session]
  (environment/session-with-environment
    session
    (environment/merge-environments
     (:environment session)
     (environment/eval-environment (-> session :server :environment)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn translate-action-plan
  [handler]
  (fn [session]
    (handler (action-plan/translate-for-target session))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn middleware-handler
  "Build a middleware processing pipeline from the specified middleware.
   The result is a middleware."
  [handler]
  (fn [session]
    ((reduce #(%2 %1) handler (:middleware session)) session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- execute
  "Execute the action plan"
  [session]
  (action-plan/execute-for-target session executor))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-phase-to-node
  "Apply a phase to a node session"
  [session]
  {:pre [(:server session) (:phase session)]}
  ((middleware-handler execute)
   (->
    session
    apply-environment
    add-session-keys-for-0-4-compatibility)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def *middleware*
  [translate-action-plan
   execute/ssh-user-credentials
   execute/execute-with-ssh])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-middleware
  "Wrap node execution in the given middleware. A middleware is a function of
   one argument (a handler function, that is the next middleware to call) and
   returns a dunction of one argument (the session map).  Middleware can be
   composed with the pipe macro."
  [f & body]
  `(binding [*middleware* ~f]
     ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- reduce-node-results
  "Combine the node execution results."
  [session results]
  (reduce
   (fn reduce-node-results-fn [session [result req :as arg]]
     (let [target-id (-> req :server :node-id)
           param-keys [:parameters]]
       (->
        session
        (assoc-in [:results target-id (:phase req)] result)
        (update-in
         param-keys
         (fn merge-params [p]
           (map-utils/deep-merge-with
            (fn merge-params-fn [x y] (or y x)) p (get-in req param-keys)))))))
   session
   results))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- plan-for-server
  "Build an action plan for the specified server."
  [session server]
  {:pre [(:node server) (:node-id server)]}
  (action-plan/build-for-target
   (->
    session
    (assoc :server server)
    add-session-keys-for-0-4-compatibility
    (environment/session-with-environment
      (environment/merge-environments
       (:environment session)
       (-> session :server :environment))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- plan-for-servers
  "Build an action plan for the specified servers."
  [session servers]
  (reduce plan-for-server session servers))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- plan-for-groups
  "Build an invocation map for specified node-type map."
  [session groups]
  (reduce
   (fn [session group]
     (plan-for-servers (assoc session :group group) (:servers group)))
   session groups))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- plan-for-phases
  "Build an invocation map for specified phases and nodes.
   This allows configuration to be accumulated in the session parameters."
  [session]
  (reduce
   (fn [session phase]
     (plan-for-groups (assoc session :phase phase) (:groups session)))
   session (:phase-list session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn sequential-apply-phase
  "Apply a phase to a sequence of nodes"
  [session servers]
  (logging/info
   (format
    "apply-phase %s for %s with %d nodes"
    (:phase session) (-> session :group :group-name) (count servers)))
  (for [server servers]
    (apply-phase-to-node (assoc session :server server))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn parallel-apply-phase
  "Apply a phase to a sequence of nodes"
  [session servers]
  (logging/info
   (format
    "apply-phase %s for %s with %d nodes"
    (:phase session) (-> session :group :group-name) (count servers)))
  (->>
   servers
   (map (fn [server]
          (future (apply-phase-to-node (assoc session :server server)))))
   futures/add))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- ensure-phase [phases phase-kw]
  (if (some #{phase-kw} phases)
    phases
    (concat [phase-kw] phases)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- identify-anonymous-phases
  [session phases]
  (reduce #(if (keyword? %2)
             [(first %1)
              (conj (second %1) %2)]
             (let [phase (keyword (name (gensym "phase")))]
               [(assoc-in (first %1) [:phases phase] %2)
                (conj (second %1) phase)])) [session []] phases))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn sequential-lift
  "Sequential apply the phases."
  [session]
  (apply
   concat
   (for [group (:groups session)]
     (sequential-apply-phase (assoc session :group group) (:servers group)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn parallel-lift
  "Apply the phases in sequence, to nodes in parallel."
  [session]
  (->>
   (for [group (:groups session)]
     (parallel-apply-phase (assoc session :group group) (:servers group)))
   (reduce concat [])
   doall                        ; make sure we start all futures before deref
   (map deref)                  ; make sure all nodes complete before next phase
   doall))                      ; make sure we force the deref</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift-nodes-for-phase
  "Lift nodes in target-node-map for the specified phases.
   Builds the commands for the phase, then executes pre-phase, phase, and
   after-phase"
  [session]
  (let [lift-fn (environment/get-for session [:algorithms :lift-fn])
        phase (:phase session)]
    (reduce
     (fn [session sub-phase]
       (let [session (->
                      session
                      (assoc :phase phase)
                      (plan-for-groups (:groups session))
                      (assoc :phase sub-phase))]
         (reduce-node-results session (lift-fn session))))
     session
     (phase/all-phases-for-phase phase))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift-nodes
  "Lift nodes in target-node-map for the specified phases."
  [session]
  (logging/info
   (format
    "lift-nodes phases %s, groups %s"
    (vec (:phase-list session))
    (vec (map :group-name (:groups session)))))
  (reduce
   (fn [session phase]
     (->
      session
      (assoc :phase phase)
      (plan-for-groups (:groups session))
      lift-nodes-for-phase))
   session
   (:phase-list session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc
    "Flag to control output of warnings about undefined phases in calls to lift
     and converge."}
  *warn-on-undefined-phase* true)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- warn-on-undefined-phase
  "Generate a warning for the elements of the session's :phase-list that are not
   defined in the session's :groups.
   No warnings are generated for the settings or configure phases."
  [session]
  (when *warn-on-undefined-phase*
    (when-let [undefined (seq
                          (set/difference
                           (set (filter keyword? (:phase-list session)))
                           #{:settings :configure}
                           (set
                            (concat
                             (->>
                              (:groups session)
                              (map (comp keys :phases))
                              (reduce concat))
                             (keys (:inline-phases session))))))]
      (logging/warn
       (format
        "Undefined phases: %s"
        (string/join ", " (map name undefined))))))
  session)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- group-with-prefix
  [prefix node-spec]
  (update-in node-spec [:group-name]
             (fn [group-name] (keyword (str prefix (name group-name))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-map-with-prefix [prefix node-map]
  (zipmap
   (map #(group-with-prefix prefix %) (keys node-map))
   (vals node-map)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- phase-list-with-configure
  "Ensure that the `phase-list` contains the :configure phase, prepending it if
  not."
  [phase-list]
  (->
   phase-list
   (ensure-phase :configure)
   (ensure-phase :settings)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- phase-list-with-default
  "Add the default configure phase if the `phase-list` is empty"
  [phase-list]
  (if (seq phase-list) phase-list [:settings :configure]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- session-with-configure-phase
  "Add the configure phase to the session's :phase-list if not present."
  [session]
  (update-in session [:phase-list] phase-list-with-configure))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- session-with-default-phase
  "Add the default phase to the session's :phase-list if none supplied."
  [session]
  (update-in session [:phase-list]
             (fn [phase-list]
               (-> phase-list
                   phase-list-with-default
                   (ensure-phase :settings)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-in-types?
  "Predicate for matching a node belonging to a set of node types"
  [node-types node]
  (some #(= (compute/group-name node) (name (% :group-name))) node-types))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- nodes-for-group
  "Return the nodes that have a group-name that matches one of the node types"
  [nodes group]
  (let [group-name (name (:group-name group))]
    (filter #(compute/node-in-group? group-name %) nodes)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- group-spec?
  "Predicate for testing if argument is a node-spec.
   This is not exhaustive, and not intended for general use."
  [x]
  (and (map? x) (:group-name x) (keyword? (:group-name x))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-in-set
  "Build a map of node-spec to nodes for the given `node-set`.
   A node set can be a node spec, a map from node-spec to a sequence of nodes,
   or a sequence of these.
   The prefix is applied to the group-name of each node-spec in the result.
   This allows you to build seperate clusters based on the same node-spec's.
   The return value is a map of node-spec to node sequence.
   Example node sets:
       node-spec-1
       [node-spec1 node-spec-2]
       {node-spec #{node1 node2}}
       [node-spec1 node-spec-2 {node-spec #{node1 node2}}]"
  [node-set prefix nodes]
  (letfn [(ensure-set [x] (if (set? x) x #{x}))
          (ensure-set-values
           [m]
           (zipmap (keys m) (map ensure-set (vals m))))]
    (cond
     (and (map? node-set) (not (group-spec? node-set)))
     (ensure-set-values (node-map-with-prefix prefix node-set))
     (group-spec? node-set)
     (let [group (group-with-prefix prefix node-set)]
       {group (set (nodes-for-group nodes group))})
     :else (reduce
            #(merge-with concat %1 %2) {}
            (map #(nodes-in-set % prefix nodes) node-set)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- server-with-packager
  "Add the target packager to the session"
  [server]
  (update-in server [:packager]
             (fn [p] (or p
                         (-> server :image :packager)
                         (compute/packager (:image server))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn server
  "Take a `group` and a `node`, an `options` map and combine them to produce
   a server.
   The group os-family, os-version, are replaced with the details form the
   node. The :node key is set to `node`, and the :node-id and :packager keys
   are set.
   `options` allows adding extra keys on the server."
  [group node options]
  (->
   group
   (update-in [:image :os-family] (fn [f] (or (compute/os-family node) f)))
   (update-in [:image :os-version] (fn [f] (or (compute/os-version node) f)))
   (update-in [:node-id] (fn [id] (or (keyword (compute/id node)) id)))
   (assoc :node node)
   server-with-packager
   (merge options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn groups-with-servers
  "Takes a map from node-spec to sequence of nodes, and converts it to a
   sequence of group definitions, containing a server for each node in then
   :servers key of each group.  The server will contain the node-spec,
   updated with any information that was available from the node.
       (groups-with-servers {(node-spec \"spec\" {}) [a b c]})
         => [{:group-name \"spec\"
              :servers [{:group-name \"spec\" :node a}
                        {:group-name \"spec\" :node b}
                        {:group-name \"spec\" :node c}]}]
   `options` allows adding extra keys to the servers."
  [node-map execute-node?]
  (for [[group nodes] node-map]
    (assoc group
      :servers (map
                (fn [node]
                  (server group node {:invoke-only (not (execute-node? node))}))
                (filter compute/running? nodes)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn session-with-all-nodes
  "If the :all-nodes key is not set, then the nodes are retrieved from the
   compute service if possible."
  [session]
  (let [nodes (filter
               compute/running?
               (or (:all-nodes session) ; empty list is ok
                   (when-let [compute (environment/get-for
                                       session [:compute] nil)]
                     (logging/info "retrieving nodes")
                     (compute/nodes compute))))]
    (assoc session :all-nodes nodes :selected-nodes nodes)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn session-with-groups
  "Takes the :selected-nodes, :all-nodes. :node-set and :prefix keys and compute
   the groups for the session, updating the :selected-nodes, :all-nodes
   and :groups keys of the session.
   The :groups key is set to a sequence of groups, each containing its
   list of servers on the :servers key."
  [session]
  (let [nodes (:selected-nodes session)
        all-nodes (:all-nodes session)
        all-targets (nodes-in-set
                     (:node-set session) (:prefix session) all-nodes)
        targets (nodes-in-set (:node-set session) (:prefix session) nodes)
        plan-targets (if-let [all-node-set (:all-node-set session)]
                       (-> (nodes-in-set all-node-set nil all-nodes)
                           (utils/dissoc-keys (keys targets))))]
    (->
     session
     (assoc :all-nodes (or (seq all-nodes)
                           (filter
                            compute/running?
                            (reduce
                             concat
                             (concat
                              (vals all-targets) (vals plan-targets))))))
     (assoc :selected-nodes (or (seq nodes)
                                (filter
                                 compute/running?
                                 (reduce concat (vals targets)))))
     (assoc :groups (concat
                     (groups-with-servers targets (set nodes))
                     (groups-with-servers plan-targets (constantly false)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn all-node-set-selector
  "Select all nodes for groups in the node-set for processing"
  [session]
  (assoc session :selected-nodes (:all-nodes session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn new-node-set-selector
  "Select all new nodes for groups in the node-set for processing"
  [session]
  (assoc session :selected-nodes (:new-nodes session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn select-node-set
  "Select a node-set of nodes to be passed to lift"
  [session]
  ((:node-set-selector session all-node-set-selector) session))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift*
  "Lift the nodes specified in the session :node-set key.
   - :node-set     - a specification of nodes to lift
   - :all-nodes    - a sequence of all known nodes
   - :all-node-set - a specification of nodes to invoke (but not lift)"
  [session]
  (logging/debug (format "pallet version: %s" (version)))
  (logging/trace (format "lift* phases %s" (vec (:phase-list session))))
  (->
   session
   session-with-all-nodes
   select-node-set
   session-with-groups
   session-with-default-phase
   warn-on-undefined-phase
   lift-nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn converge*
  "Converge the node counts of each node-spec in `:node-set`, executing each of
   the configuration phases on all the group-names in `:node-set`. The
   phase-functions are also executed, but not applied, for any other nodes in
   `:all-node-set`"
  [session]
  {:pre [(:node-set session)]}
  (logging/debug (format "pallet version: %s" (version)))
  (logging/trace
   (format "converge* phases %s" (vec (:phase-list session))))
  (->
   session
   session-with-all-nodes
   session-with-groups
   converge-node-counts
   lift*))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro or-fn [& args]
  `(fn or-args [current#]
     (or current# ~@args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- compute-from-options
  [current-value {:keys [compute compute-service]}]
  (or current-value
      compute
      (and compute-service
           (compute/compute-service
            (:provider compute-service)
            :identity (:identity compute-service)
            :credential (:credential compute-service)
            :extensions (:extensions compute-service)
            :node-list (:node-list compute-service)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- blobstore-from-options
  [current-value {:keys [blobstore blobstore-service]}]
  (or current-value
      blobstore
      (and blobstore-service
           (blobstore/service
            (:provider blobstore-service)
            :identity (:identity blobstore-service)
            :credential (:credential blobstore-service)
            :extensions (:extensions blobstore-service)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn default-environment
  "Specify the built-in default environment"
  []
  {:blobstore nil
   :compute nil
   :user utils/*admin-user*
   :middleware *middleware*
   :algorithms {:lift-fn parallel-lift
                :converge-fn parallel-adjust-node-counts}})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- effective-environment
  "Build the effective environment for the session map.
   This merges the explicitly passed :environment, with that
   defined on the :compute service."
  [session]
  (assoc
   session
   :environment
   (environment/merge-environments
    (default-environment)                                     ; global default
    (utils/find-var-with-require 'pallet.config 'environment) ; project default
    (-?> session :environment :compute environment/environment) ;service default
    (:environment session))))                                 ; session default</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc "args that are really part of the environment"}
  environment-args [:compute :blobstore :user :middleware])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- session-with-environment
  "Build a session map from the given options, combining the service specific
   options with those given in the converge or lift invocation."
  [{:as options}]
  (->
   options
   (update-in                           ; ensure backwards compatable
    [:environment]
    merge (select-keys options environment-args))
   (assoc :executor default-executors)
   (utils/dissoc-keys environment-args)
   (effective-environment)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc "A set of recognised argument keywords, used for input checking."
       :private true}
  argument-keywords
  #{:compute :blobstore :phase :user :prefix :middleware :all-node-set
    :all-nodes :parameters :environment :node-set :phase-list
    :node-set-selector})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- check-arguments-map
  "Check an arguments map for errors."
  [{:as options}]
  (let [unknown (remove argument-keywords (keys options))]
    (when (and (:phases options) (not (:phase options)))
      (condition/raise
       :type :invalid-argument
       :message (str
                 "Please pass :phase and not :phases. :phase takes a single "
                 "phase or a sequence of phases.")
       :invalid-keys unknown))
    (when (seq unknown)
      (condition/raise
       :type :invalid-argument
       :message (format "Invalid argument keywords %s" (vec unknown))
       :invalid-keys unknown)))
  options)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- identify-anonymous-phases
  "For all inline phase defintions in the session's :phase-list,
   generate a keyword for the phase, adding an entry to the session's
   :inline-phases map containing the phase definition, and replacing the
   phase defintion in the :phase-list with the keyword."
  [session]
  (reduce
   (fn [session phase]
     (if (keyword? phase)
       (update-in session [:phase-list] #(conj (or % []) phase))
       (let [phase-kw (keyword (name (gensym "phase")))]
         (->
          session
          (assoc-in [:inline-phases phase-kw] phase)
          (update-in [:phase-list] conj phase-kw)))))
   (dissoc session :phase-list)
   (:phase-list session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- group-spec-with-count
  "Take the given group-spec, and set the :count key to the value specified
   by `count`"
  [[group-spec count]]
  (assoc group-spec :count count))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-set-for-converge
  "Takes the input, and translates it into a sequence of group-spec's.
   The input can be a single group-spec, a map from group-spec to node count,
   or a sequence of group-spec's"
  [group-spec->count]
  (cond
   ;; a single group-spec
   (and
    (map? group-spec->count)
    (:group-name group-spec->count)) [group-spec->count]
   ;; a map from group-spec to count
   (map? group-spec->count) (map group-spec-with-count group-spec->count)
   :else group-spec->count))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn converge
  "Converge the existing compute resources with the counts specified in
   `group-spec->count`. New nodes are started, or nodes are destroyed,
   to obtain the specified node counts.
   `group-spec->count` can be a map from group-spec to node count, or can be a
   sequence of group-specs containing a :count key.
   The compute service may be supplied as an option, otherwise the bound
   compute-service is used.
   This applies the bootstrap phase to all new nodes and the configure phase to
   all running nodes whose group-name matches a key in the node map.  Additional
   phases can also be specified in the options, and will be applied to all
   matching nodes.  The :configure phase is always applied, by default as the
   first (post bootstrap) phase.  You can change the order in which
   the :configure phase is applied by explicitly listing it.
   An optional group-name prefix may be specified. This will be used to modify
   the group-name for each group-spec, allowing you to build multiple discrete
   clusters from a single set of group-specs."
  [group-spec->count & {:keys [compute blobstore user phase prefix middleware
                               all-nodes all-node-set environment]
                        :as options}]
  (converge*
   (->
    options
    (assoc :node-set (node-set-for-converge group-spec->count)
           :phase-list (if (sequential? phase)
                         phase
                         (if phase [phase] [:configure])))
    check-arguments-map
    session-with-environment
    identify-anonymous-phases)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift
  "Lift the running nodes in the specified node-set by applying the specified
   phases.  The compute service may be supplied as an option, otherwise the
   bound compute-service is used.  The configure phase is applied by default
   unless other phases are specified.
   node-set can be a node type, a sequence of node types, or a map
   of node type to nodes. Examples:
              [node-type1 node-type2 {node-type #{node1 node2}}]
              node-type
              {node-type #{node1 node2}}
   options can also be keywords specifying the phases to apply, or an immediate
   phase specified with the phase macro, or a function that will be called with
   each matching node.
   Options:
    :compute         a jclouds compute service
    :compute-service a map of :provider, :identity, :credential, and
                     optionally :extensions for constructing a jclouds compute
                     service.
    :phase           a phase keyword, phase function, or sequence of these
    :middleware      the middleware to apply to the configuration pipeline
    :prefix          a prefix for the group-name names
    :user            the admin-user on the nodes"
  [node-set & {:keys [compute phase prefix middleware all-node-set environment]
               :as options}]
  (lift*
   (->
    options
    (assoc :node-set node-set
           :phase-list (if (sequential? phase)
                         phase
                         (if phase [phase] [:configure])))
    check-arguments-map
    (dissoc :all-node-set :phase)
    session-with-environment
    identify-anonymous-phases)))</pre></tr><tr><td class="docs"><p>Cluster operations</p>
</td><td class="codes" /><pre class="brush: clojure">(defn cluster-groups
  "Return the groups in the passed cluster or sequence of clusters."
  [cluster]
  (if (seq? cluster)
    (mapcat :groups cluster)
    (:groups cluster)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn converge-cluster
  "Converge the specified cluster. As for `converge`, but takes a cluster-spec
   or sequence of cluster-specs."
  [cluster & options]
  (apply converge (cluster-groups cluster) options))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift-cluster
  "Lift the specified cluster.  As for `lift`, but takes a cluster-spec
   or sequence of cluster-specs."
  [cluster & options]
  (apply lift (cluster-groups cluster) options))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn destroy-cluster
  "Destroy the specified cluster. As for `converge`, but takes a cluster-spec
   or sequence of cluster-specs."
  [cluster & options]
  (apply converge (map #(assoc % :count 0) (cluster-groups cluster)) options))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.network-service" name="pallet.crate.network-service"><h1 class="project-name">pallet.crate.network-service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Crate for working with network services</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.crate.network-service
  (:require
   [pallet.action.exec-script :as exec-script]
   [pallet.script.lib :as lib]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-port-listen
  "Wait for the network port `port` to be in a listening state.
   Options:
   - :standoff      time between checking port state (seconds)
   - :max-retries   number of times to test port state before erroring
   - :service-name  name of service to use in messages (defaults to port)"
  [session port & {:keys [max-retries standoff service-name]
                   :or {max-retries 5 standoff 2
                        service-name (str "port " port)}}]
  (->
   session
   (exec-script/exec-checked-script
    (format "Wait for %s to be in a listen state" service-name)
    (group (chain-or (let x 0) true))
    (while
        (pipe (netstat -lnt) (awk ~(format "'$4 ~ /:%s$/ {exit 1}'" port)))
      (let x (+ x 1))
      (if (= ~max-retries @x)
        (do
          (println
           ~(format "Timed out waiting for listen state for %s" service-name)
           >&2)
          (~lib/exit 1)))
      (println ~(format "Waiting for %s to be in a listen state" service-name))
      (sleep ~standoff))
    (sleep ~standoff))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-http-status
  "Wait for a url to respond with the given HTTP status code.
   Options:
   - :standoff      time between checking HTTP status (seconds)
   - :max-retries   number of times to test HTTP status before erroring
   - :url-name      name of url to use in messages (defaults to url)"
  [session url status & {:keys [max-retries standoff url-name]
                         :or {max-retries 5 standoff 2
                              url-name url}}]
  (->
   session
   (exec-script/exec-checked-script
    (format "Wait for %s to return a %s status" url-name status)
    (if (~lib/has-command? wget)
      (defn httpresponse []
        (pipe
         ("wget" -q -S -O "/dev/null" (quoted ~url) "2>&1")
         ("grep" "HTTP/1.1")
         ("tail" -1)
         ("grep" -o -e (quoted "[0-9][0-9][0-9]"))))
      (if (~lib/has-command? curl)
        (defn httpresponse []
          ("curl" -sL -w (quoted "%{http_code}") (quoted ~url)
           -o "/dev/null"))
        (do
          (println "No httpresponse utility available")
          (~lib/exit 1))))
    (group (chain-or (let x 0) true))
    (while
        (!= ~status @(httpresponse))
      (let x (+ x 1))
      (if (= ~max-retries @x)
        (do
          (println
           ~(format
             "Timed out waiting for %s to return a %s status" url-name status)
           >&2)
          (~lib/exit 1)))
      (println ~(format "Waiting for %s to return a %s status" url-name status))
      (sleep ~standoff))
    (sleep ~standoff))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-port-response
  "Wait for a port to respond to a message with a given response regex.
   Options:
   - :host          host to check (defaults to localhost)
   - :timeout       time to wait for a response (default 2 secs)
   - :standoff      time between checking HTTP status (seconds)
   - :max-retries   number of times to test HTTP status before erroring
   - :service-name  name of service to use in messages (defaults to port)"
  [session port message response-regex
   & {:keys [host timeout max-retries standoff service-name]
      :or {host "localhost" max-retries 5 standoff 2 timeout 2
           service-name (str "port " port)}}]
  (->
   session
   (exec-script/exec-checked-script
    (format
     "Wait for %s to return a response %s to message %s"
     service-name response-regex message)
    (group (chain-or (let x 0) true))
    (while
        (! (pipe (println (quoted ~message))
                 ("nc" -q ~timeout ~host ~port)
                 ("grep" -E (quoted ~response-regex))))
      (let x (+ x 1))
      (if (= ~max-retries @x)
        (do
          (println
           ~(format
             "Timed out waiting for %s to return response %s"
             service-name response-regex)
           >&2)
          (~lib/exit 1)))
      (println
       ~(format
         "Waiting for %s to return response %s" service-name response-regex))
      (sleep ~standoff))
    (sleep ~standoff))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.session-store" name="pallet.crate.session-store"><h1 class="project-name">pallet.crate.session-store</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Crate functions for session storage on the target node.</p>

<pre><code>  (save-session session)
  (load-session session)
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.crate.session-store
  (:require
   [pallet.parameter :as parameter]
   [pallet.resource :as resource]
   [pallet.resource.remote-file :as remote-file]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:dynamic true} *file-path* ".pallet-session.clj")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn save-session
  [request & {:keys [path] :or {path *file-path*}}]
  (remote-file/remote-file
   request
   path
   :content (pr-str (parameter/get-for-target request [] {}))
   :literal true))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn load-session
  [request & {:keys [path] :or {path *file-path*}}]
  (resource/execute-pre-phase
   (remote-file/with-remote-file
     request
     (fn [request local-path]
       (resource/as-local-resource
        request
        (fn [request]
          (parameter/update-for-target
           request [] merge (load-file (.getAbsolutePath local-path))))))
     path)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate" name="pallet.crate"><h1 class="project-name">pallet.crate</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>The crate monad.</p>

<p>   There are two issues with crates as monads.</p>

<pre><code> i) need to reimplate crate functions to return functions of one
 argument [state], so that they have a common signature for manipulation
 as monadic functions.

 ii) to achieve pluggable error handling, etc, via monads, requires
 runtime use of monads, which isn't possible with c.c.monads.
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.crate
  (:require
   [clojure.contrib.monads :as monad]))</pre></tr><tr><td class="docs"><p>The crate monad is an identity monad</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc }
  crate-m monad/identity-m)</pre></tr><tr><td class="docs"><p>Create an anonymous crate function</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro cratefn
  [[session & args] & body]
  `(fn [~@args] (fn [~'session] ~@body)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def a (cratefn [session a] (assoc session :a a)))
(def bc (cratefn [session b c] (assoc session :b b :c c)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(use 'clojure.test)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftest cratefn-test
  (is (= {:a 1} ((a 1) {:a 2})))
  (is (= {:a 1 :b 2 :c 3} ((bc 2 3) {:a 1}))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftest basic-test
  (is (= {:a 1} (monad/with-monad crate-m (m-bind {:a 1} identity))))
  (is (= {:a 1 :b 2}
         (monad/with-monad crate-m
           ((monad/m-chain [ #(assoc % :a 1) #(assoc % :b 2)]) {}))))
  (is (= {:a 1 :b 2 :c 3}
         (monad/with-monad crate-m
           ((monad/m-chain [(a 1) (bc 2 3)]) {}))))
  (is (= {:a 1 :b 2 :c 3}
         (monad/with-monad crate-m
           ((monad/m-chain [(a 4) (bc 2 3) (a 1)]) {})))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.debug" name="pallet.debug"><h1 class="project-name">pallet.debug</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Helpers for debugging.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.debug
  (:require
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs"><p>A crate function that will log the session map at the debug level, using
   the supplied format string.</p>

<pre><code>   (log-session session "The session is %s")
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn log-session
  ([session]
     (log-session session "%s"))
  ([session format-string]
     (logging/debug (format format-string (pr-str session)))
     session))</pre></tr><tr><td class="docs"><p>A crate function that will print the session map to <em>out</em>, using the supplied
   format string.</p>

<pre><code>   (print-session session "The session is %s")
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn print-session
  ([session]
     (print-session session "%s"))
  ([session format-string]
     (println (format format-string (pr-str session)))
     session))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.enlive" name="pallet.enlive"><h1 class="project-name">pallet.enlive</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Wrappers for enlive to enable template specialisation and use xml.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.enlive
  (:use
   [pallet.template :only [find-template]]
   clojure.contrib.logging)
  (:require
   [net.cgrand.enlive-html :as enlive]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn elt
 ([tag] (elt tag nil))
 ([tag attrs & content]
   {:tag tag
    :attrs attrs
    :content content}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro transform-nodes
  [[nodes] & forms]
  `(enlive/flatmap (enlive/transformation ~@forms) ~nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro deffragment
  [name args & forms]
  `(defn ~name ~args
     (fn [nodes#] (enlive/at nodes# ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def memo-xml-resource
     (memoize
      (fn [source session]
        (if-let [source (find-template source session)]
          (enlive/xml-resource source)
          (error
           (format
            "No template found for %s %s"
            source (-> session :server :tag)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defsnippet
  "A snippet returns a collection of nodes."
  [name source session args & forms]
  `(defn ~name ~args
    (if-let [nodes# (memo-xml-resource ~source ~session)]
      (enlive/at nodes# ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro xml-template
  "A template returns a seq of string:
   Overridden from enlive to defer evaluation of the source until runtime, and
   to enable specialisation on node-type"
  [source session args & forms]
  `(comp enlive/emit*
         (fn ~args
           (if-let [nodes# (memo-xml-resource ~source ~session)]
             (enlive/flatmap (enlive/transformation ~@forms) nodes#)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn xml-emit
  "Emit a template, adding an XML Declaration."
  [f & args]
  (str "<?xml version='1.0' encoding='utf-8'?>\n"
       (apply str (apply f args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro transform-if [expr transform]
  `(if ~expr ~transform identity))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro transform-if-let [binding transform]
  `(if-let ~binding ~transform identity))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.environment" name="pallet.environment"><h1 class="project-name">pallet.environment</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>The environment provide a mechanism for customising pallet and
   pallet crates according to some externally determined criteria.</p>

<p>   An environment can be specified at the global, service, invocation and tag
   scopes.</p>

<p>   To provide a global default, specify an :environment key at the top level
   of <code>defpallet</code> in <code>~/.pallet/config.clj</code>.</p>

<p>   To provide a service spevific default, specify an :environment key at the
   service level of <code>defpallet</code> in <code>~/.pallet/config.clj</code>.</p>

<p>   To provide a project specific default, define <code>pallet.config/environment</code>.</p>

<p>   To provide a specific environment when invoking lift or converge, pass an
   environment map using the <code>:environment</code> key.</p>

<p>   The merging of values between scopes is key specific, and is determined by
   <code>merge-key-algorithm</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.environment
  (:require
   [pallet.common.deprecate :as deprecate]
   [pallet.utils :as utils]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging]
   [clojure.contrib.map-utils :as map-utils]
   [clojure.walk :as walk])
  (:use
   [clojure.contrib.core :only [-?>]]))</pre></tr><tr><td class="docs"><p>A protocol for accessing an environment.</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Environment
  (environment [_] "Returns an environment map"))</pre></tr><tr><td class="docs"><p>Map from key to merge algorithm. Specifies how environments are merged.</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc
    }
  merge-key-algorithm
  {:phases :merge-comp
   :user :merge
   :image :merge
   :compute :replace
   :blobstore :replace
   :count :merge
   :algorithms :merge
   :executor :merge
   :middleware :replace
   :groups :merge-environments
   :tags :merge-environments})</pre></tr><tr><td class="docs"><p>node specific environment keys</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc }
  node-keys [:image :phases])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def standard-pallet-keys (keys merge-key-algorithm))</pre></tr><tr><td class="docs"><p>Merge function that dispatches on the map entry key</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti merge-key
  (fn [key val-in-result val-in-latter]
    (merge-key-algorithm key :deep-merge)))</pre></tr><tr><td class="docs"><p>Returns a map that consists of the rest of the maps conj-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling (merge-key key val-in-result val-in-latter).</p>
</td><td class="codes" /><pre class="brush: clojure">(defn merge-environments
  [& maps]
  (when (some identity maps)
    (let [merge-entry (fn [m e]
                        (let [k (key e) v (val e)]
                          (if (contains? m k)
                            (assoc m k (merge-key k (get m k) v))
                            (assoc m k v))))
          merge2 (fn [m1 m2]
                   (reduce merge-entry (or m1 {}) (seq m2)))]
      (reduce merge2 maps))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod merge-key :replace
  [key val-in-result val-in-latter]
  val-in-latter)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod merge-key :merge
  [key val-in-result val-in-latter]
  (merge val-in-result val-in-latter))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod merge-key :deep-merge
  [key val-in-result val-in-latter]
  (let [map-or-nil? (fn [x] (or (nil? x) (map? x)))]
    (map-utils/deep-merge-with
     (fn deep-merge-env-fn [x y]
       (if (and (map-or-nil? x) (map-or-nil? y))
         (merge x y)
         (or y x)))
     val-in-result val-in-latter)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod merge-key :merge-comp
  [key val-in-result val-in-latter]
  (merge-with comp val-in-latter val-in-result))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod merge-key :merge-environments
  [key val-in-result val-in-latter]
  (merge-environments val-in-result val-in-latter))</pre></tr><tr><td class="docs"><p>Evaluate a phase definition.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- eval-phase
  [phase]
  (if (or (list? phase) (instance? clojure.lang.Cons phase))
    (eval phase)
    phase))</pre></tr><tr><td class="docs"><p>Evaluate a phase map.  This will attempt to require any namespaces mentioned
   and will then read each phase definition.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- eval-phases
  [phases]
  (walk/postwalk
   #(do
      (when (symbol? %)
        (when-let [n (namespace %)]
          (utils/find-var-with-require %)))
      %)
   phases)
  (zipmap (keys phases) (map eval-phase (vals phases))))</pre></tr><tr><td class="docs"><p>Evaluate an algorithm map.  This will attempt to require any namespaces
   mentioned and will then lookup each symbol to retrieve the specified
   var.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- eval-algorithms
  [algorithms]
  (walk/postwalk
   #(or
     (when (and (symbol? %) (namespace %))
       (utils/find-var-with-require %))
      %)
   algorithms))</pre></tr><tr><td class="docs"><p>Evaluate an environment literal.  This is used to replace certain keys with
   objects constructed from the map of values provided.  The keys that are
   evaluated are:
   - :user
   - :phases
   - :algorithms</p>
</td><td class="codes" /><pre class="brush: clojure">(defn eval-environment
  [env-map]
  (let [env-map (if-let [user (:user env-map)]
                  (if-let [username (:username user)]
                    (assoc
                        env-map :user
                        (apply
                         utils/make-user username (mapcat identity user)))
                    env-map)
                  env-map)
        env-map (if-let [phases (:phases env-map)]
                  (if (every? fn? (vals phases))
                    env-map
                    (assoc env-map :phases (eval-phases phases)))
                  env-map)
        env-map (if-let [algorithms (:algorithms env-map)]
                  (if (every? fn? (vals algorithms))
                    env-map
                    (assoc env-map :algorithms (eval-algorithms algorithms)))
                  env-map)]
    env-map))</pre></tr><tr><td class="docs"><p>Retrieve the environment value at the path specified by keys.
   When no default value is specified, then raise a :environment-not-found if no
   environment value is set.</p>

<pre><code>   (get-for {:p {:a {:b 1} {:d 2}}} [:p :a :d])
     =&gt; 2
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn get-for
  ([session keys]
     (let [result (get-in (:environment session) keys ::not-set)]
       (when (= ::not-set result)
         (condition/raise
          :type :environment-not-found
          :message (format
                    "Could not find keys %s in session :environment"
                    (if (sequential? keys) (vec keys) keys))
          :key-not-set keys))
       result))
  ([session keys default]
       (get-in (:environment session) keys default)))</pre></tr><tr><td class="docs"><p>Returns an updated <code>session</code> map, containing the keys for the specified
   <code>environment</code> map.</p>

<p>   When session includes a :server value, then the :server value is
   treated as an environment, and merge with any environment in the
   <code>environment</code>'s :groups key.</p>

<p>   The node-specific environment keys are :images and :phases.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn session-with-environment
  [session environment]
  (when (:tags environment)
    (deprecate/warn
     (str "Use of :tags key in the environment is deprecated. "
          "Please change to use :groups.")))
  (let [session (merge
                 session
                 (->
                  environment
                  (select-keys standard-pallet-keys)
                  (utils/dissoc-keys (conj node-keys :groups :tags))))
        session (assoc-in session [:environment]
                          (utils/dissoc-keys environment node-keys))
        session (if (:server session)
                  (let [tag (-> session :server :group-name)]
                    (assoc session
                      :server (merge-environments
                               (:server session)
                               (select-keys environment node-keys)
                               (-?> environment :tags tag) ; deprecated
                               (-?> environment :groups tag))))
                  session)
        session (if (:group session)
                  (let [tag (-> session :group :group-name)]
                    (assoc session
                      :group (merge-environments
                              (:group session)
                              (select-keys environment node-keys)
                              (-?> environment :tags tag) ; deprecated
                              (-?> environment :groups tag))))
                  session)]
    session))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.execute" name="pallet.execute"><h1 class="project-name">pallet.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Exectute commands.  At the moment the only available transport is ssh.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.execute
  (:require
   [pallet.action-plan :as action-plan]
   [pallet.action.file :as file]
   [pallet.common.shell :as shell]
   [pallet.compute :as compute]
   [pallet.compute.jvm :as jvm]
   [pallet.environment :as environment]
   [pallet.script :as script]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.utils :as utils]
   [clj-ssh.ssh :as ssh]
   [clojure.string :as string]
   [clojure.contrib.condition :as condition]
   [clojure.java.io :as io]
   [pallet.shell :as ccshell]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def prolog
  (str "#!/usr/bin/env bash\n"
       stevedore/hashlib))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- normalise-eol
  "Convert eol into platform specific value"
  [#^String s]
  (string/replace s #"[\r\n]+" (str \newline)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- strip-sudo-password
  "Elides the user's password or sudo-password from the given ssh output."
  [#^String s user]
  (string/replace
   s (format "\"%s\ (or (:password user) (:sudo-password user))) "XXXXXXX"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript sudo-no-password [])
(script/defimpl sudo-no-password :default []
  ("/usr/bin/sudo" -n))
(script/defimpl sudo-no-password
  [#{:centos-5.3 :os-x :darwin :debian :fedora}]
  []
  ("/usr/bin/sudo"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn sudo-cmd-for
  "Construct a sudo command prefix for the specified user."
  [user]
  (if (or (= (:username user) "root") (:no-sudo user))
    "/bin/bash "
    (if-let [pw (:sudo-password user)]
      (str "echo \ (or (:password user) pw) "\" | /usr/bin/sudo -S ")
      (str (stevedore/script (~sudo-no-password)) " "))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc "Specifies the buffer size used to read the ssh output stream.
    Defaults to 10K, to match clj-ssh.ssh/*piped-stream-buffer-size*"}
  ssh-output-buffer-size (atom (* 1024 10)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc "Specifies the polling period for retrieving ssh command output.
    Defaults to 1000ms."}
  output-poll-period (atom 1000))</pre></tr><tr><td class="docs"><p>local script execution</p>
</td><td class="codes" /><pre class="brush: clojure">(defn local-cmds
  "Run local cmds on a target."
  [#^String commands]
  (let [execute (fn [cmd] ((second cmd)))
        rv (doall (map execute (filter #(= :origin (first %)) commands)))]
    rv))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn read-buffer [stream]
  (let [buffer-size @ssh-output-buffer-size
        bytes (byte-array buffer-size)
        sb (StringBuilder.)]
    {:sb sb
     :reader (fn []
               (when (pos? (.available stream))
                 (let [num-read (.read stream bytes 0 buffer-size)
                       s (normalise-eol (String. bytes 0 num-read "UTF-8"))]
                   (logging/info (format "Output:\n%s" s))
                   (.append sb s)
                   s)))}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn sh-script
  "Run a script on local machine."
  [command]
  (logging/trace
   (format "sh-script %s" command))
  (let [tmp (java.io.File/createTempFile "pallet" "script")]
    (try
      (io/copy (str prolog command) tmp)
      (ccshell/sh "chmod" "+x" (.getPath tmp))
      (let [{:keys [out err proc]} (ccshell/sh
                                    "bash" (.getPath tmp) :async true)
            out-reader (read-buffer out)
            err-reader (read-buffer err)
            period @output-poll-period]
        (with-open [out out err err]
          (while (not (try (.exitValue proc)
                           (catch IllegalThreadStateException _)))
            (Thread/sleep period)
            (logging/spy ((:reader out-reader)))
            (logging/spy ((:reader err-reader))))
          (while (logging/spy ((:reader out-reader))))
          (while (logging/spy ((:reader err-reader))))
          (let [exit (.exitValue proc)]
            (when-not (zero? exit)
              (logging/error
               (format
                "Command failed: %s\n%s"
                command (str (:sb err-reader)))))
            {:exit exit
             :out (str (:sb out-reader))
             :err (str (:sb err-reader))})))
      (finally  (.delete tmp)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro local-script
  "Run a script on the local machine, setting up stevedore to produce the
   correct target specific code"
  [& body]
  `(script/with-script-context
     [(jvm/os-family)]
     (sh-script
      (stevedore/script
       ~@body))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn verify-sh-return
  "Verify the return code of a sh execution"
  [msg cmd result]
  (when-not (zero? (:exit result))
    (condition/raise
     :message (format
               "Error executing script %s\n :cmd %s :out %s\n :err %s"
               msg cmd (:out result) (:err result))
     :type :pallet-script-excution-error
     :script-exit (:exit result)
     :script-out  (:out result)
     :script-err (:err result)
     :server "localhost"))
  result)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro local-checked-script
  "Run a script on the local machine, setting up stevedore to produce the
   correct target specific code.  The return code is checked."
  [msg & body]
  `(script/with-template
     [(jvm/os-family)]
     (let [cmd# (stevedore/checked-script ~msg ~@body)]
       (verify-sh-return ~msg cmd# (sh-script cmd#)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn local-sh-cmds
  "Execute cmds for the session.
   Runs locally as the current user, so useful for testing."
  [{:keys [root-path] :or {root-path "/tmp/"} :as session}]
  (if (seq (action-plan/get-for-target session))
    (letfn [(execute-bash
             [cmdstring]
             (logging/info (format "Cmd %s" cmdstring))
             (sh-script cmdstring))
            (transfer
             [transfers]
             (logging/info (format "Local transfer"))
             (doseq [[from to] transfers]
               (logging/info (format "Copying %s to %s" from to))
               (io/copy (io/file from) (io/file to))))]
      (action-plan/execute-for-target
       session
       {:script/bash execute-bash
        :fn/clojure (fn [& _])
        :transfer/to-local transfer
        :transfer/from-local transfer}))
    [nil session]))</pre></tr><tr><td class="docs"><p>ssh</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce default-agent-atom (atom nil))
(defn default-agent
  []
  (or @default-agent-atom
      (swap! default-agent-atom
             (fn [agent]
               (if agent
                 agent
                 (ssh/create-ssh-agent false))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn possibly-add-identity
  [agent private-key-path passphrase]
  (if passphrase
    (ssh/add-identity agent private-key-path passphrase)
    (ssh/add-identity-with-keychain agent private-key-path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- ssh-mktemp
  "Create a temporary remote file using the `ssh-session` and the filename
  `prefix`"
  [ssh-session prefix]
  (let [result (ssh/ssh
                ssh-session
                (stevedore/script (println (~lib/make-temp-file ~prefix)))
                :return-map true)]
    (if (zero? (:exit result))
      (string/trim (result :out))
      (condition/raise
       :type :remote-execution-failure
       :message (format
                 "Failed to generate remote temporary file %s" (:err result))
       :exit (:exit result)
       :err (:err result)
       :out (:out result)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn remote-sudo-cmd
  "Execute remote command.
   Copies `command` to `tmpfile` on the remote node using the `sftp-channel`
   and executes the `tmpfile` as the specified `user`."
  [server ssh-session sftp-channel user tmpfile command
   {:keys [pty] :or {pty true} :as options}]
  (when (not (ssh/connected? ssh-session))
    (condition/raise :type :no-ssh-session
                     :message (format"No ssh session for %s" server)))
  (let [response (ssh/sftp sftp-channel
                           :put (java.io.ByteArrayInputStream.
                                 (.getBytes
                                  (str prolog command \newline)))
                           tmpfile
                           :return-map true)
        response2 (ssh/sftp sftp-channel :ls)]
    (logging/info
     (format "Transfering commands to %s:%s : %s" server tmpfile response)))
  (let [chmod-result (ssh/ssh
                      ssh-session (str "chmod 755 " tmpfile) :return-map true)]
    (if (pos? (chmod-result :exit))
      (logging/error (str "Couldn't chmod script : "  (chmod-result :err)))))
  (let [cmd (str (sudo-cmd-for user) "./" tmpfile)
        _ (logging/info (format "Running %s" cmd))
        [shell stream] (ssh/ssh
                        ssh-session
                        ;; using :in forces a shell ssh-session, rather than
                        ;; exec; some services check for a shell ssh-session
                        ;; before detaching (couchdb being one prime
                        ;; example)
                        :in cmd
                        :out :stream
                        :return-map true
                        :pty pty)
        sb (StringBuilder.)
        buffer-size @ssh-output-buffer-size
        period @output-poll-period
        bytes (byte-array buffer-size)
        read-ouput (fn []
                     (when (pos? (.available stream))
                       (let [num-read (.read stream bytes 0 buffer-size)
                             s (normalise-eol
                                (strip-sudo-password
                                 (String. bytes 0 num-read "UTF-8") user))]
                         (logging/info (format "Output: %s\n%s" server s))
                         (.append sb s)
                         s)))]
    (while (ssh/connected? shell)
      (Thread/sleep period)
      (read-ouput))
    (while (read-ouput))
    (let [exit (.getExitStatus shell)
          stdout (str sb)]
      (when-not (zero? exit)
        (do
          (logging/error (str "Exit status  : " exit))
          (condition/raise
           :message (format
                     "Error executing script :\n :cmd %s\n :out %s\n"
                     command stdout)
           :type :pallet-script-excution-error
           :script-exit exit
           :script-out stdout
           :server server)))
      (ssh/ssh ssh-session (str "rm " tmpfile))
      {:out stdout :exit exit})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn remote-sudo
  "Run a sudo command on a server."
  [#^String server #^String command user {:keys [pty] :as options}]
  (ssh/with-ssh-agent [(default-agent)]
    (possibly-add-identity
     ssh/*ssh-agent* (:private-key-path user) (:passphrase user))
    (let [ssh-session (ssh/session server
                               :username (:username user)
                               :password (:password user)
                               :strict-host-key-checking :no)]
      (ssh/with-connection ssh-session
        (let [tmpfile (ssh-mktemp ssh-session "remotesudo")
              sftp-channel (ssh/ssh-sftp ssh-session)]
          (logging/info (format "Cmd %s" command))
          (ssh/with-connection sftp-channel
            (remote-sudo-cmd
             server ssh-session sftp-channel user tmpfile command options)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn remote-exec
  "Run an ssh exec command on a server."
  [#^String server #^String command user]
  (ssh/with-ssh-agent [(default-agent)]
    (possibly-add-identity
     ssh/*ssh-agent* (:private-key-path user) (:passphrase user))
    (let [ssh-session (ssh/session server
                               :username (:username user)
                               :password (:password user)
                               :strict-host-key-checking :no)]
      (ssh/with-connection ssh-session
        (logging/info (format "Exec %s" command))
        (ssh/ssh-exec ssh-session command nil "UTF-8" nil)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- ensure-ssh-connection
  "Try ensuring an ssh connection to the server specified in the session."
  [session]
  (let [{:keys [server port user ssh-session sftp-channel tmpfile tmpcpy]
         :as ssh} (:ssh session)]
    (when-not
        (and server
             (if (string? server) (not (string/blank? server)) true)
             user)
      (condition/raise
       :type :session-missing-middleware
       :message (str
                 "The session is missing server ssh connection details.\n"
                 "Add middleware to enable ssh.")))
    (let [ssh-session (or ssh-session
                      (ssh/session
                       server
                       :username (:username user)
                       :strict-host-key-checking :no
                       :port port
                       :password (:password user)))
          _ (when-not (ssh/connected? ssh-session) (ssh/connect ssh-session))
          tmpfile (or tmpfile (ssh-mktemp ssh-session "sudocmd"))
          tmpcpy (or tmpcpy (ssh-mktemp ssh-session "tfer"))
          sftp-channel (or sftp-channel (ssh/ssh-sftp ssh-session))
          _ (when-not (ssh/connected? sftp-channel) (ssh/connect sftp-channel))]
      (update-in session [:ssh] merge
                 {:ssh-session ssh-session
                  :tmpfile tmpfile
                  :tmpcpy tmpcpy
                  :sftp-channel sftp-channel}))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- close-ssh-connection
  "Close any ssh connection to the server specified in the session."
  [session]
  (let [{:keys [ssh-session sftp-channel tmpfile tmpcpy] :as ssh} (:ssh session)]
    (if ssh
      (do
        (when (and sftp-channel (ssh/connected? sftp-channel))
          ;; remove tmpfile, tmpcpy
          (ssh/disconnect sftp-channel))
        (when (and ssh-session (ssh/connected? ssh-session))
          (ssh/disconnect ssh-session))
        (dissoc session :ssh))
      session)))</pre></tr><tr><td class="docs"><p>executor functions</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn bash-on-origin
  "Execute a bash action on the origin"
  [session f]
  (let [{:keys [value session]} (f session)
        result (sh-script value)]
    (logging/info (format "Origin cmd\n%s" value))
    (verify-sh-return "for origin cmd" value result)
    [result session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn transfer-on-origin
  "Transfer files on origin by copying"
  [session f]
  (let [{:keys [value session]} (f session)]
    (logging/info "Local transfer")
    (doseq [[from to] value]
      (logging/info (format "Copying %s to %s" from to))
      (io/copy (io/file from) (io/file to)))
    [value session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn clojure-on-origin
  "Execute a clojure function on the origin"
  [session f]
  (let [{:keys [value session]} (f session)]
    [value session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn ssh-bash-on-target
  "Execute a bash action on the target via ssh."
  [session f]
  (let [{:keys [ssh] :as session} (ensure-ssh-connection session)
        {:keys [server ssh-session sftp-channel tmpfile tmpcpy user]} ssh
        {:keys [value session]} (f session)]
    (logging/info (format "Target %s cmd\n%s" server value))
    [(remote-sudo-cmd server ssh-session sftp-channel user tmpfile value {})
     session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn ssh-from-local
  "Transfer a file from the origin machine to the target via ssh."
  [session f]
  (let [{:keys [ssh] :as session} (ensure-ssh-connection session)
        {:keys [server ssh-session sftp-channel tmpfile tmpcpy user]} ssh
        {:keys [value session]} (f session)]
    (doseq [[file remote-name] value]
      (logging/info
       (format
        "Transferring file %s to node @ %s via %s" file remote-name tmpcpy))
      (ssh/sftp
       sftp-channel
       :put (-> file java.io.FileInputStream. java.io.BufferedInputStream.)
       tmpcpy)
      (remote-sudo-cmd
       server ssh-session sftp-channel user tmpfile
       (stevedore/script
        (chmod "0600" ~tmpcpy)
        (mv -f ~tmpcpy ~remote-name))
       {}))
    [value session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn ssh-to-local
  "Transfer a file from the origin machine to the target via ssh."
  [session f]
  (let [{:keys [ssh] :as session} (ensure-ssh-connection session)
        {:keys [server ssh-session sftp-channel tmpfile tmpcpy user]} ssh
        {:keys [value session]} (f session)]
    (doseq [[remote-file local-file] value]
      (logging/info
       (format
        "Transferring file %s from node to %s" remote-file local-file))
      (remote-sudo-cmd
       server ssh-session sftp-channel user tmpfile
       (stevedore/script
        (cp -f ~remote-file ~tmpcpy))
       {})
      (ssh/sftp sftp-channel
                :get tmpcpy
                (-> local-file java.io.FileOutputStream.
                    java.io.BufferedOutputStream.)))
    [value session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn echo-bash
  "Echo a bash action. Do not execute."
  [session f]
  [(:value (f session)) session])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn echo-clojure
  "Echo a clojure action (which returns nil)"
  [session f]
  (let [{:keys [value session]} (f session)]
    [ session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn echo-transfer
  "echo transfer of files"
  [session f]
  (let [{:keys [value session]} (f session)]
    (logging/info "Local transfer")
    (doseq [[from to] value]
      (logging/info (format "Copying %s to %s" from to)))
    [value session]))</pre></tr><tr><td class="docs"><p>executor middleware</p>
</td><td class="codes" /><pre class="brush: clojure">(defn execute-with-ssh
  "Execute cmds for the session. Also accepts an IP or hostname as address."
  [handler]
  (fn execute-with-ssh-fn [{:keys [target-node user] :as session}]
    (logging/info
     (format
      "execute-with-ssh on %s %s"
      (compute/group-name target-node)
      (pr-str (compute/node-address target-node))))
    (ssh/with-ssh-agent [(default-agent)]
      (try
        (->
         session
         (assoc :ssh {:port (compute/ssh-port target-node)
                      :server (compute/node-address target-node)
                      :user user})
         (assoc-in [:executor :script/bash :target] ssh-bash-on-target)
         (assoc-in [:executor :transfer/to-local :origin] ssh-to-local)
         (assoc-in [:executor :transfer/from-local :origin] ssh-from-local)
         handler
         close-ssh-connection)
        (catch Exception e
          (close-ssh-connection session)
          (throw e))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn execute-target-on-localhost
  "Execute cmds for target on the local machine"
  [handler]
  (fn execute-target-on-localhost-fn [{:keys [target-node user] :as session}]
    (->
     session
     (assoc-in [:executor :script/bash :target] bash-on-origin)
     (assoc-in [:executor :transfer/from-local :origin] transfer-on-origin)
     (assoc-in [:executor :transfer/to-local :origin] transfer-on-origin)
     handler)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn execute-echo
  "Execute cmds for target on the local machine"
  [handler]
  (fn execute-target-on-localhost-fn [{:keys [target-node user] :as session}]
    (->
     session
     (assoc-in [:executor :script/bash :target] echo-bash)
     (assoc-in [:executor :script/bash :origin] echo-bash)
     (assoc-in [:executor :fn/clojure :target] echo-clojure)
     (assoc-in [:executor :fn/clojure :origin] echo-clojure)
     (assoc-in [:executor :transfer/from-local :origin] echo-transfer)
     (assoc-in [:executor :transfer/to-local :origin] echo-transfer)
     handler)))</pre></tr><tr><td class="docs"><p>other middleware</p>
</td><td class="codes" /><pre class="brush: clojure">(defn ssh-user-credentials
  "Middleware to user the session :user credentials for SSH authentication."
  [handler]
  (fn [session]
    (let [user (:user session)]
      (logging/info
       (format "Admin user %s %s" (:username user) (:private-key-path user)))
      (possibly-add-identity
       (default-agent) (:private-key-path user) (:passphrase user)))
    (handler session)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.futures" name="pallet.futures"><h1 class="project-name">pallet.futures</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Keep track of operations started by pallet</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.futures
  (:require
   [clojure.stacktrace :as stacktrace]
   [clojure.contrib.logging :as logging])
  (:import
   java.util.concurrent.CancellationException
   java.util.concurrent.ExecutionException
   java.util.concurrent.Future))</pre></tr><tr><td class="docs"><p>Keep track of pending operations, so they can be cancelled.</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc 
    :private true}
  pending-futures (atom (list)))</pre></tr><tr><td class="docs"><p>Remove all completed futures</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- remove-done
  [futures]
  (remove #(.isDone ^Future %1) futures))</pre></tr><tr><td class="docs"><p>Add a sequence of futures to the list of pending operations. Returns
   its argument.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add
  [futures]
  (do
    (swap! pending-futures #(concat (remove-done %1) %2) futures)
    futures))</pre></tr><tr><td class="docs"><p>Cancel all pending parallel operations</p>
</td><td class="codes" /><pre class="brush: clojure">(defn cancel-all
  []
  (swap! pending-futures #(do (doseq [^Future f %] (.cancel f true)) '()))
  nil)</pre></tr><tr><td class="docs"><p>Deref a future with logging, returning nil if exception thrown.
   <code>operation-label</code> appears in each log message generated.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn deref-with-logging
  [f operation-label]
  (try
    @f
    (catch CancellationException e
      (logging/warn
       (format "%s cancelled : %s" operation-label (.getMessage e))))
    (catch InterruptedException e
      (logging/warn
       (format "%s interrupted" operation-label)))
    (catch ExecutionException e
      (let [cause (stacktrace/root-cause e)]
        (logging/error
         (format "%s exception: %s" operation-label
                 (.getMessage cause)) cause))
      (logging/debug
       (format "%s exception" operation-label) (.getCause e)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.heynote" name="pallet.heynote"><h1 class="project-name">pallet.heynote</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Heynote feedback client</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.heynote
  (:require
   [clojure.contrib.logging :as logging]
   [clojure.contrib.http.agent :as agent]
   [clojure.contrib.http.connection :as connection]
   [clojure.contrib.json :as json]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce heynote-project (atom nil))</pre></tr><tr><td class="docs"><p>Sets and returns the heynote project name</p>
</td><td class="codes" /><pre class="brush: clojure">(defn project
  [name]
  (reset! heynote-project name))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def heynote-url "http://orcloud-heynote.appspot.com/")</pre></tr><tr><td class="docs"><p>(def heynote-url "http://localhost:8080/")</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def user-prefs (atom nil))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def user-prefs-file
     (str (. System getProperty "user.home") "/.heynote"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- user-preferences
  [& options]
  (when-not @user-prefs
    (try
     (reset! user-prefs (read-string (slurp user-prefs-file)))
     (catch Exception e
       (reset! user-prefs {}))))
  (when (seq options)
    (swap! user-prefs merge (apply hash-map options))
    (spit user-prefs-file (with-out-str (pr @user-prefs))))
  @user-prefs)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- process-response
  [response]
  (when (nil? ((user-preferences) :id))
    (user-preferences :id (response :user-id))))</pre></tr><tr><td class="docs"><p>Read heynote response.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- read-response
  [http-agnt]
  (let [ response (json/read-json
                   (java.io.PushbackReader.
                    (java.io.InputStreamReader.
                     (agent/stream http-agnt))))]
    (process-response response)
    response))</pre></tr><tr><td class="docs"><p>Send the given message map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn send-msg
  [path method msg-map]
  (let [agent (agent/http-agent
               (str heynote-url path)
               :method method
               :body (json/json-str msg-map)
               :headers {"Content-type" "application/json"}
               :handler read-response)
        response (agent/result agent)]
    (println
     (if (agent/client-error? agent)
       "There was a problem with the feedback system."))
    response))</pre></tr><tr><td class="docs"><p>Return a map that can be used to send to heynote</p>
</td><td class="codes" /><pre class="brush: clojure">(defn message-map
  []
  (when-not @heynote-project
    (throw (java.lang.RuntimeException. "No heynote project configured")))
  {:project @heynote-project
   :user-id (:id (user-preferences))})</pre></tr><tr><td class="docs"><p>Send new feedback with the given message</p>
</td><td class="codes" /><pre class="brush: clojure">(defn new-item
  [& options]
  (let [response (send-msg
                  "item/new" "POST"
                  (merge (message-map) (apply hash-map options)))]
    (println (response :item))))</pre></tr><tr><td class="docs"><p>Recieve feedback items</p>
</td><td class="codes" /><pre class="brush: clojure">(defn items
  [& options]
  (let [response (send-msg
                  "items" "GET"
                  (merge (message-map) (apply hash-map options)))
        items (response :items [])]
    (doseq [item items]
      (println item))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn as-number-if-possible [x]
  (if (string? x)
    (try
      (Long/parseLong x)
      (catch NumberFormatException e
        x))
    x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn as-string
  [x]
  (cond
   (keyword? x) (name x)
   (symbol? x) (name x)
   :else (str x)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn item-id-from-string
  [item]
  (as-number-if-possible
   (.substring (as-string item) 1)))</pre></tr><tr><td class="docs"><p>Recieve feedback item</p>
</td><td class="codes" /><pre class="brush: clojure">(defn item
  [item & options]
  (let [response (send-msg
                  "item" "GET"
                  (-> (message-map)
                      (merge (apply hash-map options))
                      (assoc :item-id (item-id-from-string item))))
        item (response :item)
        comments (response :comments [])]
    (println item)
    (doseq [comment comments]
      (println comment))))</pre></tr><tr><td class="docs"><p>Receive feedback items</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-comment
  [item & options]
  (let [response (send-msg
                  "comment" "POST"
                  (-> (message-map)
                      (merge (apply hash-map options))
                      (assoc :item-id (item-id-from-string item))))
        comment (response :item "There was a problem adding your comment.")]
    (println comment)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.logging" name="pallet.logging"><h1 class="project-name">pallet.logging</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Control pallet's logging</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.logging)</pre></tr><tr><td class="docs"><p>(def log-priorities
{:warn org.apache.log4j.Priority/WARN
:debug org.apache.log4j.Priority/DEBUG
:fatal org.apache.log4j.Priority/FATAL
:info org.apache.log4j.Priority/INFO
:error org.apache.log4j.Priority/ERROR})</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>(defn console-logging-threshold
"A fixture for no output from tests"
([] (console-logging-threshold :error))
([level]
(fn [f]
(let [console (.. (org.apache.log4j.Logger/getRootLogger)
(getAppender "console"))
threshold (.getThreshold console)]
(try
(.setThreshold
console (level log-priorities org.apache.log4j.Priority/WARN))
(f)
(finally
(.setThreshold console threshold)))))))</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>(defmacro with-console-logging-threshold
"A scope for no output from tests"
[level &amp; body]
`((console-logging-threshold ~level) (fn [] ~@body)))</p>
</td><td class="codes" /></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.main" name="pallet.main"><h1 class="project-name">pallet.main</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.main
  (:gen-class)
  (:require
   [pallet.command-line :as command-line]
   [clojure.contrib.logging :as logging]
   [clojure.stacktrace :as stacktrace]
   [clojure.walk :as walk]
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>An exception instance to use for terminating the task, without
          a stack trace</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc }
  exit-task-exception (Exception.))</pre></tr><tr><td class="docs"><p>Report a message to <em>err</em>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn report-error
  [msg]
  (binding [*out* *err*]
    (println msg)))</pre></tr><tr><td class="docs"><p>Abort a task, with the specified error message, and no stack trace.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn abort
  [msg]
  (report-error msg)
  (throw exit-task-exception))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn read-targets
  ([dir]
     (try
      (doseq [file (file-seq dir)]
        (load (.getPath file)))
      (catch java.io.FileNotFoundException _
        (abort "No pallet directory found in the current directory."))))
  ([] (read-targets "pallet")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def aliases {"--help" "help" "-h" "help" "-?" "help" "-v" "version"
              "--version" "version"})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn resolve-task [task]
  (let [task-ns (symbol (str "pallet.task." task))
        task (symbol task)
        error-fn (with-meta
                   (fn [& _]
                     (abort
                      (format
                       "%s is not a task. Use \"help\" to list all tasks."
                       task)))
                   {:no-service-required true})]
    (try
      (when-not (find-ns task-ns)
        (require task-ns))
      (or (ns-resolve task-ns task)
          error-fn)
      (catch java.io.FileNotFoundException e
        error-fn))))</pre></tr><tr><td class="docs"><p>Convert the given string into a namespace qualified symbol.
   Returns a vector of ns and symbol</p>
</td><td class="codes" /><pre class="brush: clojure">(defn parse-as-qualified-symbol
  [arg]
  {:pre [(string? arg)]}
  (if (.contains arg "/")
    (if-let [sym (symbol arg)]
      [(symbol (namespace sym)) sym])))</pre></tr><tr><td class="docs"><p>Function to build a symbol&rarr;value map, requiring namespaces as needed.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn map-and-resolve-symbols
  [symbol-map arg]
  (if-let [[ns sym] (parse-as-qualified-symbol arg)]
    (do
      (try
        (require ns)
        (catch java.io.FileNotFoundException e
          (abort
           (format "Could not locate node definition for %s" arg))))
      (if-let [v (find-var sym)]
        (assoc symbol-map sym (var-get v))
        symbol-map))
    symbol-map))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn profiles
  [profiles-string]
  (when profiles-string
    (string/split profiles-string #",")))</pre></tr><tr><td class="docs"><p>Check the exception to see if it is the <code>exit-task-exception</code>, and if it is
   not, then report the exception.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- report-unexpected-exception
  [^Throwable e]
  (when-not (= e exit-task-exception)
    (logging/error "Exception" e)
    (report-error (.getMessage e))
    (binding [*out* *err*]
      (stacktrace/print-stack-trace
       (stacktrace/root-cause e)))))</pre></tr><tr><td class="docs"><p>A pallet task.</p>

<p>   Returns an integer exit status suitable for System/exit.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pallet-task
  [args]
  (command-line/with-command-line args
    "Pallet command line"
    [[provider "Cloud provider name."]
     [identity "Cloud user name or key."]
     [credential "Cloud password or secret."]
     [blobstore-provider "Blobstore provider name."]
     [blobstore-identity "Blobstore user name or key."]
     [blobstore-credential "Blobstore password or secret."]
     [P "Profiles to use for key lookup in config.clj or settings.xml"]
     [project-options "Project options (usually picked up from project.clj)."]
     [defaults "Default options (usually picked up from config.clj)."]
     args]
    (try
      (let [[task & args] args
            task (or (aliases task) task "help")
            project-options (when project-options
                              (read-string project-options))
            defaults (when defaults
                       (read-string defaults))
            symbol-map (reduce map-and-resolve-symbols {} args)
            arg-line (str "[ " (apply str (interpose " " args)) " ]")
            params (read-string arg-line)
            params (clojure.walk/prewalk-replace symbol-map params)
            task (resolve-task task)
            return-value (if (:no-service-required (meta task))
                           (apply task params)
                           (let [_ (require 'pallet.main-invoker)
                                 invoker (find-var
                                          'pallet.main-invoker/invoke)]
                             (invoker
                              {:provider provider
                               :identity identity
                               :credential credential
                               :blobstore-provider blobstore-provider
                               :blobstore-identity blobstore-identity
                               :blobstore-credential blobstore-credential
                               :profiles (profiles P)
                               :project project-options
                               :defaults defaults}
                              task
                              params)))]
        (flush)
        (if (integer? return-value) return-value 0))
      (catch Exception e
        (report-unexpected-exception e)
        1))))</pre></tr><tr><td class="docs"><p>Command line runner.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn -main
  ([& args]
     (let [return-value (pallet-task args)]
       (shutdown-agents)
       (System/exit return-value)))
  ([] (apply -main *command-line-args*)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.main-invoker" name="pallet.main-invoker"><h1 class="project-name">pallet.main-invoker</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Invoke tasks requiring a compute service.  This decouples main from anything
   pallet, jclouds or maven specific, and ensures compiling main doesn't compile
   the world.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.main-invoker
  (:require
   [clojure.contrib.logging :as logging]
   [pallet.compute :as compute]
   [pallet.configure :as configure]
   [pallet.blobstore :as blobstore]
   [pallet.utils :as utils]
   [pallet.main :as main]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn log-info
  [admin-user]
  (logging/debug (format "OS              %s %s"
                         (System/getProperty "os.name")
                         (System/getProperty "os.version")))
  (logging/debug (format "Arch            %s" (System/getProperty "os.arch")))
  (logging/debug (format "Admin user      %s" (:username admin-user)))
  (let [private-key-path (:private-key-path admin-user)
        public-key-path (:public-key-path admin-user)]
    (logging/debug
     (format "private-key-path %s %s" private-key-path
             (.canRead (java.io.File. private-key-path))))
    (logging/debug
     (format "public-key-path %s %s" public-key-path
             (.canRead (java.io.File. public-key-path))))))</pre></tr><tr><td class="docs"><p>Return the admin user</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-admin-user
  [defaults project profiles]
  (or
   (utils/admin-user-from-config (:pallet project))
   (utils/admin-user-from-config defaults)
   (utils/admin-user-from-config-var)
   utils/*admin-user*))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config-files
  [defaults project profiles]
  (or
   (compute/compute-service-from-config (:pallet project) profiles)
   (compute/compute-service-from-config defaults profiles)
   (apply compute/compute-service-from-settings profiles)))</pre></tr><tr><td class="docs"><p>Look for a compute service in the following sequence:
     Check pallet.config.service property,
     check maven settings,
     check pallet.config/service var.
   This sequence allows you to specify an overridable default in
   pallet.config/service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-compute-service
  [options defaults project profiles]
  (or
   (compute/compute-service-from-map options)
   (when (seq profiles)
     (compute-service-from-config-files defaults project profiles))
   (compute/compute-service-from-property)
   (compute/compute-service-from-config-var)
   (compute-service-from-config-files defaults project profiles)))</pre></tr><tr><td class="docs"><p>Look for a compute service in the following sequence:
     Check pallet.config.service property,
     check maven settings,
     check pallet.config/service var.
   This sequence allows you to specify an overridable default in
   pallet.config/service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-blobstore
  [options defaults project profiles]
  (or
   (blobstore/blobstore-from-map options)
   (blobstore/blobstore-from-config (:pallet project) profiles)
   (blobstore/blobstore-from-config defaults profiles)
   (apply blobstore/blobstore-from-settings profiles)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn invoke
  [options task params]
  (let [default-config (or (:defaults options) (configure/pallet-config))
        admin-user (find-admin-user
                    default-config (:project options) (:profiles options))
        compute (try
                  (find-compute-service
                   options default-config
                   (:project options) (:profiles options))
                  (catch IllegalArgumentException e
                    (let [msg (.getMessage e)]
                      (if (and
                           msg
                           (re-find #"provider .* not configured" msg))
                        (binding [*out* *err*]
                          (println msg)
                          (throw pallet.main/exit-task-exception))
                        (throw e)))))]
    (if compute
      (try
        (let [blobstore (find-blobstore
                         options default-config
                         (:project options) (:profiles options))]
          (try
            (log-info admin-user)
            (apply task {:compute compute
                         :blobstore blobstore
                         :project (:project options)
                         :config default-config
                         :user admin-user} params)
            (finally ;; make sure we don't hang on exceptions
             (when blobstore
               (blobstore/close blobstore)))))
        (finally ;; make sure we don't hang on exceptions
         (compute/close compute)))
      (do
        (println "Error: no credentials supplied\n\n")
        ((main/resolve-task "help"))
        1))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.maven" name="pallet.maven"><h1 class="project-name">pallet.maven</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Maven interaction</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.maven
  (:import
   [org.apache.maven.settings Settings MavenSettingsBuilder]
   [org.codehaus.plexus.embed Embedder]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def key-map
  {:pallet.compute.provider :provider
   :pallet.compute.identity :identity
   :pallet.compute.credential :credential
   :pallet.compute.extensions :extensions
   :pallet.blobstore.provider :blobstore-provider
   :pallet.blobstore.identity :blobstore-identity
   :pallet.blobstore.credential :blobstore-credential
   :pallet.blobstore.extensions :blobstore-extensions
   :pallet.endpoint :endpoint
   :jclouds.compute.provider :provider
   :jclouds.compute.identity :identity
   :jclouds.compute.credential :credential
   :jclouds.compute.extensions :extensions
   :jclouds.blobstore.provider :blobstore-provider
   :jclouds.blobstore.identity :blobstore-identity
   :jclouds.blobstore.credential :blobstore-credential
   :jclouds.endpoint :endpoint})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def container (.getContainer (doto (Embedder.) (.start))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- make-settings []
  (.buildSettings (.lookup container MavenSettingsBuilder/ROLE)))</pre></tr><tr><td class="docs"><p>Read maven's settings.xml file, and extract properties from active profiles
   as a map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn properties
  [profiles]
  (let [settings (make-settings)
        properties (apply
                    merge
                    (map #(into {} (.getProperties (val %)))
                         (select-keys
                          (into {} (.getProfilesAsMap settings))
                          (if (seq profiles)
                            profiles
                            (.getActiveProfiles settings)))))]
    (zipmap (map keyword (keys properties)) (vals properties))))</pre></tr><tr><td class="docs"><p>Read maven's settings.xml file, and extract credentials.  </p>
</td><td class="codes" /><pre class="brush: clojure">(defn credentials
  [profiles]
  (into {}
        (filter identity
                (map
                 #(if-let [k (key-map (key %))] [k (val %)])
                 (properties profiles)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.md5crypt" name="pallet.md5crypt"><h1 class="project-name">pallet.md5crypt</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.md5crypt
  (:import [java.security NoSuchAlgorithmException MessageDigest]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce salt-chars
  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce itoa64
  "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce md5-magic "$1$")
(defonce apache-magic "$apr1$")</pre></tr><tr><td class="docs"><p>Return value encoded as n base64 chars</p>
</td><td class="codes" /><pre class="brush: clojure">(defn to64
  [#^Integer value #^Integer n]
  (if (pos? n)
    (str (.charAt itoa64 (int (bit-and value 0x3f)))
         (to64 (bit-shift-right value 6) (dec n)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn salt
  []
  (apply str (take 8 (repeatedly #(rand-nth itoa64)))))</pre></tr><tr><td class="docs"><p>Clean up a passed salt value</p>
</td><td class="codes" /><pre class="brush: clojure">(defn #^String clean-salt
  [#^String salt #^String magic]
  (let [salt (if (.startsWith salt magic)
                (.substring salt (.length magic))
                salt)
        salt (if (.contains salt "$")
               (.substring salt 0 (.indexOf salt "$"))
               salt)
        salt (if (> (.length salt) 8)
               (.substring salt 0 8)
               salt)]
    salt))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn set-array [#^bytes array #^Byte value]
  (dotimes [i (alength array)]
    (aset array i value))
  array)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn #^Integer byte-as-unsigned
  [b]
  (int (bit-and (int (byte b)) 0xff)))</pre></tr><tr><td class="docs"><p>LINUX/BSD MD5Crypt function</p>
</td><td class="codes" /><pre class="brush: clojure">(defn crypt
  ([password]
     (crypt password (salt) md5-magic))
  ([password salt]
     (crypt password salt md5-magic))
  ([#^String password #^String salt #^String magic]
     (let [salt (clean-salt salt magic)
           ctx (doto (MessageDigest/getInstance "md5")
                 (.update (.getBytes password))
                 (.update (.getBytes magic))
                 (.update (.getBytes salt)))
           ctx1 (doto (MessageDigest/getInstance "md5")
                  (.update (.getBytes password))
                  (.update (.getBytes salt))
                  (.update (.getBytes password)))
           final-state (.digest ctx1)]
       (loop [l (.length password)]
         (.update ctx final-state 0 (min l 16))
         (if (> l 16)
           (recur (int (- l 16)))))
       (set-array final-state (byte 0))
       (loop [i (.length password)]
         (when (pos? i)
           (if (pos? (bit-and i 1))
             (.update ctx final-state 0 1)
             (.update ctx (.getBytes password) 0 1))
           (recur (bit-shift-right i 1))))
       (let [#^bytes final-state (loop [final-state (.digest ctx)
                                i 0]
                           (if (< i 1000)
                             (let [ctx1 (MessageDigest/getInstance "md5")]
                               (if (pos? (bit-and i 1))
                                 (.update ctx1 (.getBytes password))
                                 (.update ctx1 final-state 0 16))
                               (if (pos? (mod i 3))
                                 (.update ctx1 (.getBytes salt)))
                               (if (pos? (mod i 7))
                                 (.update ctx1 (.getBytes password)))
                               (if (pos? (bit-and i 1))
                                 (.update ctx1 final-state 0 16)
                                 (.update ctx1 (.getBytes password)))
                               (recur (.digest ctx1) (inc i)))
                             final-state))]
         (str
          magic
          salt
          "$"
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 0)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 6)) 8))
                 (byte-as-unsigned (aget final-state 12)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 1)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 7)) 8))
                 (byte-as-unsigned (aget final-state 13)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 2)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 8)) 8))
                 (byte-as-unsigned (aget final-state 14)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 3)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 9)) 8))
                 (byte-as-unsigned (aget final-state 15)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 4)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 10)) 8))
                 (byte-as-unsigned (aget final-state 5)))
                4)
          (to64 (byte-as-unsigned (aget final-state 11)) 2))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.parameter" name="pallet.parameter"><h1 class="project-name">pallet.parameter</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides functions for working with parameters.</p>

<p>   Parameters are data maps that allow propogation of information between the
   functions of a crate, and between crates. There are two conventions for using
   parameters in crates that are directly supported here.</p>

<p>   Host specific parameters are specified under
       [:parameters :host (keyword target-id)]
   These functions are <code>get-for-target</code>, <code>assoc-for-target</code>, and
   <code>update-for-target</code>.</p>

<p>   Service specific paramters, used across hosts, are specified under
      [:parameters :service (keyword service-name)]
   These functions are <code>get-for-service</code>, <code>assoc-for-service</code>, and
   <code>update-for-service</code>.</p>

<p>   The <code>get-for</code> functions have slightly different semantics compared with
   clojure.core/get, in that they throw an exception if the key is undefined
   and no default value is specified.</p>

<p>   Delayed evaluation of parameters specified as arguments to action functions
   are also implemented here. <code>lookup</code> and <code>lookup-for-target</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.parameter
  (:require
   [pallet.action :as action]
   [pallet.argument :as argument]
   [pallet.compute :as compute]
   [clojure.contrib.condition :as condition]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn from-map
  "Initialise parameters based on the given keys, which are used to merge maps
   from m."
  [m keys]
  (reduce merge {} (map m keys)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-for
  "Retrieve the parameter at the path specified by keys.
   When no default value is specified, then raise a :parameter-not-found if no
   parameter is set.
       (get-for {:p {:a {:b 1} {:d 2}}} [:p :a :d])
         => 2"
  ([session keys]
     {:pre [(map? session)]}
     (let [result (get-in (:parameters session) keys ::not-set)]
       (when (= ::not-set result)
         (let [found-keys (take-while
                           #(not=
                             (get-in (:parameters session) % ::not-set)
                             ::not-set)
                           (rest (reductions conj [] keys)))]
           (condition/raise
            :type :parameter-not-found
            :message (format
                      (str
                       "Could not find keys %s in session :parameters. "
                       "Found keys %s with values %s")
                      (if (sequential? keys) (vec keys) keys)
                      (vec found-keys)
                      (if (seq found-keys)
                        (get-in (:parameters session) (vec found-keys))
                        (:parameters session)))
            :key-not-set keys)))
       result))
  ([session keys default]
       (get-in (:parameters session) keys default)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-for-target
  "Retrieve the host parameter for the current target at the path specified by
   keys.  When no default value is specified, then raise a :parameter-not-found
   if no parameter is set.
       (get-for-target
         {:parameters {:host {:id1 {:a {:b 1} {:d 2}}}}
          :target-id :id1} [:a :b])
         => 1"
  ([session keys]
     (get-for session (concat [:host (-> session :server :node-id)] keys)))
  ([session keys default]
     (get-for
      session (concat [:host (-> session :server :node-id)] keys) default)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-for-service
  "Retrieve the service parameter for the service and path specified by
   keys.  When no default value is specified, then raise a :parameter-not-found
   if no parameter is set.
       (get-for-service
         {:parameters {:service {:proxy {:a {:b 1} {:d 2}}}}} [:proxy :a :b])
         => 1"
  ([session keys]
     (get-for session (concat [:service] keys)))
  ([session keys default]
     (get-for session (concat [:service] keys) default)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-node-settings
  "Retrieve the settings for the specified node facility. The instance-id allows
   the specification of specific instance of the facility. If passed a nil
   `instance-id`, then `:default` is used"
  [session node facility instance-id]
  (get-for
   session
   [:host (keyword (compute/id node)) facility (or instance-id :default)]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-target-settings
  "Retrieve the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility. If passed a nil
   `instance-id`, then `:default` is used"
  [session facility instance-id]
  (get-for
   session
   [:host (-> session :server :node-id) facility (or instance-id :default)]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- assoc-for-prefix
  "Set the values in a map at the paths specified with prefix prepended to each
   path.
       (assoc-for-prefix {} :prefix [:a :b] 1 [:a :d] 2)
         => {:prefix {:a {:b 1} {:d 2}}}"
  [session prefix {:as keys-value-pairs}]
  (reduce
   #(assoc-in %1 (concat prefix (first %2)) (second %2))
   session
   keys-value-pairs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-for
  "Set the :parameters values at the paths specified.
       (assoc-for {} [:a :b] 1 [:a :d] 2)
         => {:parameters {:a {:b 1} {:d 2}}}"
  [session & {:as keys-value-pairs}]
  (assoc-for-prefix session [:parameters] keys-value-pairs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-for-target
  "Set the host parameter values at the paths specified.
       (assoc-for-target {:target-id :id1} [:a :b] 1 [:a :d] 2)
         => {:parameters {:host {:id1 {:a {:b 1} {:d 2}}}}}"
  [session & {:as keys-value-pairs}]
  (assoc-for-prefix
   session [:parameters :host (-> session :server :node-id)] keys-value-pairs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-for-service
  "Set the service parameter values at the paths specified.
       (assoc-for-service {} :proxy [:a :b] 1 [:a :d] 2)
         => {:parameters {:srvice {:proxy {:a {:b 1} {:d 2}}}}}"
  [session service & {:as keys-value-pairs}]
  (assoc-for-prefix
   session [:parameters :service service] keys-value-pairs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-target-settings
  "Set the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default)."
  [session facility instance-id values]
  (assoc-for
   session
   [:host (-> session :server :node-id) facility (or instance-id :default)]
   values))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- update-for-prefix
  "Update a map at the path given by the prefix and keys.
   The value is set to the value return by calling f with the current
   value and the given args.
       (update-for-prefix {:p {:a {:b 1}}} [:p] [:a :b] + 2)
         => {:p {:a {:b 3}}}"
  ([session prefix keys f args]
  (apply update-in session (concat prefix keys) f args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn update-for
  "Update parameters at the path given by keys.
   The value is set to the value return by calling f with the current
   value and the given args.
       (update-for {:parameters {:a {:b 1}}} [:a :b] + 2)
         => {:parameters {:a {:b 3}}}"
  [session keys f & args]
  (update-for-prefix session [:parameters] keys f args))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn update-for-target
  "Update host parameters for the current target at the path given by keys.
   The value is set to the value return by calling f with the current
   value and the given args.
       (update-for-target
          {:parameters {:host {:id1 {:a {:b 1}}}}
           :target-id :id1}
          [:a :b] + 2)
         => {:parameters {:host {:id1 {:a {:b 3}}}}}"
  [session keys f & args]
  (update-for-prefix
   session [:parameters :host (-> session :server :node-id)] keys f args))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn update-for-service
  "Update serivce parameters for the pecified service at the path given by keys.
   The value is set to the value return by calling f with the current
   value and the given args.
       (update-for-service
          {:parameters {:service {:proxy {:a {:b 1}}}}}
          [:proxy :a :b] + 2)
         => {:parameters {:service {:proxy {:a {:b 3}}}}}"
  [session keys f & args]
  (update-for-prefix session [:parameters :service] keys f args))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn update-target-settings
  "Update the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default)."
  [session facility instance-id f & args]
  (apply
   update-for
   session
   [:host (-> session :server :node-id) facility (or instance-id :default)]
   f args))</pre></tr><tr><td class="docs"><p>Delayed parameter evaluation</p>
</td><td class="codes" /><pre class="brush: clojure">(deftype ParameterLookup
  [keys]
  pallet.argument.DelayedArgument
  (evaluate
   [_ session]
   (get-for session keys)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype ParameterLookupTarget
  [keys]
  pallet.argument.DelayedArgument
  (evaluate
   [_ session]
   (get-for session (concat [:host (-> session :server :node-id)] keys))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lookup
  "Lookup a parameter in a delayed manner. Use a call to this function as the
   argument of a action.
   This function produces an object, which causes parameter lookup when it's
   toString method is called.
   See also `pallet.argument`."
  [& keys]
  (ParameterLookup. keys))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lookup-for-target
  "Lookup a parameter for the target in a delayed manner. Use a call to this
   function as the argument of a action.  This function produces an object,
   which causes parameter lookup when it's toString method is called.
   See also `pallet.argument`."
  [& keys]
  (ParameterLookupTarget. keys))</pre></tr><tr><td class="docs"><p>Actions</p>
</td><td class="codes" /><pre class="brush: clojure">(action/def-clj-action parameters
  "An action to set parameters"
  [session & {:as keyvector-value-pairs}]
  (assoc session
    :parameters (reduce
                 #(apply assoc-in %1 %2)
                 (:parameters session)
                 keyvector-value-pairs)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.phase" name="pallet.phase"><h1 class="project-name">pallet.phase</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A phase is a function of a single <code>session</code> argument, that contains
   calls to crate functions or actions. A phase has an implicitly
   defined pre and post phase.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.phase
  (:require
   [clojure.contrib.condition :as condition]))</pre></tr><tr><td class="docs"><p>Return the name for the pre-phase for the given <code>phase</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pre-phase-name
  [phase]
  (keyword "pallet.phase" (str "pre-" (name phase))))</pre></tr><tr><td class="docs"><p>Return the name for the post-phase for the given <code>phase</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn post-phase-name
  [phase]
  (keyword "pallet.phase" (str "post-" (name phase))))</pre></tr><tr><td class="docs"><p>Return a sequence including the implicit pre and post phases for a phase.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn all-phases-for-phase
  [phase]
  [(pre-phase-name phase) phase (post-phase-name phase)])</pre></tr><tr><td class="docs"><p>Specify that the body should be executed in the pre-phase.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro schedule-in-pre-phase
  [session & body]
  `(let [session# ~session
         phase# (:phase session#)]
     (->
      (assoc session# :phase (pre-phase-name phase#))
      ~@body
      (assoc :phase phase#))))</pre></tr><tr><td class="docs"><p>Specify that the body should be executed in the post-phase.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro schedule-in-post-phase
  [session & body]
  `(let [session# ~session
         phase# (:phase session#)]
     (->
      (assoc session# :phase (post-phase-name phase#))
      ~@body
      (assoc :phase phase#))))</pre></tr><tr><td class="docs"><p>Function that can check a session map to ensure it is a valid part of
   phase definiton. It returns the session map.</p>

<p>   If this fails, then it is likely that you have an incorrect crate function,
   which is failing to return its session map properly, or you have a non crate
   function in the phase defintion.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn check-session
  ([session]
     ;; we do not use a precondition in order to improve the error message
     (when-not (and session (map? session))
       (condition/raise
        :type :invalid-session
        :message
        "Invalid session map in phase. Check for non crate functions,
      improper crate functions, or problems in threading the session map
      in your phase definition.
      A crate function is a function that takes a session map and other
      arguments, and returns a modified session map. Calls to crate functions
      are often wrapped in a threading macro, -> or pallet.phase/phase-fn,
      to simplify chaining of the session map argument."))
     session)
  ([session form]
     ;; we do not use a precondition in order to improve the error message
     (when-not (and session (map? session))
       (condition/raise
        :type :invalid-session
        :message
        (format
         (str
          "Invalid session map in phase session.\n"
          "`session` is %s\n"
          "Problem probably caused in:\n  %s ")
         session form)))
     session))</pre></tr><tr><td class="docs"><p>Create a phase function from a sequence of crate invocations with
   an ommited session parameter.</p>

<p>   eg. (phase-fn
         (file "/some-file")
         (file "/other-file"))</p>

<p>   which generates a function with a session argument, that is thread
   through the function calls. The example is thus equivalent to:</p>

<p>   (fn [session] (&rarr; session
                   (file "/some-file")
                   (file "/other-file"))) </p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro phase-fn
  [& body]
  `(fn [session#]
     (->
      session#
      (check-session "The session passed to the pipeline")
      ~@(mapcat (fn [form] [form `(check-session '~form)]) body))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.repl" name="pallet.repl"><h1 class="project-name">pallet.repl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A namespace that can be used to pull in most of pallet's namespaces.  uesful
  when working at the clojure REPL.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.repl
  (:use
   [org.jclouds.compute
    :exclude [destroy-node nodes run-nodes destroy-nodes-with-tag
              destroy-nodes-in-group
              terminated? id running? tag hostname compute-service]]
   pallet.utils
   [pallet.compute :exclude [make-node]]
   pallet.core
   pallet.phase
   pallet.action.package
   pallet.task.feedback
   clj-ssh.ssh))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro use-pallet
  "Macro that will use pallet's namespaces, to provide an easy to access REPL."
  []
  '(do
     (clojure.core/use
      '[org.jclouds.compute
        :exclude [destroy-node nodes run-nodes destroy-nodes-with-tag
                  destroy-nodes-in-group
                  terminated? id running? tag hostname compute-service]]
      'pallet.utils
      '[pallet.compute :exclude [make-node]]
      'pallet.core
      'pallet.phase
      'pallet.action.package
      'pallet.task.feedback
      'clj-ssh.ssh)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.request-map" name="pallet.request-map"><h1 class="project-name">pallet.request-map</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatibility namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.request-map
  (:require
   [pallet.common.deprecate :as deprecate]
   [pallet.session :as session]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.session
 safe-id phase target-node target-name target-id target-ip os-family
 os-version safe-name packager admin-user group-name)</pre></tr><tr><td class="docs"><p>All nodes in the same tag as the target-node, or with the specified tag.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-in-tag
  {:deprecated "0.5.0"}
  ([session]
     (deprecate/deprecated
      (deprecate/rename
       'pallet.request-map/nodes-in-tag 'pallet.session/nodes-in-group))
     (session/nodes-in-group session))
  ([session group-name] (session/nodes-in-group session group-name)))</pre></tr><tr><td class="docs"><p>Tag of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tag
  {:deprecated "0.5.0"}
  [session]
  (deprecate/deprecated
   (deprecate/rename 'pallet.request-map/tag 'pallet.session/group-name))
  (session/group-name session))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.directory" name="pallet.resource.directory"><h1 class="project-name">pallet.resource.directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.directory
  (:require
   [pallet.action :as action]
   [pallet.action.directory :as directory]
   [pallet.common.deprecate :as deprecate]
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib rmdir mkdir make-temp-dir)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.action.directory
 adjust-directory
 make-directory
 directory
 directories)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def directory* (action/action-fn directory/directory))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.exec-script" name="pallet.resource.exec-script"><h1 class="project-name">pallet.resource.exec-script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.exec-script
  (:require
   [pallet.action.exec-script :as exec-script]
   [pallet.common.deprecate :as deprecate]
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro exec-script
  "Execute a bash script remotely"
  {:deprecated "0.5.0"}
  [session & script]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource.exec-script/exec-script
       'pallet.action.exec-script/exec-script))
     (exec-script/exec-script ~session ~@script)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro exec-checked-script
  "Execute a bash script remotely, throwing if any element of the
   script fails."
  {:deprecated "0.5.0"}
  [session name & script]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource.exec-script/exec-checked-script
       'pallet.action.exec-script/exec-checked-script))
     (exec-script/exec-checked-script ~session ~name ~@script)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.file" name="pallet.resource.file"><h1 class="project-name">pallet.resource.file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.file
  (:require
   pallet.action.file
   [pallet.common.deprecate :as deprecate]
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 rm mv cp ln backup-option basename ls cat tail diff cut chown chgrp chmod
 touch md5sum md5sum-verify sed-file download-file tmp-dir make-temp-file
 heredoc-in heredoc)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.action.file
 adjust-file write-md5-for-file touch-file
 file symbolic-link fifo sed)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.filesystem" name="pallet.resource.filesystem"><h1 class="project-name">pallet.resource.filesystem</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.filesystem
  (:require
   pallet.action.filesystem
   [pallet.common.deprecate :as deprecate]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.action.filesystem
 make-xfs-filesytem format-mount-option mount)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.filesystem-layout" name="pallet.resource.filesystem-layout"><h1 class="project-name">pallet.resource.filesystem-layout</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatibility namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.filesystem-layout
  (:require
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 etc-default
 log-root
 pid-root
 config-root
 etc-hosts
 etc-init
 pkg-etc-default
 etc-default
 pkg-log-root
 pkg-pid-root
 pkg-config-root
 pkg-sbin)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.format" name="pallet.resource.format"><h1 class="project-name">pallet.resource.format</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.format
  (:require
   pallet.config-file.format
   [pallet.common.deprecate :as deprecate]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.config-file.format sectioned-properties name-values)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.hostinfo" name="pallet.resource.hostinfo"><h1 class="project-name">pallet.resource.hostinfo</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatibility namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.hostinfo
  (:require
   pallet.script.lib
   [pallet.common.deprecate :as deprecate]
   [pallet.stevedore :as stevedore]
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 os-version-name
 hostname
 dnsdomainname
 nameservers
 debian-version
 redhat-version
 ubuntu-version
 arch)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn architecture
  "Machine CPU architecture."
  {:deprecated "0.5.0"}
  []
  (deprecate/deprecated "pallet.resource.hostinfo/architecture is deprecated")
  (stevedore/script (~arch)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.lib" name="pallet.resource.lib"><h1 class="project-name">pallet.resource.lib</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatibility namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.lib
  (:require
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 file-changed
 set-flag
 flag?)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.network-service" name="pallet.resource.network-service"><h1 class="project-name">pallet.resource.network-service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.network-service
  (:require
   [pallet.common.deprecate :as deprecate]
   pallet.crate.network-service
   pallet.script.lib))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.crate.network-service
 wait-for-port-listen wait-for-http-status
 wait-for-port-response)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.package" name="pallet.resource.package"><h1 class="project-name">pallet.resource.package</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.package
  (:require
   pallet.action.package
   pallet.action.package.centos
   pallet.action.package.debian-backports
   pallet.action.package.epel
   pallet.action.package.jpackage
   pallet.action.package.rpmforge
   [pallet.common.deprecate :as deprecate]
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 update-package-list upgrade-all-packages install-package upgrade-package
 remove-package purge-package list-installed-packages debconf-set-selections
 package-manager-non-interactive)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.action.package
 package packages package-source package-manager add-scope
 minimal-packages format-source)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns pallet.action.package.jpackage add-jpackage)
(deprecate/forward-fns pallet.action.package.epel add-epel)
(deprecate/forward-fns pallet.action.package.rpmforge add-rpmforge)
(deprecate/forward-fns
 pallet.action.package.debian-backports add-debian-backports)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-centos55-to-amzn-linux
  {:deprecated "0.5.0"}
  [& args]
  (deprecate/deprecated
   (deprecate/rename
    'pallet.action.package/add-centos55-to-amzn-linux
    'pallet.action.package.centos/add-repository))
  (apply pallet.action.package.centos/add-repository args))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.remote-directory" name="pallet.resource.remote-directory"><h1 class="project-name">pallet.resource.remote-directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.remote-directory
  (:require
   pallet.action.remote-directory
   [pallet.common.deprecate :as deprecate]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns pallet.action.remote-directory remote-directory)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.remote-file" name="pallet.resource.remote-file"><h1 class="project-name">pallet.resource.remote-file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.remote-file
  (:require
   [pallet.action :as action]
   [pallet.action.remote-file :as remote-file]
   [pallet.common.deprecate :as deprecate]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.action.remote-file
 set-install-new-files set-force-overwrite with-remote-file transfer-file
 remote-file-action remote-file)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-vars
 pallet.action.remote-file
 content-options
 version-options
 ownership-options
 all-options)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def remote-file* (action/action-fn remote-file/remote-file-action))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.resource-when" name="pallet.resource.resource-when"><h1 class="project-name">pallet.resource.resource-when</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Conditional resource execution.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.resource-when
  (:require
   [pallet.action.conditional :as conditional]
   [pallet.common.deprecate :as deprecate]
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro resource-when
  {:deprecated "0.5.0"}
  [session condition & resources]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource.resource-when/resource-when
       'pallet.action.conditional/when))
     (conditional/when ~session ~condition ~@resources)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro resource-when-not
  {:deprecated "0.5.0"}
  [session condition & resources]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource.resource-when/resource-when-not
       'pallet.action.conditional/when-not))
     (conditional/when-not ~session ~condition ~@resources)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.rsync" name="pallet.resource.rsync"><h1 class="project-name">pallet.resource.rsync</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.rsync
  (:require
   pallet.action.rsync
   [pallet.common.deprecate :as deprecate]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns
 pallet.action.rsync
 rsync rsync-directory)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.service" name="pallet.resource.service"><h1 class="project-name">pallet.resource.service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.service
  (:require
   pallet.action.service
   [pallet.common.deprecate :as deprecate]
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib configure-service)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns pallet.action.service service init-script)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-restart
  [session service-name & body]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource.service/with-restart
       'pallet.action.service/with-restart))
     (pallet.action.service/with-restart ~session ~service-name ~@body)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.shell" name="pallet.resource.shell"><h1 class="project-name">pallet.resource.shell</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatibility namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.shell
  (:require
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 exit
 xargs
 which)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.user" name="pallet.resource.user"><h1 class="project-name">pallet.resource.user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatability namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.user
  (:require
   pallet.action.user
   [pallet.common.deprecate :as deprecate]
   pallet.script.lib
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(utils/forward-to-script-lib
 user-exists? modify-user create-user remove-user lock-user unlock-user
 user-home current-user group-exists? modify-group create-group remove-group)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deprecate/forward-fns pallet.action.user user group)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource" name="pallet.resource"><h1 class="project-name">pallet.resource</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Namespace for backward compatibility</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource
  (:require
   [pallet.action :as action]
   [pallet.common.deprecate :as deprecate]
   [pallet.phase :as phase]
   [clojure.contrib.def :as ccdef]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro phase [& body]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename 'pallet.resource/phase 'pallet.phase/phase-fn))
     (phase/phase-fn ~@body)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro execute-pre-phase
  [& body]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource/execute-pre-phase 'pallet.phase/schedule-in-pre-phase))
     (phase/schedule-in-pre-phase ~@body)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro execute-after-phase [& body]
  `(do
     (deprecate/deprecated-macro
      ~&form
      (deprecate/rename
       'pallet.resource/execute-after-phase
       'pallet.phase/schedule-in-post-phase))
     (phase/schedule-in-post-phase ~@body)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defresource [n & body]
  (let [[n args] (ccdef/name-with-attributes n body)
        n (vary-meta n dissoc :use-arglist :copy-arglist)
        [[n* arguments & forms]] args]
    `(do
       (deprecate/deprecated-macro
        ~&form
        (deprecate/rename
         'pallet.resource/defresource 'pallet.action/def-bash-action))
       (action/def-bash-action
         ~n [~@arguments] ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro deflocal [n & body]
  (let [[n args] (ccdef/name-with-attributes n body)
        n (vary-meta n dissoc :use-arglist :copy-arglist)
        [[n* arguments & forms]] args]
    `(do
       (deprecate/deprecated-macro
        ~&form
        (deprecate/rename
         'pallet.resource/deflocal 'pallet.action/def-clj-action))
       (action/def-clj-action
         ~n [~@arguments] ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defaggregate [n & body]
  (let [[n args] (ccdef/name-with-attributes n body)
        n (vary-meta n dissoc :use-arglist :copy-arglist)
        [[n* arguments & forms]] args]
    `(do
       (deprecate/deprecated-macro
        ~&form
        (deprecate/rename
         'pallet.resource/defaggregate 'pallet.action/def-aggregated-action))
       (action/def-aggregated-action
         ~n [~@arguments] ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defcollect [n & body]
  (let [[n args] (ccdef/name-with-attributes n body)
        n (vary-meta n dissoc :use-arglist :copy-arglist)
        [[n* arguments & forms]] args]
    `(do
       (deprecate/deprecated-macro
        ~&form
        (deprecate/rename
         'pallet.resource/defcollect 'pallet.action/def-collected-action))
       (action/def-collected-action
         ~n [~@arguments] ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(action/def-clj-action as-local-resource
  [session f & args]
  (apply f session args))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.script.lib" name="pallet.script.lib"><h1 class="project-name">pallet.script.lib</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Script library for abstracting target host script differences</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.script.lib
  (:require
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]
   [pallet.thread-expr :as thread-expr]
   [clojure.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript exit [value])
(script/defimpl exit :default [value]
  (exit ~value))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript xargs [script])
(script/defimpl xargs :default
  [script]
  (xargs ~script))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript which [arg])
(script/defimpl which :default
  [arg]
  (which ~arg))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript has-command?
  "Check whether the specified command is on the path"
  [arg])
(script/defimpl has-command? :default [arg] (hash ~arg "2>&-"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript canonical-path [path]
  "Return the canonical version of the specified path"
  [arg])
(script/defimpl canonical-path :default [arg] (readlink -f ~arg))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript rm [file & {:keys [recursive force]}])
(script/defimpl rm :default [file & {:keys [recursive force] :as options}]
  ("rm" ~(stevedore/map-to-arg-string options) ~file))
(script/defimpl rm [#{:darwin :os-x}] [file & {:keys [recursive force]}]
  ("rm" ~(stevedore/map-to-arg-string {:r recursive :f force}) ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript mv [source destination & {:keys [force backup]}])
(script/defimpl mv :default
  [source destination & {:keys [force backup]}]
  (mv
   ~(stevedore/map-to-arg-string
     {:f force :backup (when backup (name backup))}
     :assign true)
   ~source ~destination))
(script/defimpl mv [#{:darwin :os-x}]
  [source destination & {:keys [force backup]}]
  (mv
   ~(stevedore/map-to-arg-string
     {:f force}
     :assign true)
   ~source ~destination))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript cp [source destination & {:keys [force backup preserve]}])
(script/defimpl cp :default
  [source destination & {:keys [force backup preserve]}]
  (cp
   ~(stevedore/map-to-arg-string {:f force
                                  :backup (when backup (name backup))
                                  :p preserve})
   ~source ~destination))
(script/defimpl cp [#{:darwin :os-x}]
  [source destination & {:keys [force backup preserve]}]
  (cp
   ~(stevedore/map-to-arg-string {:f force :p preserve})
   ~source ~destination))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript ln [source destination & {:keys [force symbolic]}])
(script/defimpl ln :default
  [source destination & {:keys [force symbolic]}]
  (ln
   ~(stevedore/map-to-arg-string {:f force :s symbolic})
   ~source ~destination))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript backup-option [])
(script/defimpl backup-option :default []
  "--backup=numbered")
(script/defimpl backup-option [#{:darwin :os-x}] [])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript basename [path])
(script/defimpl basename :default
  [path]
  (basename ~path))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript ls [pattern & {:keys [sort-by-time sort-by-size reverse]}])
(script/defimpl ls :default
  [pattern & {:keys [sort-by-time sort-by-size reverse]}]
  (ls ~(stevedore/map-to-arg-string
          {:t sort-by-time
           :S sort-by-size
           :r reverse})
   ~pattern))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript cat [pattern])
(script/defimpl cat :default
  [pattern]
  (cat ~pattern))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript tail [pattern & {:keys [max-lines]}])
(script/defimpl tail :default
  [pattern & {:keys [max-lines]}]
  (tail ~(stevedore/map-to-arg-string {:n max-lines}) ~pattern))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript diff [file1 file2 & {:keys [unified]}])
(script/defimpl diff :default
  [file1 file2 & {:keys [unified]}]
  (diff ~(stevedore/map-to-arg-string {:u unified}) ~file1 ~file2))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript cut [file & {:keys [fields delimiter]}])
(script/defimpl cut :default
  [file & {:keys [fields delimiter]}]
  (cut
   ~(stevedore/map-to-arg-string {:f fields :d delimiter})
   ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript chown [owner file & {:as options}])
(script/defimpl chown :default [owner file & {:as options}]
  (chown ~(stevedore/map-to-arg-string options) ~owner ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript chgrp [group file & {:as options}])
(script/defimpl chgrp :default [group file & {:as options}]
  (chgrp ~(stevedore/map-to-arg-string options) ~group ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript chmod [mode file & {:as options}])
(script/defimpl chmod :default [mode file & {:as options}]
  (chmod ~(stevedore/map-to-arg-string options) ~mode ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript touch [file & {:as options}])
(script/defimpl touch :default [file & {:as options}]
  (touch ~(stevedore/map-to-arg-string options) ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript md5sum [file & {:as options}])
(script/defimpl md5sum :default [file & {:as options}]
  (md5sum ~(stevedore/map-to-arg-string options) ~file))
(script/defimpl md5sum [#{:darwin :os-x}] [file & {:as options}]
  ("/sbin/md5" -r ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript normalise-md5
  "Normalise an md5 sum file to contain the base filename"
  [file])
(script/defimpl normalise-md5 :default
  [file]
  (if (egrep "'^[a-fA-F0-9]+$'" ~file)
    (echo
     (quoted (str "  " @(pipe (basename ~file) (sed -e "s/.md5//"))))
     ">>" ~file)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript md5sum-verify [file & {:as options}])
(script/defimpl md5sum-verify :default
  [file & {:keys [quiet check] :or {quiet true check true} :as options}]
  ("(" (chain-and
        (cd @(dirname ~file))
        (md5sum
         ~(stevedore/map-to-arg-string {:quiet quiet :check check})
         @(basename ~file))) ")"))
(script/defimpl md5sum-verify [#{:centos :debian :amzn-linux :rhel :fedora}]
  [file & {:keys [quiet check] :or {quiet true check true} :as options}]
  ("(" (chain-and
        (cd @(dirname ~file))
        (md5sum
         ~(stevedore/map-to-arg-string {:status quiet :check check})
         @(basename ~file))) ")"))
(script/defimpl md5sum-verify [#{:darwin :os-x}] [file & {:as options}]
  (chain-and
   (var testfile @(~cut ~file :delimiter " " :fields 2))
   (var md5 @(~cut ~file :delimiter " " :fields 1))
   ("test" (quoted @("/sbin/md5" -q @testfile)) == (quoted @md5))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript backup-option [])
(script/defimpl backup-option :default []
  "--backup=numbered")
(script/defimpl backup-option [#{:darwin :os-x}] [])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript sed-file [file expr-map options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc "Possible sed separators" :private true}
  sed-separators
  (concat [\/ \_ \| \: \% \! \@] (map char (range 42 127))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl sed-file :default
  [file expr-map {:keys [seperator restriction quote-with]
                  :or {quote-with "\}
                  :as options}]
  (sed "-i"
   ~(if (map? expr-map)
      (string/join
       " "
       (map
        (fn [[key value]]
          (let [used (fn [c]
                       (or (>= (.indexOf key (int c)) 0)
                           (>= (.indexOf value (int c)) 0)))
                seperator (or seperator (first (remove used sed-separators)))]
            (format
             "-e %s%ss%s%s%s%s%s%s"
             quote-with
             (if restriction (str restriction " ") )
             seperator key seperator value seperator quote-with)))
        expr-map))
      (format
       "-e %s%s%s%s"
       quote-with
       (if restriction (str restriction " ") )
       expr-map quote-with))
   ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript download-file [url path & {:keys [proxy]}])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl download-file :default [url path & {:keys [proxy]}]
  (if (~has-command? curl)
    (curl "-o" (quoted ~path)
     --retry 5 --silent --show-error --fail --location
     ~(if proxy
        (let [url (java.net.URL. proxy)]
          (format "--proxy %s:%s" (.getHost url) (.getPort url))))
     (quoted ~url))
    (if (~has-command? wget)
      (wget "-O" (quoted ~path) --tries 5 --no-verbose
       ~(if proxy
          (format "-e \"http_proxy = %s\" -e \"ftp_proxy = %s\ proxy proxy))
       (quoted ~url))
      (do
        (println "No download utility available")
        (~exit 1)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript download-request [path request])
(script/defimpl download-request :default [path request]
  (curl "-o" (quoted ~path) --retry 3 --silent --show-error --fail --location
   ~(string/join
     " "
     (map (fn dlr-fmt [e] (format "-H \"%s: %s\ (key e) (val e)))
          (:headers request)))
   (quoted ~(:endpoint request))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript tmp-dir [])
(script/defimpl tmp-dir :default []
  @TMPDIR-/tmp)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript make-temp-file [pattern])
(script/defimpl make-temp-file :default [pattern]
  @(mktemp (quoted ~(str pattern "XXXXX"))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript heredoc-in [cmd content {:keys [literal]}])
(script/defimpl heredoc-in :default [cmd content {:keys [literal]}]
  ("{" ~cmd
   ~(str (if literal "<<'EOFpallet'\n" "<<EOFpallet\n")
         content "\nEOFpallet\n }")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript heredoc [path content {:keys [literal]}])
(script/defimpl heredoc :default
  [path content {:keys [literal] :as options}]
  (~heredoc-in ("cat" ">" ~path) ~content ~options))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript rmdir
  "Remove the specified directory"
  [directory & {:as options}])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl rmdir :default [directory & {:as options}]
  (rmdir ~(stevedore/map-to-arg-string options) ~directory))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript mkdir
  "Create the specified directory"
  [directory & {:keys [path verbose mode]}])
(script/defimpl mkdir :default
  [directory & {:keys [path verbose mode] :as options}]
  (mkdir
   ~(stevedore/map-to-arg-string {:m mode :p path :v verbose})
   ~directory))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript make-temp-dir
  "Create a temporary directory"
  [pattern & {:as options}])
(script/defimpl make-temp-dir :default [pattern & {:as options}]
  @(mktemp -d
    ~(stevedore/map-to-arg-string options)
    ~(str pattern "XXXXX")))</pre></tr><tr><td class="docs"><p>Host information.</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript os-version-name [])
(script/defimpl os-version-name [#{:ubuntu :debian}] []
  @(lsb_release -c -s))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl os-version-name :default [])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript hostname [& options])
(script/defimpl hostname :default [& options]
  @(hostname
    ~(if (first options)
       (stevedore/map-to-arg-string (apply hash-map options)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript dnsdomainname [])
(script/defimpl dnsdomainname :default []
  @(dnsdomainname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript nameservers [])
(script/defimpl nameservers :default []
  @(grep nameserver "/etc/resolv.conf" | cut "-f2"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript debian-version [])
(script/defimpl debian-version :default []
  (if (file-exists? "/etc/debian") (cat "/etc/debian")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript redhat-version [])
(script/defimpl redhat-version :default []
  (if (file-exists? "/etc/redhat-release") (cat "/etc/redhat-release")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript ubuntu-version [])
(script/defimpl ubuntu-version :default []
  (if (file-exists? "/usr/bin/lsb_release") @("/usr/bin/lsb_release" -c -s)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript arch [])
(script/defimpl arch :default []
  @(uname -p))</pre></tr><tr><td class="docs"><p>Users</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript user-exists? [name])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript modify-user [name options])
(script/defscript create-user [name options])
(script/defscript remove-user [name options])
(script/defscript lock-user [name])
(script/defscript unlock-user [name])
(script/defscript user-home [username])
(script/defscript current-user [])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript group-exists? [name])
(script/defscript modify-group [name options])
(script/defscript create-group [name options])
(script/defscript remove-group [name options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl user-exists? :default [username]
  (getent passwd ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl create-user :default [username options]
  ("/usr/sbin/useradd"
   ~(-> options
        (thread-expr/when->
         (:groups options)
         (update-in [:groups] (fn [groups]
                                (if (and (seq? groups) (not (string? groups)))
                                  (string/join "," groups)))))
        (thread-expr/when->
         (:group options)
         (assoc :g (:group options))
         (dissoc :group))
        stevedore/map-to-arg-string)
   ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl create-user [#{:rhel :centos :amzn-linux :fedora}]
  [username options]
  ("/usr/sbin/useradd"
   ~(-> options
        (assoc :r (:system options))
        (dissoc :system)
        (thread-expr/when->
         (:groups options)
         (update-in [:groups] (fn [groups]
                                (if (and (seq? groups) (not (string? groups)))
                                  (string/join "," groups)))))
        (thread-expr/when->
         (:group options)
         (assoc :g (:group options))
         (dissoc :group))
        stevedore/map-to-arg-string)
   ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl modify-user :default [username options]
  ("/usr/sbin/usermod" ~(stevedore/map-to-arg-string options) ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl modify-user [#{:rhel :centos :amzn-linux :fedora}]
  [username options]
  ("/usr/sbin/usermod"
   ~(-> options
        (assoc :r (:system options))
        (dissoc :system)
        (thread-expr/when->
         (:groups options)
         (update-in [:groups] (fn [groups]
                                (if (and (seq? groups) (not (string? groups)))
                                  (string/join "," groups)))))
        (thread-expr/when->
         (:group options)
         (assoc :g (:group options))
         (dissoc :group))
        stevedore/map-to-arg-string)
   ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-user :default [username options]
  ("/usr/sbin/userdel" ~(stevedore/map-to-arg-string options) ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl lock-user :default [username]
  ("/usr/sbin/usermod" --lock ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl unlock-user :default [username]
  ("/usr/sbin/usermod" --unlock ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl user-home :default [username]
  @("getent" passwd ~username | "cut" "-d:" "-f6"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl user-home [#{:darwin :os-x}] [username]
  @(pipe
    ("dscl" localhost -read ~(str "/Local/Default/Users/" username)
          "dsAttrTypeNative:home")
    ("cut" -d "' '" -f 2)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl current-user :default []
  @("whoami"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl group-exists? :default [name]
  ("getent" group ~name))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl create-group :default [groupname options]
  ("/usr/sbin/groupadd" ~(stevedore/map-to-arg-string options) ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl create-group [#{:rhel :centos :amzn-linux :fedora}]
  [groupname options]
  ("/usr/sbin/groupadd"
   ~(-> options
        (assoc :r (:system options))
        (dissoc :system)
        stevedore/map-to-arg-string)
   ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl modify-group :default [groupname options]
  ("/usr/sbin/groupmod" ~(stevedore/map-to-arg-string options) ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-group :default [groupname options]
  ("/usr/sbin/groupdel" ~(stevedore/map-to-arg-string options) ~groupname))</pre></tr><tr><td class="docs"><p>Package management</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>the package management commands vary for each distribution, so we
use a script multimethod to describe these</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defscript update-package-list
  "Update the list of packages available to the package manager from the
   declared package sources."
  [& options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript upgrade-all-packages
  "Upgrade the all installed package."
  [& options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript install-package
  "Install the specified package."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript upgrade-package
  "Upgrade the specified package."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript remove-package
  "Uninstall the specified package, leaving the configuration files if
   possible."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript purge-package
  "Uninstall the specified package, removing the configuration files if
   possible."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript list-installed-packages
  "List the installed packages"
  [& options])</pre></tr><tr><td class="docs"><p>Implementation to do nothing
Repeating the selector makes it more explicit</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl update-package-list [#{:no-packages} #{:no-packages}]
  [& options] )
(script/defimpl upgrade-all-packages [#{:no-packages} #{:no-packages}]
  [& options] )
(script/defimpl install-package [#{:no-packages} #{:no-packages}]
  [package & options] )
(script/defimpl upgrade-package [#{:no-packages} #{:no-packages}]
  [package & options] )
(script/defimpl remove-package [#{:no-packages} #{:no-packages}]
  [package & options] )
(script/defimpl purge-package [#{:no-packages} #{:no-packages}]
  [package & options] )
(script/defimpl list-installed-packages [#{:no-packages} #{:no-packages}]
  [& options] )</pre></tr><tr><td class="docs"><p>aptitude</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl update-package-list [#{:aptitude}] [& {:keys [] :as options}]
  (chain-or
   (aptitude update ~(stevedore/map-to-arg-string options)) true))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:aptitude}] [& options]
  (aptitude upgrade -q -y ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl install-package [#{:aptitude}] [package & options]
  (aptitude install -q -y ~(stevedore/option-args options) ~package
            ;; show returns an error code if no package found, while install
            ;; does not.  There should be a better way than this...
            "&&" aptitude show ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-package [#{:aptitude}] [package & options]
  (aptitude install -q -y ~(stevedore/option-args options) ~package
            ;; show returns an error code if no package found, while install
            ;; does not.  There should be a better way than this...
            "&&" aptitude show ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-package [#{:aptitude}] [package & options]
  (aptitude remove -y ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl purge-package [#{:aptitude}] [package & options]
  (aptitude purge -y  ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl list-installed-packages [#{:aptitude}] [& options]
  (aptitude search (quoted "~i")))</pre></tr><tr><td class="docs"><p>yum</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl update-package-list [#{:yum}] [& {:keys [enable disable]}]
  (yum makecache -q ~(string/join
                      " "
                      (concat
                       (map #(str "--disablerepo=" %) disable)
                       (map #(str "--enablerepo=" %) enable)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:yum}] [& options]
  (yum update -y -q ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl install-package [#{:yum}] [package & options]
  (yum install -y -q ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-package [#{:yum}] [package & options]
  (yum upgrade -y -q ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-package [#{:yum}] [package & options]
  (yum remove ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl purge-package [#{:yum}] [package & options]
  (yum purge ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl list-installed-packages [#{:yum}] [& options]
  (yum list installed))</pre></tr><tr><td class="docs"><p>zypper</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl update-package-list [#{:zypper}] [& options]
  (zypper refresh ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:zypper}] [& options]
  (zypper update -y ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl install-package [#{:zypper}] [package & options]
  (zypper install -y ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-package [#{:zypper}] [package & options]
  (zypper remove ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl purge-package [#{:zypper}] [package & options]
  (zypper remove ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs"><p>pacman</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl update-package-list [#{:pacman}] [& options]
  (pacman -Sy "--noconfirm" "--noprogressbar"
   ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:pacman}] [& options]
  (pacman -Su "--noconfirm" "--noprogressbar" ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl install-package [#{:pacman}] [package & options]
  (pacman -S "--noconfirm" "--noprogressbar"
   ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-package [#{:pacman}] [package & options]
  (pacman -S "--noconfirm" "--noprogressbar"
   ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-package [#{:pacman}] [package & options]
  (pacman -R "--noconfirm" ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl purge-package [#{:pacman}] [package & options]
  (pacman -R "--noconfirm" "--nosave"
   ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs"><p>brew</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl update-package-list [#{:brew}] [& options]
  (brew update ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:brew}] [& options]
  (comment "No command to do this"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl install-package [#{:brew}] [package & options]
  (brew install -y ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl remove-package [#{:brew}] [package & options]
  (brew uninstall ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl purge-package [#{:brew}] [package & options]
  (brew uninstall ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript debconf-set-selections [& selections])
(script/defimpl debconf-set-selections :default [& selections] )
(script/defimpl debconf-set-selections [#{:aptitude}] [& selections]
  ("{ debconf-set-selections"
   ~(str "<<EOF\n" (string/join \newline selections) "\nEOF\n}")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript package-manager-non-interactive [])
(script/defimpl package-manager-non-interactive :default [] )
(script/defimpl package-manager-non-interactive [#{:aptitude}] []
  (~debconf-set-selections
   "debconf debconf/frontend select noninteractive"
   "debconf debconf/frontend seen false"))</pre></tr><tr><td class="docs"><p>Service functions</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript configure-service
  [name action options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def debian-configure-option-names
     {:force :f})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn debian-options [options]
  (zipmap
   (map #(% debian-configure-option-names %) (keys options))
   (vals options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl configure-service :default [name action options]
  ~(condp = action
       :disable (stevedore/script
                 ("update-rc.d"
                  ~(stevedore/map-to-arg-string
                    (select-keys [:f :n] (debian-options options)))
                  ~name remove))
       :enable (stevedore/script
                ("update-rc.d"
                 ~(stevedore/map-to-arg-string
                   (select-keys [:n] (debian-options options)))
                 ~name defaults
                 ~(:sequence-start options 20)
                 ~(:sequence-stop options (:sequence-start options 20))))
       :start-stop (stevedore/script ;; start/stop
                    ("update-rc.d"
                     ~(stevedore/map-to-arg-string
                       (select-keys [:n] (debian-options options)))
                     ~name
                     start ~(:sequence-start options 20)
                     "."
                     stop ~(:sequence-stop options (:sequence-start options 20))
                     "."))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} chkconfig-default-options
  [20 2 3 4 5])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- chkconfig-levels
  [options]
  (->> options (drop 1 ) (map str) string/join))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl configure-service [#{:yum}] [name action options]
  ~(condp = action
       :disable (stevedore/script ("/sbin/chkconfig" ~name off))
       :enable (stevedore/script
                ("/sbin/chkconfig"
                 ~name on
                 "--level" ~(chkconfig-levels
                             (:sequence-start
                              options chkconfig-default-options))))
       :start-stop (stevedore/script ;; start/stop
                    ("/sbin/chkconfig"
                     ~name on
                     "--level" ~(chkconfig-levels
                                 (:sequence-start
                                  options chkconfig-default-options))))))</pre></tr><tr><td class="docs"><p>Functions to return distribution specific paths.</p>

<p>These script functions are meant to help build distribution agnostic crates.
* Links
- man 7 hier
- http://www.pathname.com/fhs/
- http://wiki.apache.org/httpd/DistrosDefaultLayout</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript etc-default [])
(script/defimpl etc-default [#{:ubuntu :debian :jeos}] []
  "/etc/default")
(script/defimpl etc-default [#{:centos :rhel :amzn-linux :fedora}] []
  "/etc/sysconfig")
(script/defimpl etc-default [#{:os-x :darwin}] []
  "/etc/defaults")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript log-root [])
(script/defimpl log-root :default []
  "/var/log")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pid-root [])
(script/defimpl pid-root :default []
  "/var/run")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript config-root [])
(script/defimpl config-root :default []
  "/etc")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript etc-hosts [])
(script/defimpl etc-hosts :default []
  "/etc/hosts")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript etc-init [])
(script/defimpl etc-init :default [] "/etc/init.d")
(script/defimpl etc-init [:pacman] [] "/etc/rc.d")</pre></tr><tr><td class="docs"><p>Some of the packagers, like brew, are "add-ons" in the sense that they are
outside of the base system.  These paths refer to locations of packager
installed files.</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-etc-default [])
(script/defimpl pkg-etc-default :default [] (~etc-default))
(script/defimpl etc-default [:brew] [] "/usr/local/etc/default")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-log-root [])
(script/defimpl pkg-log-root :default [] (~log-root))
(script/defimpl pkg-log-root [:brew] [] "/usr/local/var/log")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-pid-root [])
(script/defimpl pkg-pid-root :default [] (~pid-root))
(script/defimpl pkg-pid-root [:brew] [] "/usr/local/var/run")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-config-root [])
(script/defimpl pkg-config-root :default [] (~config-root))
(script/defimpl pkg-config-root [:brew] [] "/usr/local/etc")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-sbin [])
(script/defimpl pkg-sbin :default [] "/sbin")
(script/defimpl pkg-sbin [:brew] [] "/usr/local/sbin")</pre></tr><tr><td class="docs"><p>Register changed files</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript file-changed [path])
(script/defimpl file-changed :default [path]
  (assoc! changed_files path 1))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript set-flag [path])
(script/defimpl set-flag :default [path]
  (assoc! flags_hash ~(name path) 1))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript flag? [path])
(script/defimpl flag? :default [path]
  (get flags_hash ~(name path)))</pre></tr><tr><td class="docs"><p>selinux</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript selinux-file-type
  "Set the selinux file type"
  [path type])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defimpl selinux-file-type :default
  [path type]
  (if (~has-command? chcon)
    (chcon -Rv ~(str "--type=" type) ~path)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.session" name="pallet.session"><h1 class="project-name">pallet.session</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for querying sessions.</p>

<p>   This is the official crate API for extracting information from the session.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.session
  (:require
   [pallet.compute :as compute]
   [pallet.utils :as utils])
  (:use
   [clojure.contrib.core :only [-?>]]))</pre></tr><tr><td class="docs"><p>Computes a configuration and filesystem safe identifier corresponding to a
  potentially unsafe ID</p>
</td><td class="codes" /><pre class="brush: clojure">(defn safe-id
  [#^String unsafe-id]
  (utils/base64-md5 unsafe-id))</pre></tr><tr><td class="docs"><p>Current phase</p>
</td><td class="codes" /><pre class="brush: clojure">(defn phase
  [session]
  (:phase session))</pre></tr><tr><td class="docs"><p>Target compute service node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-node
  [session]
  (-> session :server :node))</pre></tr><tr><td class="docs"><p>Current phase</p>
</td><td class="codes" /><pre class="brush: clojure">(defn phase
  [session]
  (:phase session))</pre></tr><tr><td class="docs"><p>Name of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-name
  [session]
  (compute/hostname (target-node session)))</pre></tr><tr><td class="docs"><p>Id of the target-node (unique for provider).</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-id
  [session]
  (-> session :server :node-id))</pre></tr><tr><td class="docs"><p>IP of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-ip
  [session]
  (compute/primary-ip (target-node session)))</pre></tr><tr><td class="docs"><p>Roles of the target server.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-roles
  [session]
  (-> session :server :roles))</pre></tr><tr><td class="docs"><p>Base distribution of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn base-distribution
  [session]
  (compute/base-distribution (-> session :server :image)))</pre></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn os-family
  [session]
  (-> session :server :image :os-family))</pre></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn os-version
  [session]
  (-> session :server :image :os-version))</pre></tr><tr><td class="docs"><p>Group name of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn group-name
  [session]
  (-> session :server :group-name))</pre></tr><tr><td class="docs"><p>Safe name for target machine.
   Some providers don't allow for node names, only node ids, and there is
   no guarantee on the id format.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn safe-name
  [session]
  (format
   "%s%s"
   (name (group-name session)) (safe-id (name (target-id session)))))</pre></tr><tr><td class="docs"><p>All nodes in the same tag as the target-node, or with the specified tag.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-in-group
  ([session] (nodes-in-group session (group-name session)))
  ([session group-name]
     (filter
      #(= (name group-name) (compute/group-name %))
      (:all-nodes session))))</pre></tr><tr><td class="docs"><p>All target groups with the specified role.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn groups-with-role
  [session role]
  (->>
   (:node-set session)
   (filter #(when-let [roles (:roles %)] (roles role)))
   (map :group-name)))</pre></tr><tr><td class="docs"><p>All target nodes with the specified role.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-with-role
  [session role]
  (mapcat #(nodes-in-group session %) (groups-with-role session role)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn packager
  [session]
  (get-in session [:server :packager]))</pre></tr><tr><td class="docs"><p>User that remote commands are run under</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user
  [session]
  (:user session))</pre></tr><tr><td class="docs"><p>User that remote commands are run under</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-group
  [session]
  (compute/admin-group (:server session)))</pre></tr><tr><td class="docs"><p>Predicate for a 64 bit target</p>
</td><td class="codes" /><pre class="brush: clojure">(defn is-64bit?
  [session]
  (compute/is-64bit? (target-node session)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.shell" name="pallet.shell"><h1 class="project-name">pallet.shell</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A modified version of clojure.java.shell, that allows for reading of
shell output as it is produced.</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns
  ^{:author "Chris Houser, Stuart Halloway, Hugo Duncan",
    :doc }
  pallet.shell
  (:use [clojure.java.io :only (as-file copy)])
  (:import (java.io OutputStreamWriter ByteArrayOutputStream StringWriter)
           (java.nio.charset Charset)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def *sh-dir* nil)
(def *sh-env* nil)</pre></tr><tr><td class="docs"><p>Sets the directory for use with sh, see sh for details.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-sh-dir
  {:added "1.2"}
  [dir & forms]
  `(binding [*sh-dir* ~dir]
     ~@forms))</pre></tr><tr><td class="docs"><p>Sets the environment for use with sh, see sh for details.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-sh-env
  {:added "1.2"}
  [env & forms]
  `(binding [*sh-env* ~env]
     ~@forms))</pre></tr><tr><td class="docs"><p>Concatenates arrays of given type.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- aconcat
  [type & xs]
  (let [target (make-array type (apply + (map count xs)))]
    (loop [i 0 idx 0]
      (when-let [a (nth xs i nil)]
        (System/arraycopy a 0 target idx (count a))
        (recur (inc i) (+ idx (count a)))))
    target))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- parse-args
  [args]
  (let [default-encoding "UTF-8" ;; see sh doc string
        default-opts {:out-enc default-encoding
                      :in-enc default-encoding
                      :dir *sh-dir*
                      :env *sh-env*}
        [cmd opts] (split-with string? args)]
    [cmd (merge default-opts (apply hash-map opts))]))</pre></tr><tr><td class="docs"><p>Helper so that callers can pass a Clojure map for the :env to sh.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- ^"[Ljava.lang.String;" as-env-strings
  [arg]
  (cond
   (nil? arg) nil
   (map? arg) (into-array String (map (fn [[k v]] (str (name k) "=" v)) arg))
   true arg))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- stream-to-bytes
  [in]
  (with-open [bout (ByteArrayOutputStream.)]
    (copy in bout)
    (.toByteArray bout)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- stream-to-string
  ([in] (stream-to-string in (.name (Charset/defaultCharset))))
  ([in enc]
     (with-open [bout (StringWriter.)]
       (copy in bout :encoding enc)
       (.toString bout))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- stream-to-enc
  [stream enc]
  (if (= enc :bytes)
    (stream-to-bytes stream)
    (stream-to-string stream enc)))</pre></tr><tr><td class="docs"><p>Passes the given strings to Runtime.exec() to launch a sub-process.</p>

<p>  Options are</p>

<p>  :in      may be given followed by a String or byte array specifying input
           to be fed to the sub-process's stdin.
  :in-enc  option may be given followed by a String, used as a character
           encoding name (for example "UTF-8" or "ISO-8859-1") to
           convert the input string specified by the :in option to the
           sub-process's stdin.  Defaults to UTF-8.
           If the :in option provides a byte array, then the bytes are passed
           unencoded, and this option is ignored.
  :out-enc option may be given followed by :bytes, :stream or a String. If a
           String is given, it will be used as a character encoding
           name (for example "UTF-8" or "ISO-8859-1") to convert
           the sub-process's stdout to a String which is returned.
           If :bytes is given, the sub-process's stdout will be stored
           in a byte array and returned.  Defaults to UTF-8.
  :async   If true, returns a map with :out, :err and :proc keys, and
           the caller is responsible for reading these and
           the sxit status.
  :env     override the process env with a map (or the underlying Java
           String[] if you are a masochist).
  :dir     override the process dir with a String or java.io.File.</p>

<p>  You can bind :env or :dir for multiple operations using with-sh-env
  and with-sh-dir.</p>

<p>  sh returns a map of
    :exit => sub-process's exit code
    :out  => sub-process's stdout (as byte[] or String)
    :err  => sub-process's stderr (String via platform default encoding)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sh
  {:added "1.2"}
  [& args]
  (let [[cmd opts] (parse-args args)
        proc (.exec (Runtime/getRuntime)
                    ^"[Ljava.lang.String;" (into-array cmd)
                    (as-env-strings (:env opts))
                    (as-file (:dir opts)))
        {:keys [in in-enc out-enc async]} opts]
    (if in
      (future
       (if (instance? (class (byte-array 0)) in)
         (with-open [os (.getOutputStream proc)]
           (.write os ^"[B" in))
         (with-open [osw (OutputStreamWriter.
                          (.getOutputStream proc) ^String in-enc)]
           (.write osw ^String in))))
      (.close (.getOutputStream proc)))
    (if async
      {:out (.getInputStream proc)
       :err (.getErrorStream proc)
       :proc proc}
      (with-open [stdout (.getInputStream proc)
                  stderr (.getErrorStream proc)]
        (let [out (future (stream-to-enc stdout out-enc))
              err (future (stream-to-string stderr))
              exit-code (.waitFor proc)]
          {:exit exit-code :out @out :err @err})))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(comment

(println (sh "ls" "-l"))
(println (sh "ls" "-l" "/no-such-thing"))
(println (sh "sed" "s/[aeiou]/oo/g" :in "hello there\n"))
(println (sh "cat" :in "x\u25bax\n"))
(println (sh "echo" "x\u25bax"))
(println
 (sh "echo" "x\u25bax" :out-enc "ISO-8859-1")) ; reads 4 single-byte chars
(println
 (sh "cat" "myimage.png" :out-enc :bytes)) ; reads binary file into bytes[]
(println (sh "cmd" "/c dir 1>&2"))

)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.strint" name="pallet.strint"><h1 class="project-name">pallet.strint</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Runtime string interpolation built on top of clojure.contrib.strint.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.strint
 (:use clojure.contrib.strint)
 (:require
   clojure.walk))</pre></tr><tr><td class="docs"><p>Capture the values of the specified symbols in a symbol&rarr;value map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro capture-values
  [& values]
  (into {} (map (fn [s] [ `'~s s]) values)))</pre></tr><tr><td class="docs"><p>Interpolate a string given a map of symbol&rarr;value</p>
</td><td class="codes" /><pre class="brush: clojure">(defn <<!
  [f value-map]
  (apply str
         (map (fn [x] (if (symbol? x)
                            (value-map x)
                            (if (seq x)
                              (eval (clojure.walk/prewalk-replace value-map x))
                              x)))
                  (#'clojure.contrib.strint/interpolate f))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.target" name="pallet.target"><h1 class="project-name">pallet.target</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Compatibility namespace</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.target
  (:require
   [pallet.common.deprecate :as deprecate]))</pre></tr><tr><td class="docs"><p>OS family</p>
</td><td class="codes" /><pre class="brush: clojure">(defn os-family
  {:deprecated "0.5.0"}
  [target]
  (deprecate/deprecated
   "pallet.target/os-family is deprecated, please use pallet.session/os-family")
  (:os-family target))</pre></tr><tr><td class="docs"><p>Default administrator group</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-group
  [target]
  (deprecate/deprecated
   "pallet.target/admin-group is deprecated, please use pallet.session/admin-group")
  (case (os-family target)
    :yum "wheel"
    "adm"))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.add-service" name="pallet.task.add-service"><h1 class="project-name">pallet.task.add-service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Add a service definition to pallet.</p>

<p>   This doesn't work, see:
   http://stackoverflow.com/questions/3790889/clojure-lein-read-line-stdin-woes</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.add-service
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]
   [pallet.compute :as compute]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn warn-on-invalid-provider-name
  [provider-name available-services]
  (if (not (and provider-name (some #(= provider-name %) available-services)))
    (do
      (println "WARNING:" provider-name "is not an available provider")
      (println "         Currently loaded providers are:")
      (doseq [provider available-services]
        (println "           " provider))
      (println "Try adding " (str "org.jclouds/" provider-name)
               "or org.jclouds/jclouds-all as a dependency if you can not see"
               "the provider you want. Writing configuration file with"
               "specified provider anyway."))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn write-service
  [file service-name provider-name identity credential]
  (.. (java.io.File. (.getParent file)) mkdirs)
  (spit file (pr-str {(keyword service-name) {:provider provider-name
                                              :identity identity
                                              :credential credential}})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn add-service*
  [file service-name provider-name identity credential]
  (let [service-name (name service-name)
        available-services (compute/supported-providers)]
    (warn-on-invalid-provider-name provider-name available-services)
    (write-service file service-name provider-name identity credential)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn usage []
  (binding [*out* *err*]
    (println "incorrect arguments:")
    (println "  lein pallet service-name provider-name identity credential")))</pre></tr><tr><td class="docs"><p>Add a service provider definition to your pallet configuration.
       lein pallet add-serivce name [provider [identity [credential]]]
   This will create ~/.pallet/services/name.clj</p>
</td><td class="codes" /><pre class="brush: clojure">(defn
  ^{:no-service-required true}
  add-service
  [ & [service-name provider-name identity credential & _]]
  (if (and service-name provider-name identity credential)
    (let [service-name (name service-name)
          path (io/file
                (System/getProperty "user.home")
                ".pallet" "services" service-name)]
      (if (.exists path)
        (do
          (println
           "Service configuration file" (.getPath path) "already exists")
          1)
        (add-service*
         path service-name
         (name provider-name)
         (name identity)
         (name credential))))
    (usage)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.containers" name="pallet.task.containers"><h1 class="project-name">pallet.task.containers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>List contianers.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.containers
  (:require
   [pallet.blobstore :as blobstore]))</pre></tr><tr><td class="docs"><p>List containers.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn containers
  [request & args]
  (doseq [container (blobstore/containers (:blobstore request))
          :let [container (bean container)
                location (-> container :location)]]
    (println
     (format
      "\t%20s  %s"
      (:name container) (.getDescription location)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.converge" name="pallet.task.converge"><h1 class="project-name">pallet.task.converge</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Adjust node counts.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.converge
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [a (first args)]
      (cond
       (and (nil? m) (symbol? a) (nil? (namespace a))) (recur
                                                        (next args)
                                                        (name a)
                                                        m
                                                        phases)
       (not (keyword? a)) (recur
                           (nnext args)
                           prefix
                           (assoc (or m {}) a (fnext args))
                           phases)
       :else (recur (next args) prefix m (conj phases a)))
      (concat [m] (if prefix [:prefix prefix] []) [:phase phases]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn converge
  "Adjust node counts.  Requires a map of node-type, count pairs.
     eg. pallet converge mynodes/my-node 1
   The node-types should be namespace qualified."
  [request & args]
  (let [args (build-args args)]
    (apply core/converge
           (concat args
                   (apply concat
                          (->
                           request
                           (dissoc :config :project)
                           (assoc :environment
                             (-> request :project :environment))))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.converge-cluster" name="pallet.task.converge-cluster"><h1 class="project-name">pallet.task.converge-cluster</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Adjust node counts for a cluster.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.converge-cluster
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [a (first args)]
      (cond
       (and (nil? m) (symbol? a) (nil? (namespace a))) (recur
                                                        (next args)
                                                        (name a)
                                                        m
                                                        phases)
       (nil? m) (recur (next args) prefix a phases)
       :else (recur (next args) prefix m (conj phases a)))
      (concat [m] (if prefix [:prefix prefix] []) [:phase phases]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn converge-cluster
  "Adjust node counts of a cluster.  Requires the name of the cluster.
       pallet converge-cluster org.mynodes/my-cluster
       pallet converge-cluster org.mynodes/my-cluster :install :configure
   The cluster name should be namespace qualified."
  [request & args]
  (let [args (build-args args)]
    (apply core/converge-cluster
           (concat args
                   (apply concat
                          (->
                           request
                           (dissoc :config :project)
                           (assoc :environment
                             (-> request :project :environment))))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.describe-node" name="pallet.task.describe-node"><h1 class="project-name">pallet.task.describe-node</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Adjust node counts.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.describe-node
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn describe-node
  "Display the node definition for the given node-types."
  {:no-service-required true}
  [& args]
  (doseq [arg args]
    (println (format "%s\t %s" (arg :tag) (arg :image)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.destroy-cluster" name="pallet.task.destroy-cluster"><h1 class="project-name">pallet.task.destroy-cluster</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Destroy nodes for a cluster.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.destroy-cluster
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [a (first args)]
      (cond
       (and (nil? m) (symbol? a) (nil? (namespace a))) (recur
                                                        (next args)
                                                        (name a)
                                                        m
                                                        phases)
       (not (keyword? a)) (recur (next args) prefix a phases)
       :else (recur (next args) prefix m (conj phases a)))
      (concat [m] (if prefix [:prefix prefix] []) [:phase phases]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn destroy-cluster
  "Adjust node counts of a cluster.  Requires the name of the cluster.
     eg. pallet converge-cluster org.mynodes/my-cluster
   The cluster name should be namespace qualified."
  [request & args]
  (let [args (build-args args)]
    (apply core/destroy-cluster
           (concat args
                   (apply concat
                          (->
                           request
                           (dissoc :config :project)
                           (assoc :environment
                             (-> request :project :environment))))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.feedback" name="pallet.task.feedback"><h1 class="project-name">pallet.task.feedback</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Feedback to the pallet project.
      add  - send new feedback. Arguments will be sent as text.
      list - show recent feedback.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.feedback
  (:require
   [pallet.heynote :as heynote]
   [clojure.contrib.http.agent :as agent]
   [clojure.contrib.http.connection :as connection]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def heynote-project (heynote/project "pallet"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def desc "feedback")
(defn as-keyword [x]
  (cond
   (string? x) (keyword x)
   (symbol? x) (keyword (name x))
   :else x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn feedback
  {:no-service-required true}
  [& args]
  (let [[task & args] args
        task (as-keyword task)
        task (or task :list)]
    (condp = task
        :add  (heynote/new-item
               :text (apply str (interpose " " args)))
        :list (heynote/items)
        :show (if-let [item (first args)]
                (heynote/item item)
                (println "Specify the %tag to show."))
        :comment (let [[item & args] args]
                   (if item
                     (heynote/add-comment
                      item
                      :text (apply str (interpose " " args)))
                     (println "Specify the %tag to comment on.")))
        (do (println "Unknown feedback command" task)
            (println "Valid feedback commands:")
            (println "  list         - list feedback")
            (println "  add          - add a feedback (%tag to name it)")
            (println "  comment %tag - add a comment on the specified item")
            (println "  show %tag    - show the specified item")))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.help" name="pallet.task.help"><h1 class="project-name">pallet.task.help</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Display a list of tasks or help for a given task.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.help)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def impl-ns #"^pallet\.task\.")
(def task-list (atom nil))</pre></tr><tr><td class="docs"><p>Find the available tasks.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tasks
  []
  (try
   (require 'clojure.contrib.find-namespaces)
   (let [find-namespaces-on-classpath
         (find-var 'clojure.contrib.find-namespaces/find-namespaces-on-classpath)]
     (or @task-list
         (reset! task-list
                 (set (filter #(re-find impl-ns (name %))
                              (find-namespaces-on-classpath))))))
   (catch java.io.FileNotFoundException e
     #{'pallet.task.help
       'pallet.task.new-project})))</pre></tr><tr><td class="docs"><p>Help for a task is stored in its docstring, or if that's not present
  in its namespace.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn help-for
  [task]
  (let [task-ns (symbol (str "pallet.task." task))
        _ (require task-ns)
        task (ns-resolve task-ns (symbol task))]
    (or (:doc (meta task))
        (:doc (meta (find-ns task-ns))))))</pre></tr><tr><td class="docs"><p>affected by clojure ticket #130: bug of AOT'd namespaces losing metadata</p>
</td><td class="codes" /><pre class="brush: clojure">(defn help-summary-for [task-ns]
  (require task-ns)
  (let [task-name (last (.split (name task-ns) "\\."))]
    (str task-name (apply str (repeat (- 8 (count task-name)) " "))
         " - " (:doc (meta (find-ns task-ns))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn help
  {:no-service-required true}
  ([task] (println (help-for task)))
  ([]
     (println "Pallet is a cloud administration tool.\n")
     (println "Several tasks are available:")
     (doseq [task-ns (tasks)]
       ;; (println (help-summary-for task-ns))
       (println " " (last (.split (name task-ns) "\\."))))
     (println "\nRun pallet help $TASK for details.")
     (if @task-list
       (do
         (println "\nYou can write project specific tasks under the\n"
                  "pallet.task namespace.")
         (println "\nOptions:")
         (println "  -progvide    name-of-cloud-provider")
         (println "  -identity    login for cloud service API")
         (println "  -credential  key or password for cloud service API")
         (println "\nIf no options are given, the following sequence is used to")
         (println "find a service to use.")
         (println "\n  the pallet.config.service property is checked for the")
         (println "    name of a var to use for the service,")
         (println "\n  the ~/.pallet/config.clj is checked for an active profile")
         (println "    specified with `defpallet`.  e.g.")
         (println "      (defpallet")
         (println "        :services {")
         (println "          :aws {:provider \"ec2\)
         (println "                :identity \"username or key\)
         (println "                :credential \"password, key or secret key\"}})")
         (println "\n  the ~/.m2/settings.xml is checked for an active profile")
         (println "    with the following properties:")
         (println "      pallet.compute.provider")
         (println "      pallet.compute.identity")
         (println "      pallet.compute.credential,")
         (println "\n  the pallet.config/service is used if it exists."))
       (do
         (println "Run the new-project task to create a pallet project.\n")))
     (println "\nSee http://github.com/hugoduncan/pallet.")))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.lift" name="pallet.task.lift"><h1 class="project-name">pallet.task.lift</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Apply configuration.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.lift
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [a (first args)]
      (cond
       (and (nil? m) (symbol? a) (nil? (namespace a))) (recur
                                                        (next args)
                                                        (name a)
                                                        m
                                                        phases)
       (not (keyword? a)) (recur
                           (next args)
                           prefix
                           (conj (or m []) a)
                           phases)
       :else (recur (next args) prefix m (conj phases a)))
      (concat (if prefix [prefix] []) [(set m)] [:phase phases]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift
  "Apply configuration.
     eg. pallet lift mynodes/my-node
   The node-types should be namespace qualified."
  [request & args]
  (let [args (build-args args)]
    (apply core/lift
           (concat args
                   (apply concat
                          (->
                           request
                           (dissoc :config :project)
                           (assoc :environment
                             (-> request :project :environment))))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.new-project" name="pallet.task.new-project"><h1 class="project-name">pallet.task.new-project</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Create a new pallet project.
     pallet new-project <project-directory>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.new-project
  (:import
   [java.io
    File OutputStreamWriter FileOutputStream PrintWriter]))</pre></tr><tr><td class="docs"><p>We don't want this task to depend on clojure.contrib, or on lein</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>(defn spit
"Opposite of slurp.  Opens f, writes content, then closes f."
[f content]
(with-open [w (PrintWriter.
(OutputStreamWriter.
(FileOutputStream. f)))]
(.print w content)))</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn file
  [& args]
  (File. (apply str (interpose "/" args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn ns->path [n]
  (str (.. (str n)
           (replace \- \_)
           (replace \. \/))
       ".clj"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn new-project-lein
  [project-name project-dir]
  (let [project-name (symbol project-name)
        group-id (namespace project-name)
        artifact-id (name project-name)]
    (.mkdirs (File. project-dir))
    (spit (file project-dir "project.clj")
          (str "(defproject " project-name " \"1.0.0-SNAPSHOT\"\n"
               "  :description \"FIXME: write\"\n"
               "  :dependencies [[pallet/pallet \"0.0.1-SNAPSHOT\"]])\n"))
    (let [project-ns  (str (.replace (str project-name) "/" ".") ".nodes")
          project-clj (ns->path project-ns)
          test-clj (.replace project-clj ".clj" "_test.clj")]
      (.mkdirs (file project-dir "test"))
      (.mkdirs (.getParentFile (file project-dir "src" project-clj)))
      (spit (file project-dir "src" project-clj)
            (str "(ns " project-ns
                 "\n  \"Admin and provisioning for FIXME:project.\" "
                 "\n  (:require"
                 "\n    [pallet.core :as core]))\n"))
      (.mkdirs (.getParentFile (file project-dir "test" test-clj)))
      (spit (file project-dir "test" test-clj)
            (str "(ns " (str project-ns "-test")
                 "\n  (:use [" project-ns "] :reload-all)"
                 "\n  (:use [clojure.test]))\n\n"
                 "(deftest replace-me ;; FIXME: write\n  (is false))\n"))
      (spit (file project-dir ".gitignore")
            (apply str (interpose"\n" ["pom.xml" "*jar" "lib" "classes"])))
      (spit (file project-dir "README")
            (apply str (interpose "\n\n" [(str "# " artifact-id)
                                          "FIXME: write description"
                                          "## Usage" "FIXME: write"
                                          "## Installation" "FIXME: write"
                                          "## License" "FIXME: write\n"])))
      (println "Created new project in:" project-dir)
      (println "You should now run 'lein deps' in that directory."))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn new-project
  {:no-service-required true}
  [& args]
  (let [name (first args)
        dir (or (second args) "pallet")]
    (if (.exists (File. dir))
      (do
        (println "Directory" dir "already exists.")
        (System/exit 1))
      (new-project-lein name dir))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.nodes" name="pallet.task.nodes"><h1 class="project-name">pallet.task.nodes</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>list nodes.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.nodes
  (:require
   [pallet.compute :as compute]
   [clojure.contrib.pprint :as pprint])
  (:use clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nodes
  [request]
  (let [ns (compute/nodes (:compute request))]
    (doseq [n ns]
      (println n))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.providers" name="pallet.task.providers"><h1 class="project-name">pallet.task.providers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provide information on the supported and enabled providers.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.providers
  (:require
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- provider-properties []
  (apply
   hash-map
   (apply concat
          (filter #(re-find #"(.*)\.contextbuilder" (first %))
                  (utils/resource-properties "rest.properties")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- enabled?
  [provider]
  (try
   (Class/forName provider)
   (catch java.lang.ClassNotFoundException e)))</pre></tr><tr><td class="docs"><p>Provide information on the supported and enabled providers.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn providers
  {:no-service-required true}
  [& _]
  (println "Pallet uses jcloud's providers.\n")
  (doseq [supported (sort #(compare (first %1) (first %2))
                          (provider-properties))
          :let [key (first supported)
                name (.substring key 0 (.indexOf key "."))]]
    (println
     (format
      "\t%20s  %s"
      name
      (if (enabled? (second supported)) "Enabled" "Disabled"))))
  (println "\nProviders can be enabled by adding a dependency on the jclouds ")
  (println "provider into your project.clj or pom.xml."))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.to-blob" name="pallet.task.to-blob"><h1 class="project-name">pallet.task.to-blob</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Upload to a blob.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.to-blob
  (:require
   [pallet.blobstore :as blobstore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn war-file-name
  [project]
  (format "%s-%s.war" (:name project) (:version project)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn find-war
  [project]
  (some
   #(let [f (% project)] (and (.exists (java.io.File. f)) f))
   [war-file-name]))</pre></tr><tr><td class="docs"><p>Upload to a blob.
    to-blob container path filename
   By default tries to upload the project war file.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn to-blob
  [request & args]
  (let [[container path & files] (map name args)
        file (or (first files) (find-war (:project request)))
        options (-> request :project :pallet)]
    (if file
      (do
        (println "Uploading" file)
        (blobstore/put-file (:blobstore request) container path file))
      (println "Nothing to upload"))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.version" name="pallet.task.version"><h1 class="project-name">pallet.task.version</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Print Pallet's version to standard out.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.version)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn version
  {:no-service-required true}
  []
  (println "Pallet" (System/getProperty "pallet.version")
           "on Java" (System/getProperty "java.version")
           (System/getProperty "java.vm.name")))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.template.properties" name="pallet.template.properties"><h1 class="project-name">pallet.template.properties</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A template for writing properties style config files.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.template.properties
  (:use [pallet.utils :only [as-string]]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn property-section [[name settings]]
  (apply
   str
   "[" (as-string name) "]" \newline
   (map #(format "%s = %s\n" (as-string (first %)) (as-string (second %))) settings)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn property-set [p]
  (apply str (map property-section p)))</pre></tr><tr><td class="docs"><p>Write a properties file based on the input argument.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn properties
  [values]
  (apply str (map property-set values)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.template" name="pallet.template"><h1 class="project-name">pallet.template</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Template file writing</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.template
  (:require
   [pallet.compute :as compute]
   [pallet.script.lib :as lib]
   [pallet.session :as session]
   [pallet.stevedore :as stevedore]
   [pallet.strint :as strint]
   [pallet.target :as target]
   [pallet.utils :as utils]
   [clojure.string :as string]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn get-resource
  "Loads a resource. Returns a URI."
  [path]
  (-> (clojure.lang.RT/baseLoader) (.getResource path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn path-components
  "Split a resource path into path, basename and extension components."
  [path]
  (let [p (inc (.lastIndexOf path "/"))
        i (.lastIndexOf path ".")]
    [(when (pos? p) (subs path 0 (dec p)))
     (if (neg? i) (subs path p) (subs path p i))
     (if (neg? i) nil (subs path (inc i)))]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn pathname
  "Build a pathname from a list of path and filename parts.  Last part is
   assumed to be a file extension.
   'The name of a resource is a '/'-separated path name that identifies the
   resource.'"
  [path file ext]
  (str (when path (str path "/")) file (when ext (str "." ext))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- candidate-templates
  "Generate a prioritised list of possible template paths."
  [path tag session]
  (let [[dirpath base ext] (path-components path)
        variants (fn [specifier]
                   (let [p (pathname
                            dirpath
                            (if specifier (str base "_" specifier) base)
                            ext)]
                     [p (str "resources/" p)]))]
    (concat
     (variants tag)
     (variants (name (or (session/os-family session) "unknown")))
     (variants (name (or (session/packager session) "unknown")))
     (variants nil))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn find-template
  "Find a template for the specified path, for application to the given node.
   Templates may be specialised."
  [path session]
  {:pre [(map? session) (session :server)]}
  (some
   get-resource
   (candidate-templates
    path (-> session :server :group-name) session)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn interpolate-template
  "Interpolate the given template."
  [path values session]
  (strint/<<!
   (utils/load-resource-url
    (find-template path session))
   (utils/map-with-keys-as-symbols values)))</pre></tr><tr><td class="docs"><p>programatic templates - umm not really templates at all</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro deftemplate [template [& args] m]
  `(defn ~template [~@args]
     ~m))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-template-file [[file-spec content]]
  (logging/trace (str "apply-template-file " file-spec \newline content))
  (let [path (:path file-spec)]
    (string/join
     (filter (complement nil?)
             [(stevedore/script
               (var file ~path)
               ((~lib/cat ) > @file <<EOF))
              content
              "\nEOF\n"
              (when-let [mode (:mode file-spec)]
                (stevedore/script (do (chmod ~mode @file))))
              (when-let [group (:group file-spec)]
                (stevedore/script (do (chgrp ~group @file))))
              (when-let [owner (:owner file-spec)]
                (stevedore/script (do (chown ~owner @file))))]))))</pre></tr><tr><td class="docs"><p>TODO - add chmod, owner, group</p>
</td><td class="codes" /><pre class="brush: clojure">(defn apply-templates [template-fn args]
  (string/join  (map apply-template-file (apply template-fn args))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.utils" name="pallet.utils"><h1 class="project-name">pallet.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Utilities used across pallet.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.utils
  (:require
   [clojure.java.io :as io]
   [clojure.contrib.jar :as jar]
   [clojure.contrib.string :as string]
   [clojure.contrib.pprint :as pprint]
   [clojure.contrib.logging :as logging])
  (:use
   clojure.contrib.logging
   clojure.contrib.def)
  (:import
   (java.security
    NoSuchAlgorithmException
    MessageDigest)
   (org.apache.commons.codec.binary Base64)))</pre></tr><tr><td class="docs"><p>Pretty print a multiline string</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pprint-lines
  [s]
  (pprint/pprint (seq (.split #"\r?\n" s))))</pre></tr><tr><td class="docs"><p>Return the string value of the argument in quotes.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn quoted
  [s]
  (str "\"" s "\""))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn underscore [s]
  "Change - to _"
  (apply str (interpose "_"  (.split s "-"))))</pre></tr><tr><td class="docs"><p>Return the string value of the argument.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn as-string
  [arg]
  (cond
   (symbol? arg) (name arg)
   (keyword? arg) (name arg)
   :else (str arg)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn resource-path [name]
  (let [loader (.getContextClassLoader (Thread/currentThread))
        resource (. loader getResource name)]
    (when resource
      (.getFile resource))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn load-resource
  [name]
  (let [loader (.getContextClassLoader (Thread/currentThread))]
    (.getResourceAsStream loader name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn load-resource-url
  [name]
  (logging/trace (format "load-resource-url %s" name))
  (with-open [stream (.getContent name)
              r (new java.io.BufferedReader
                     (new java.io.InputStreamReader
                          stream (.name (java.nio.charset.Charset/defaultCharset))))]
    (let [sb (new StringBuilder)]
      (loop [c (.read r)]
        (if (neg? c)
          (str sb)
          (do
            (.append sb (char c))
            (recur (.read r))))))))</pre></tr><tr><td class="docs"><p>Given a resource <code>path</code>, load it as a java properties file.
   Returns nil if resource not found.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn resource-properties
  [path]
  (let [loader (.getContextClassLoader (Thread/currentThread))
        stream (.getResourceAsStream loader path)]
    (when stream
      (with-open [stream stream]
        (let [properties (new java.util.Properties)]
          (.load properties stream)
          (let [keysseq (enumeration-seq (. properties propertyNames))]
            (reduce (fn [a b] (assoc a b (. properties getProperty b)))
                    {} keysseq)))))))</pre></tr><tr><td class="docs"><p>Read the given file as a byte array.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn slurp-as-byte-array
  [#^java.io.File file]
  (let [size (.length file)
        bytes #^bytes (byte-array size)
        stream (new java.io.FileInputStream file)]
    bytes))</pre></tr><tr><td class="docs"><p>Find the var for the given namespace and symbol. If the namespace does
   not exist, then it will be required.
       (find-var-with-require 'my.ns 'a-symbol)
       (find-var-with-require 'my.ns/a-symbol)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-var-with-require
  ([sym]
     (find-var-with-require (symbol (namespace sym)) (symbol (name sym))))
  ([ns sym]
     (try
       (when-not (find-ns ns)
         (require ns))
       (when-let [v (ns-resolve ns sym)]
         (var-get v))
       (catch Exception _))))</pre></tr><tr><td class="docs"><p>Return the default private key path.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-private-key-path
  []
  (str (System/getProperty "user.home") "/.ssh/id_rsa"))</pre></tr><tr><td class="docs"><p>Return the default public key path</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-public-key-path
  []
  (str (System/getProperty "user.home") "/.ssh/id_rsa.pub"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord User
  [username public-key-path private-key-path passphrase
   password sudo-password no-sudo])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn user? [user]
  (instance? pallet.utils.User user))</pre></tr><tr><td class="docs"><p>Creates a User record with the given username and options. Generally used
   in conjunction with <em>admin-user</em> and pallet.core/with-admin-user, or passed
   to <code>lift</code> or <code>converge</code> as the named :user argument.</p>

<p>   Options:
    - :public-key-path (defaults to ~/.ssh/id_rsa.pub)
    - :private-key-path (defaults to ~/.ssh/id_rsa)
    - :passphrase
    - :password
    - :sudo-password (defaults to :password)
    - :no-sudo</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-user
  [username & {:keys [public-key-path private-key-path passphrase
                      password sudo-password no-sudo] :as options}]
  (merge (User. username nil nil nil nil nil nil)
    {:private-key-path (default-private-key-path)
     :public-key-path (default-public-key-path)
     :sudo-password (:password options)}
    options))</pre></tr><tr><td class="docs"><p>The admin user is used for running remote admin commands that require root
   permissions.  The default admin user is taken from the pallet.admin.username
   property.  If not specified then the user.name property is used.
   The admin user can also be specified in config.clj when running tasks
   from the command line.</p>
</td><td class="codes" /><pre class="brush: clojure">(defvar *admin-user*
  (make-user (or (. System getProperty "pallet.admin.username")
                 (. System getProperty "user.name"))))</pre></tr><tr><td class="docs"><p>Set the admin user based on pallet.config setup.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user-from-config-var
  []
  (find-var-with-require 'pallet.config 'admin-user))</pre></tr><tr><td class="docs"><p>Set the admin user based on a config map</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user-from-config
  [config]
  (when-let [admin-user (:admin-user config)]
    (apply make-user (:username admin-user) (apply concat admin-user))))</pre></tr><tr><td class="docs"><p>Create a block where <code>varname</code> is a temporary <code>File</code> containing <code>content</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-temp-file
  [[varname content] & body]
  `(let [~varname (java.io.File/createTempFile "stevedore", ".tmp")]
     (io/copy ~content ~varname)
     (let [rv# (do ~@body)]
       (.delete ~varname)
       rv#)))</pre></tr><tr><td class="docs"><p>Create a temporary file</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tmpfile
  ([] (java.io.File/createTempFile "pallet_" "tmp"))
  ([^java.io.File dir] (java.io.File/createTempFile "pallet_" "tmp" dir)))</pre></tr><tr><td class="docs"><p>Create a temporary directory.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tmpdir
  []
  (doto (java.io.File/createTempFile "pallet_" "tmp")
    (.delete) ; this is a potential cause of non-unique names
    (.mkdir)))</pre></tr><tr><td class="docs"><p>A block scope allowing multiple bindings to expressions.  Each binding will
   have the member function <code>delete</code> called on it.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-temporary
  [bindings & body] {:pre
   [(vector?  bindings)
         (even? (count bindings))]}
  (cond
   (= (count bindings) 0) `(do ~@body)
   (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)
                             (try
                              (with-temporary ~(subvec bindings 2) ~@body)
                              (finally
                               (. ~(bindings 0) delete))))
   :else (throw (IllegalArgumentException.
                 "with-temporary only allows Symbols in bindings"))))</pre></tr><tr><td class="docs"><p>Produce a map that is the same as m, but with all keys are converted to
  symbols.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn map-with-keys-as-symbols
  [m]
  (letfn [(to-symbol [x]
                     (cond
                      (symbol? x) x
                      (string? x) (symbol x)
                      (keyword? x) (symbol (name x))))]
    (zipmap (map to-symbol (keys m)) (vals m))))</pre></tr><tr><td class="docs"><p>Like clojure.core/dissoc, except it takes a vector of keys to remove</p>
</td><td class="codes" /><pre class="brush: clojure">(defn dissoc-keys
  [m keys]
  (apply dissoc m keys))</pre></tr><tr><td class="docs"><p>Like clojure.core/dissoc, except it only dissoc's if the value at the
   keyword is nil.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn dissoc-if-empty
  [m key]
  (if (empty? (m key)) (dissoc m key) m))</pre></tr><tr><td class="docs"><p>'Updates' a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created only if the update function returns a non-nil value. If
  the update function returns nil, the map is returned unmodified.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn maybe-update-in
  ([m [& ks] f & args]
     (let [v (f (get-in m ks))]
       (if v
         (assoc-in m ks v)
         m))))</pre></tr><tr><td class="docs"><p>Build a session processing pipeline from the specified forms.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro pipe
  [& forms]
  (let [[middlewares etc] (split-with #(or (seq? %) (symbol? %)) forms)
        middlewares (reverse middlewares)
        [middlewares [x :as etc]]
          (if (seq etc)
            [middlewares etc]
            [(rest middlewares) (list (first middlewares))])
          handler x]
    (if (seq middlewares)
      `(-> ~handler ~@middlewares)
      handler)))</pre></tr><tr><td class="docs"><p>Computes the base64 encoding of the md5 of a string</p>
</td><td class="codes" /><pre class="brush: clojure">(defn base64-md5
  [#^String unsafe-id]
  (let [alg (doto (MessageDigest/getInstance "MD5")
              (.reset)
              (.update (.getBytes unsafe-id)))]
    (try
      (Base64/encodeBase64URLSafeString (.digest alg))
      (catch NoSuchAlgorithmException e
        (throw (new RuntimeException e))))))</pre></tr><tr><td class="docs"><p>Build a middleware processing pipeline from the specified forms.
   The result is a middleware.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro middleware
  [& forms]
  (let [[middlewares] (split-with #(or (seq? %) (symbol? %)) forms)
        middlewares (reverse middlewares)]
    (if (seq middlewares)
      `(fn [handler#] (-> handler# ~@middlewares))
      `(fn [handler#] handler#))))</pre></tr><tr><td class="docs"><p>Convert a URL to a File. </p>

<p>see http://weblogs.java.net/blog/kohsuke/archive/2007/04/how<em>to</em>convert.html</p>
</td><td class="codes" /><pre class="brush: clojure">(defn file-for-url
  [^java.net.URL url]
  (try
    (java.io.File. (.toURI url))
    (catch java.net.URISyntaxException _
      (java.io.File. (.getPath url)))))</pre></tr><tr><td class="docs"><p>Return the classpath URL's for the current clojure classloader.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn classpath-urls
  []
  (.getURLs (.getClassLoader clojure.lang.RT)))</pre></tr><tr><td class="docs"><p>Return the classpath File's for the current clojure classloader.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn classpath
  []
  (map file-for-url (classpath-urls)))</pre></tr><tr><td class="docs"><p>Returns a sequence of JarFile objects for the JAR files on classpath.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn classpath-jarfiles
  []
  (filter
   identity
   (map
    #(try
       (java.util.jar.JarFile. %)
       (catch Exception _
         (logging/warn
          (format "Unable to open jar file on classpath: %s" %))))
    (filter jar/jar-file? (classpath)))))</pre></tr><tr><td class="docs"><p>Forward a script to the new script lib</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro forward-to-script-lib
  [& symbols]
  `(do
     ~@(for [sym symbols]
         (list `def sym (symbol "pallet.script.lib" (name sym))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_pallet.action.conditional">pallet.action.conditional</li><li class="floating-toc-li" id="floating-toc_pallet.action.directory">pallet.action.directory</li><li class="floating-toc-li" id="floating-toc_pallet.action.environment">pallet.action.environment</li><li class="floating-toc-li" id="floating-toc_pallet.action.exec-script">pallet.action.exec-script</li><li class="floating-toc-li" id="floating-toc_pallet.action.file">pallet.action.file</li><li class="floating-toc-li" id="floating-toc_pallet.action.filesystem">pallet.action.filesystem</li><li class="floating-toc-li" id="floating-toc_pallet.action.package.centos">pallet.action.package.centos</li><li class="floating-toc-li" id="floating-toc_pallet.action.package.debian-backports">pallet.action.package.debian-backports</li><li class="floating-toc-li" id="floating-toc_pallet.action.package.epel">pallet.action.package.epel</li><li class="floating-toc-li" id="floating-toc_pallet.action.package.jpackage">pallet.action.package.jpackage</li><li class="floating-toc-li" id="floating-toc_pallet.action.package.rpmforge">pallet.action.package.rpmforge</li><li class="floating-toc-li" id="floating-toc_pallet.action.package">pallet.action.package</li><li class="floating-toc-li" id="floating-toc_pallet.action.remote-directory">pallet.action.remote-directory</li><li class="floating-toc-li" id="floating-toc_pallet.action.remote-file">pallet.action.remote-file</li><li class="floating-toc-li" id="floating-toc_pallet.action.rsync">pallet.action.rsync</li><li class="floating-toc-li" id="floating-toc_pallet.action.service">pallet.action.service</li><li class="floating-toc-li" id="floating-toc_pallet.action.user">pallet.action.user</li><li class="floating-toc-li" id="floating-toc_pallet.action">pallet.action</li><li class="floating-toc-li" id="floating-toc_pallet.action-plan">pallet.action-plan</li><li class="floating-toc-li" id="floating-toc_pallet.argument">pallet.argument</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore.implementation">pallet.blobstore.implementation</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore.jclouds">pallet.blobstore.jclouds</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore.url-blobstore">pallet.blobstore.url-blobstore</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore">pallet.blobstore</li><li class="floating-toc-li" id="floating-toc_pallet.command-line">pallet.command-line</li><li class="floating-toc-li" id="floating-toc_pallet.command-script">pallet.command-script</li><li class="floating-toc-li" id="floating-toc_pallet.compute.implementation">pallet.compute.implementation</li><li class="floating-toc-li" id="floating-toc_pallet.compute.jclouds">pallet.compute.jclouds</li><li class="floating-toc-li" id="floating-toc_pallet.compute.jvm">pallet.compute.jvm</li><li class="floating-toc-li" id="floating-toc_pallet.compute.node-list">pallet.compute.node-list</li><li class="floating-toc-li" id="floating-toc_pallet.compute.vmfest">pallet.compute.vmfest</li><li class="floating-toc-li" id="floating-toc_pallet.compute">pallet.compute</li><li class="floating-toc-li" id="floating-toc_pallet.config-file.format">pallet.config-file.format</li><li class="floating-toc-li" id="floating-toc_pallet.configure">pallet.configure</li><li class="floating-toc-li" id="floating-toc_pallet.core">pallet.core</li><li class="floating-toc-li" id="floating-toc_pallet.crate.network-service">pallet.crate.network-service</li><li class="floating-toc-li" id="floating-toc_pallet.crate.session-store">pallet.crate.session-store</li><li class="floating-toc-li" id="floating-toc_pallet.crate">pallet.crate</li><li class="floating-toc-li" id="floating-toc_pallet.debug">pallet.debug</li><li class="floating-toc-li" id="floating-toc_pallet.enlive">pallet.enlive</li><li class="floating-toc-li" id="floating-toc_pallet.environment">pallet.environment</li><li class="floating-toc-li" id="floating-toc_pallet.execute">pallet.execute</li><li class="floating-toc-li" id="floating-toc_pallet.futures">pallet.futures</li><li class="floating-toc-li" id="floating-toc_pallet.heynote">pallet.heynote</li><li class="floating-toc-li" id="floating-toc_pallet.logging">pallet.logging</li><li class="floating-toc-li" id="floating-toc_pallet.main">pallet.main</li><li class="floating-toc-li" id="floating-toc_pallet.main-invoker">pallet.main-invoker</li><li class="floating-toc-li" id="floating-toc_pallet.maven">pallet.maven</li><li class="floating-toc-li" id="floating-toc_pallet.md5crypt">pallet.md5crypt</li><li class="floating-toc-li" id="floating-toc_pallet.parameter">pallet.parameter</li><li class="floating-toc-li" id="floating-toc_pallet.phase">pallet.phase</li><li class="floating-toc-li" id="floating-toc_pallet.repl">pallet.repl</li><li class="floating-toc-li" id="floating-toc_pallet.request-map">pallet.request-map</li><li class="floating-toc-li" id="floating-toc_pallet.resource.directory">pallet.resource.directory</li><li class="floating-toc-li" id="floating-toc_pallet.resource.exec-script">pallet.resource.exec-script</li><li class="floating-toc-li" id="floating-toc_pallet.resource.file">pallet.resource.file</li><li class="floating-toc-li" id="floating-toc_pallet.resource.filesystem">pallet.resource.filesystem</li><li class="floating-toc-li" id="floating-toc_pallet.resource.filesystem-layout">pallet.resource.filesystem-layout</li><li class="floating-toc-li" id="floating-toc_pallet.resource.format">pallet.resource.format</li><li class="floating-toc-li" id="floating-toc_pallet.resource.hostinfo">pallet.resource.hostinfo</li><li class="floating-toc-li" id="floating-toc_pallet.resource.lib">pallet.resource.lib</li><li class="floating-toc-li" id="floating-toc_pallet.resource.network-service">pallet.resource.network-service</li><li class="floating-toc-li" id="floating-toc_pallet.resource.package">pallet.resource.package</li><li class="floating-toc-li" id="floating-toc_pallet.resource.remote-directory">pallet.resource.remote-directory</li><li class="floating-toc-li" id="floating-toc_pallet.resource.remote-file">pallet.resource.remote-file</li><li class="floating-toc-li" id="floating-toc_pallet.resource.resource-when">pallet.resource.resource-when</li><li class="floating-toc-li" id="floating-toc_pallet.resource.rsync">pallet.resource.rsync</li><li class="floating-toc-li" id="floating-toc_pallet.resource.service">pallet.resource.service</li><li class="floating-toc-li" id="floating-toc_pallet.resource.shell">pallet.resource.shell</li><li class="floating-toc-li" id="floating-toc_pallet.resource.user">pallet.resource.user</li><li class="floating-toc-li" id="floating-toc_pallet.resource">pallet.resource</li><li class="floating-toc-li" id="floating-toc_pallet.script.lib">pallet.script.lib</li><li class="floating-toc-li" id="floating-toc_pallet.session">pallet.session</li><li class="floating-toc-li" id="floating-toc_pallet.shell">pallet.shell</li><li class="floating-toc-li" id="floating-toc_pallet.strint">pallet.strint</li><li class="floating-toc-li" id="floating-toc_pallet.target">pallet.target</li><li class="floating-toc-li" id="floating-toc_pallet.task.add-service">pallet.task.add-service</li><li class="floating-toc-li" id="floating-toc_pallet.task.containers">pallet.task.containers</li><li class="floating-toc-li" id="floating-toc_pallet.task.converge">pallet.task.converge</li><li class="floating-toc-li" id="floating-toc_pallet.task.converge-cluster">pallet.task.converge-cluster</li><li class="floating-toc-li" id="floating-toc_pallet.task.describe-node">pallet.task.describe-node</li><li class="floating-toc-li" id="floating-toc_pallet.task.destroy-cluster">pallet.task.destroy-cluster</li><li class="floating-toc-li" id="floating-toc_pallet.task.feedback">pallet.task.feedback</li><li class="floating-toc-li" id="floating-toc_pallet.task.help">pallet.task.help</li><li class="floating-toc-li" id="floating-toc_pallet.task.lift">pallet.task.lift</li><li class="floating-toc-li" id="floating-toc_pallet.task.new-project">pallet.task.new-project</li><li class="floating-toc-li" id="floating-toc_pallet.task.nodes">pallet.task.nodes</li><li class="floating-toc-li" id="floating-toc_pallet.task.providers">pallet.task.providers</li><li class="floating-toc-li" id="floating-toc_pallet.task.to-blob">pallet.task.to-blob</li><li class="floating-toc-li" id="floating-toc_pallet.task.version">pallet.task.version</li><li class="floating-toc-li" id="floating-toc_pallet.template.properties">pallet.template.properties</li><li class="floating-toc-li" id="floating-toc_pallet.template">pallet.template</li><li class="floating-toc-li" id="floating-toc_pallet.utils">pallet.utils</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>