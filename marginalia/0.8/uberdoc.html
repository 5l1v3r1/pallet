<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="DevOps for the JVM.

Pallet is a platform for agile and programmatic automation of infrastructure
in the cloud, on server racks or directly on virtual machines. Pallet
provides cloud provider and operating system independence, and allows for an
unprecedented level of customization." name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>com.palletops/pallet -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">com.palletops/pallet</h1><h2 class="project-version">0.8.0-RC.7</h2><br /><p>DevOps for the JVM.</p>

<p>Pallet is a platform for agile and programmatic automation of infrastructure
in the cloud, on server racks or directly on virtual machines. Pallet
provides cloud provider and operating system independence, and allows for an
unprecedented level of customization.</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.4.0</td></tr><tr><td class="dep-name">org.clojure/core.incubator</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0</td></tr><tr><td class="dep-name">org.clojure/tools.logging</td><td class="dotted"><hr /></td><td class="dep-version">0.2.0</td></tr><tr><td class="dep-name">org.clojure/tools.macro</td><td class="dotted"><hr /></td><td class="dep-version">0.1.1</td></tr><tr><td class="dep-name">org.clojure/tools.cli</td><td class="dotted"><hr /></td><td class="dep-version">0.2.2</td></tr><tr><td class="dep-name">org.clojure/algo.monads</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0</td></tr><tr><td class="dep-name">com.palletops/chiba</td><td class="dotted"><hr /></td><td class="dep-version">0.2.0</td></tr><tr><td class="dep-name">com.palletops/thread-expr</td><td class="dotted"><hr /></td><td class="dep-version">1.3.0</td></tr><tr><td class="dep-name">com.palletops/pallet-common</td><td class="dotted"><hr /></td><td class="dep-version">0.4.0</td></tr><tr><td class="dep-name">com.palletops/pallet-repl</td><td class="dotted"><hr /></td><td class="dep-version">0.8.0-beta.2</td></tr><tr><td class="dep-name">com.palletops/script-exec</td><td class="dotted"><hr /></td><td class="dep-version">0.4.0</td></tr><tr><td class="dep-name">com.palletops/stevedore</td><td class="dotted"><hr /></td><td class="dep-version">0.8.0-beta.5</td></tr><tr><td class="dep-name">clj-ssh</td><td class="dotted"><hr /></td><td class="dep-version">0.5.7</td></tr><tr><td class="dep-name">enlive</td><td class="dotted"><hr /></td><td class="dep-version">1.0.1</td></tr><tr><td class="dep-name">pallet-fsmop</td><td class="dotted"><hr /></td><td class="dep-version">0.3.1</td></tr><tr><td class="dep-name">pallet-map-merge</td><td class="dotted"><hr /></td><td class="dep-version">0.1.0</td></tr><tr><td class="dep-name">org.clojars.runa/clj-schema</td><td class="dotted"><hr /></td><td class="dep-version">0.9.4</td></tr><tr><td class="dep-name">org.flatland/useful</td><td class="dotted"><hr /></td><td class="dep-version">0.10.3</td></tr><tr><td class="dep-name">commons-codec</td><td class="dotted"><hr /></td><td class="dep-version">1.4</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#cfg.current">cfg.current</a></li><li><a href="#pallet.action">pallet.action</a></li><li><a href="#pallet.action-impl">pallet.action-impl</a></li><li><a href="#pallet.action-plan">pallet.action-plan</a></li><li><a href="#pallet.actions">pallet.actions</a></li><li><a href="#pallet.actions.direct">pallet.actions.direct</a></li><li><a href="#pallet.actions.direct.conditional">pallet.actions.direct.conditional</a></li><li><a href="#pallet.actions.direct.directory">pallet.actions.direct.directory</a></li><li><a href="#pallet.actions.direct.exec-script">pallet.actions.direct.exec-script</a></li><li><a href="#pallet.actions.direct.file">pallet.actions.direct.file</a></li><li><a href="#pallet.actions.direct.package">pallet.actions.direct.package</a></li><li><a href="#pallet.actions.direct.remote-directory">pallet.actions.direct.remote-directory</a></li><li><a href="#pallet.actions.direct.remote-file">pallet.actions.direct.remote-file</a></li><li><a href="#pallet.actions.direct.retry">pallet.actions.direct.retry</a></li><li><a href="#pallet.actions.direct.rsync">pallet.actions.direct.rsync</a></li><li><a href="#pallet.actions.direct.service">pallet.actions.direct.service</a></li><li><a href="#pallet.actions.direct.settings">pallet.actions.direct.settings</a></li><li><a href="#pallet.actions.direct.user">pallet.actions.direct.user</a></li><li><a href="#pallet.actions-impl">pallet.actions-impl</a></li><li><a href="#pallet.api">pallet.api</a></li><li><a href="#pallet.argument">pallet.argument</a></li><li><a href="#pallet.blobstore">pallet.blobstore</a></li><li><a href="#pallet.blobstore.implementation">pallet.blobstore.implementation</a></li><li><a href="#pallet.blobstore.url-blobstore">pallet.blobstore.url-blobstore</a></li><li><a href="#pallet.command-line">pallet.command-line</a></li><li><a href="#pallet.compute">pallet.compute</a></li><li><a href="#pallet.compute.hybrid">pallet.compute.hybrid</a></li><li><a href="#pallet.compute.implementation">pallet.compute.implementation</a></li><li><a href="#pallet.compute.jvm">pallet.compute.jvm</a></li><li><a href="#pallet.compute.localhost">pallet.compute.localhost</a></li><li><a href="#pallet.compute.node-list">pallet.compute.node-list</a></li><li><a href="#pallet.config-file.format">pallet.config-file.format</a></li><li><a href="#pallet.configure">pallet.configure</a></li><li><a href="#pallet.context">pallet.context</a></li><li><a href="#pallet.contracts">pallet.contracts</a></li><li><a href="#pallet.core">pallet.core</a></li><li><a href="#pallet.core.api">pallet.core.api</a></li><li><a href="#pallet.core.api-impl">pallet.core.api-impl</a></li><li><a href="#pallet.core.data-api">pallet.core.data-api</a></li><li><a href="#pallet.core.file-upload">pallet.core.file-upload</a></li><li><a href="#pallet.core.file-upload.protocols">pallet.core.file-upload.protocols</a></li><li><a href="#pallet.core.file-upload.rsync-upload">pallet.core.file-upload.rsync-upload</a></li><li><a href="#pallet.core.operations">pallet.core.operations</a></li><li><a href="#pallet.core.plan-state">pallet.core.plan-state</a></li><li><a href="#pallet.core.primitives">pallet.core.primitives</a></li><li><a href="#pallet.core.session">pallet.core.session</a></li><li><a href="#pallet.core.thread-local">pallet.core.thread-local</a></li><li><a href="#pallet.core.user">pallet.core.user</a></li><li><a href="#pallet.core.version-dispatch">pallet.core.version-dispatch</a></li><li><a href="#pallet.crate">pallet.crate</a></li><li><a href="#pallet.crate.automated-admin-user">pallet.crate.automated-admin-user</a></li><li><a href="#pallet.crate.crontab">pallet.crate.crontab</a></li><li><a href="#pallet.crate.environment">pallet.crate.environment</a></li><li><a href="#pallet.crate.etc-default">pallet.crate.etc-default</a></li><li><a href="#pallet.crate.etc-hosts">pallet.crate.etc-hosts</a></li><li><a href="#pallet.crate.filesystem">pallet.crate.filesystem</a></li><li><a href="#pallet.crate.initd">pallet.crate.initd</a></li><li><a href="#pallet.crate.limits-conf">pallet.crate.limits-conf</a></li><li><a href="#pallet.crate.network-service">pallet.crate.network-service</a></li><li><a href="#pallet.crate.nohup">pallet.crate.nohup</a></li><li><a href="#pallet.crate.os">pallet.crate.os</a></li><li><a href="#pallet.crate.package.centos">pallet.crate.package.centos</a></li><li><a href="#pallet.crate.package.debian-backports">pallet.crate.package.debian-backports</a></li><li><a href="#pallet.crate.package.epel">pallet.crate.package.epel</a></li><li><a href="#pallet.crate.package.jpackage">pallet.crate.package.jpackage</a></li><li><a href="#pallet.crate.package.rpmforge">pallet.crate.package.rpmforge</a></li><li><a href="#pallet.crate.package-repo">pallet.crate.package-repo</a></li><li><a href="#pallet.crate.service">pallet.crate.service</a></li><li><a href="#pallet.crate.ssh-key">pallet.crate.ssh-key</a></li><li><a href="#pallet.crate.sudoers">pallet.crate.sudoers</a></li><li><a href="#pallet.crate-install">pallet.crate-install</a></li><li><a href="#pallet.debug">pallet.debug</a></li><li><a href="#pallet.echo.execute">pallet.echo.execute</a></li><li><a href="#pallet.enlive">pallet.enlive</a></li><li><a href="#pallet.environment">pallet.environment</a></li><li><a href="#pallet.environment-impl">pallet.environment-impl</a></li><li><a href="#pallet.event">pallet.event</a></li><li><a href="#pallet.execute">pallet.execute</a></li><li><a href="#pallet.executor.protocols">pallet.executor.protocols</a></li><li><a href="#pallet.executors">pallet.executors</a></li><li><a href="#pallet.feature">pallet.feature</a></li><li><a href="#pallet.futures">pallet.futures</a></li><li><a href="#pallet.local.execute">pallet.local.execute</a></li><li><a href="#pallet.main">pallet.main</a></li><li><a href="#pallet.main-invoker">pallet.main-invoker</a></li><li><a href="#pallet.md5crypt">pallet.md5crypt</a></li><li><a href="#pallet.node">pallet.node</a></li><li><a href="#pallet.node-value">pallet.node-value</a></li><li><a href="#pallet.phase">pallet.phase</a></li><li><a href="#pallet.plugin">pallet.plugin</a></li><li><a href="#pallet.project">pallet.project</a></li><li><a href="#pallet.project.load">pallet.project.load</a></li><li><a href="#pallet.project.loader">pallet.project.loader</a></li><li><a href="#pallet.script.lib">pallet.script.lib</a></li><li><a href="#pallet.script-builder">pallet.script-builder</a></li><li><a href="#pallet.script-exec">pallet.script-exec</a></li><li><a href="#pallet.session.action-plan">pallet.session.action-plan</a></li><li><a href="#pallet.session.verify">pallet.session.verify</a></li><li><a href="#pallet.ssh.credentials">pallet.ssh.credentials</a></li><li><a href="#pallet.ssh.execute">pallet.ssh.execute</a></li><li><a href="#pallet.ssh.file-upload.sftp-upload">pallet.ssh.file-upload.sftp-upload</a></li><li><a href="#pallet.ssh.node-state">pallet.ssh.node-state</a></li><li><a href="#pallet.ssh.node-state.no-state">pallet.ssh.node-state.no-state</a></li><li><a href="#pallet.ssh.node-state.protocols">pallet.ssh.node-state.protocols</a></li><li><a href="#pallet.ssh.node-state.state-root">pallet.ssh.node-state.state-root</a></li><li><a href="#pallet.ssh.script-upload.protocols">pallet.ssh.script-upload.protocols</a></li><li><a href="#pallet.strint">pallet.strint</a></li><li><a href="#pallet.task">pallet.task</a></li><li><a href="#pallet.task.add-service">pallet.task.add-service</a></li><li><a href="#pallet.task.bootstrap">pallet.task.bootstrap</a></li><li><a href="#pallet.task.config">pallet.task.config</a></li><li><a href="#pallet.task.containers">pallet.task.containers</a></li><li><a href="#pallet.task.converge">pallet.task.converge</a></li><li><a href="#pallet.task.describe-node">pallet.task.describe-node</a></li><li><a href="#pallet.task.down">pallet.task.down</a></li><li><a href="#pallet.task.help">pallet.task.help</a></li><li><a href="#pallet.task.images">pallet.task.images</a></li><li><a href="#pallet.task.lift">pallet.task.lift</a></li><li><a href="#pallet.task.nodes">pallet.task.nodes</a></li><li><a href="#pallet.task.project-init">pallet.task.project-init</a></li><li><a href="#pallet.task.providers">pallet.task.providers</a></li><li><a href="#pallet.task.to-blob">pallet.task.to-blob</a></li><li><a href="#pallet.task.up">pallet.task.up</a></li><li><a href="#pallet.task.version">pallet.task.version</a></li><li><a href="#pallet.task-utils">pallet.task-utils</a></li><li><a href="#pallet.template">pallet.template</a></li><li><a href="#pallet.template.properties">pallet.template.properties</a></li><li><a href="#pallet.utils">pallet.utils</a></li><li><a href="#pallet.version-dispatch">pallet.version-dispatch</a></li><li><a href="#pallet.versions">pallet.versions</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#cfg.current" name="cfg.current"><h1 class="project-name">cfg.current</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>DO NOT EDIT THIS FILE
This file was auto-generated by Configleaf.
Your changes could get overwritten by Configleaf.
DO NOT EDIT THIS FILE</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns cfg.current)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def project '{:classifiers {:tests {:source-paths [&quot;test&quot;], :resource-paths []}}, :compile-path &quot;/Users/duncan/projects/palletops/pallet/target/classes&quot;, :group &quot;com.palletops&quot;, :license {:name &quot;Eclipse Public License&quot;, :url &quot;http://www.eclipse.org/legal/epl-v10.html&quot;}, :global-vars {}, :dependencies ([org.clojure/clojure &quot;1.4.0&quot;] [org.clojure/core.incubator &quot;0.1.0&quot;] [org.clojure/tools.logging &quot;0.2.0&quot;] [org.clojure/tools.macro &quot;0.1.1&quot;] [org.clojure/tools.cli &quot;0.2.2&quot;] [org.clojure/algo.monads &quot;0.1.0&quot;] [com.palletops/chiba &quot;0.2.0&quot;] [com.palletops/thread-expr &quot;1.3.0&quot;] [com.palletops/pallet-common &quot;0.4.0&quot;] [com.palletops/pallet-repl &quot;0.8.0-beta.2&quot; :exclusions ([com.palletops/pallet])] [com.palletops/script-exec &quot;0.4.0&quot;] [com.palletops/stevedore &quot;0.8.0-beta.5&quot;] [enlive/enlive &quot;1.0.1&quot; :exclusions ([org.clojure/clojure])] [pallet-fsmop/pallet-fsmop &quot;0.3.1&quot;] [pallet-map-merge/pallet-map-merge &quot;0.1.0&quot;] [org.clojars.runa/clj-schema &quot;0.9.4&quot;] [org.flatland/useful &quot;0.10.3&quot;] [commons-codec/commons-codec &quot;1.4&quot;]), :plugin-repositories [[&quot;central&quot; {:snapshots false, :url &quot;http://repo1.maven.org/maven2/&quot;}] [&quot;clojars&quot; {:url &quot;https://clojars.org/repo/&quot;}]], :target-path &quot;/Users/duncan/projects/palletops/pallet/target&quot;, :name &quot;pallet&quot;, :deploy-repositories [[&quot;clojars&quot; {:username :gpg, :url &quot;https://clojars.org/repo/&quot;, :password :gpg}]], :root &quot;/Users/duncan/projects/palletops/pallet&quot;, :offline? false, :source-paths (&quot;/Users/duncan/projects/palletops/pallet/src&quot;), :certificates [&quot;clojars.pem&quot;], :version &quot;0.8.0-SNAPSHOT&quot;, :jar-exclusions [#&quot;^\.&quot;], :prep-tasks [&quot;javac&quot; &quot;compile&quot;], :url &quot;http://palletops.com&quot;, :repositories [[&quot;central&quot; {:snapshots false, :url &quot;http://repo1.maven.org/maven2/&quot;}] [&quot;clojars&quot; {:url &quot;https://clojars.org/repo/&quot;}]], :resource-paths (&quot;/Users/duncan/projects/palletops/pallet/resources&quot;), :uberjar-exclusions [#&quot;(?i)^META-INF/[^/]*\.(SF|RSA|DSA)$&quot;], :scm {:url &quot;git@github.com:pallet/pallet.git&quot;}, :jvm-opts nil, :eval-in :subprocess, :plugins [], :native-path &quot;/Users/duncan/projects/palletops/pallet/target/native&quot;, :description &quot;DevOps for the JVM.\n\nPallet is a platform for agile and programmatic automation of infrastructure\nin the cloud, on server racks or directly on virtual machines. Pallet\nprovides cloud provider and operating system independence, and allows for an\nunprecedented level of customization.&quot;, :uberjar-merge-with {&quot;META-INF/plexus/components.xml&quot; leiningen.uberjar/components-merger, &quot;data_readers.clj&quot; leiningen.uberjar/clj-map-merger}, :test-paths (&quot;/Users/duncan/projects/palletops/pallet/test&quot;), :clean-targets [:target-path], :aliases nil})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alter-var-root #'project with-meta '{:included-profiles (:provided), :without-profiles {:classifiers {:tests {:source-paths [&quot;test&quot;], :resource-paths []}}, :compile-path &quot;%s/classes&quot;, :group &quot;com.palletops&quot;, :license {:name &quot;Eclipse Public License&quot;, :url &quot;http://www.eclipse.org/legal/epl-v10.html&quot;}, :global-vars {}, :dependencies ([org.clojure/clojure &quot;1.4.0&quot;] [org.clojure/core.incubator &quot;0.1.0&quot;] [org.clojure/tools.logging &quot;0.2.0&quot;] [org.clojure/tools.macro &quot;0.1.1&quot;] [org.clojure/tools.cli &quot;0.2.2&quot;] [org.clojure/algo.monads &quot;0.1.0&quot;] [com.palletops/chiba &quot;0.2.0&quot;] [com.palletops/thread-expr &quot;1.3.0&quot;] [com.palletops/pallet-common &quot;0.4.0&quot;] [com.palletops/pallet-repl &quot;0.8.0-beta.2&quot; :exclusions ([com.palletops/pallet])] [com.palletops/script-exec &quot;0.4.0&quot;] [com.palletops/stevedore &quot;0.8.0-beta.5&quot;] [enlive/enlive &quot;1.0.1&quot; :exclusions ([org.clojure/clojure])] [pallet-fsmop/pallet-fsmop &quot;0.3.1&quot;] [pallet-map-merge/pallet-map-merge &quot;0.1.0&quot;] [org.clojars.runa/clj-schema &quot;0.9.4&quot;] [org.flatland/useful &quot;0.10.3&quot;] [commons-codec/commons-codec &quot;1.4&quot;]), :plugin-repositories [[&quot;central&quot; {:snapshots false, :url &quot;http://repo1.maven.org/maven2/&quot;}] [&quot;clojars&quot; {:url &quot;https://clojars.org/repo/&quot;}]], :target-path &quot;target&quot;, :name &quot;pallet&quot;, :deploy-repositories [[&quot;clojars&quot; {:username :gpg, :url &quot;https://clojars.org/repo/&quot;, :password :gpg}]], :root &quot;/Users/duncan/projects/palletops/pallet&quot;, :offline? false, :source-paths (&quot;src&quot;), :certificates [&quot;clojars.pem&quot;], :version &quot;0.8.0-SNAPSHOT&quot;, :jar-exclusions [#&quot;^\.&quot;], :prep-tasks [&quot;javac&quot; &quot;compile&quot;], :url &quot;http://palletops.com&quot;, :repositories [[&quot;central&quot; {:snapshots false, :url &quot;http://repo1.maven.org/maven2/&quot;}] [&quot;clojars&quot; {:url &quot;https://clojars.org/repo/&quot;}]], :resource-paths (&quot;resources&quot;), :uberjar-exclusions [#&quot;(?i)^META-INF/[^/]*\.(SF|RSA|DSA)$&quot;], :scm {:url &quot;git@github.com:pallet/pallet.git&quot;}, :jvm-opts nil, :eval-in :subprocess, :plugins [], :native-path &quot;%s/native&quot;, :description &quot;DevOps for the JVM.\n\nPallet is a platform for agile and programmatic automation of infrastructure\nin the cloud, on server racks or directly on virtual machines. Pallet\nprovides cloud provider and operating system independence, and allows for an\nunprecedented level of customization.&quot;, :uberjar-merge-with {&quot;META-INF/plexus/components.xml&quot; leiningen.uberjar/components-merger, &quot;data_readers.clj&quot; leiningen.uberjar/clj-map-merger}, :test-paths (&quot;test&quot;), :clean-targets [:target-path], :aliases nil}})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action" name="pallet.action"><h1 class="project-name">pallet.action</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions are the primitives that are called by crate functions.</p>

<p>   Actions can have multiple implementations, but by default most are
   implemented as script to be executed on the remote node.</p>

<p>   An action has an :execution, which is one of :aggregated, :in-sequence,
   :collected, :delayed-crate-fn or :aggregated-crate-fn.</p>

<p>   Calls to :aggregated actions will be grouped, and run before
   :in-sequence actions. Calls to :collected actions will be grouped, and run
   after :in-sequence actions.</p>

<p>   Calls to :delayed-crate-fn and :aggregated-crate-fn actions are evaluated
   at action plan translation time, which provides a mechanism for calling
   crate functions after all other crate functions have been called.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.action
  (:require
   [clojure.tools.macro :refer [name-with-attributes]]
   [pallet.action-impl
    :refer [action-implementation
            action-symbol
            add-action-implementation!
            make-action]]
   [pallet.action-plan
    :refer [action-map pop-block push-block schedule-action-map]]
   [pallet.common.context :refer [throw-map]]
   [pallet.core.session :refer [session session!]]
   [pallet.session.action-plan
    :refer [assoc-action-plan get-action-plan update-action-plan]]
   [pallet.stevedore :refer [with-source-line-comments]]
   [pallet.utils :refer [compiler-exception]]))</pre></td></tr><tr><td class="docs"><h1>Session precedence</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Precedence for actions can be overridden by setting the precedence map
on the session.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:no-doc true :internal true} action-options-key ::action-options)</pre></td></tr><tr><td class="docs"><p>Return any action-options currently defined on the session.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-options
  [session]
  (get-in session [:plan-state action-options-key]))</pre></td></tr><tr><td class="docs"><p>Return any action-options currently defined on the session.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-action-options
  []
  (action-options (session)))</pre></td></tr><tr><td class="docs"><p>Update any precedence modifiers defined on the session</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-action-options
  [m]
  (session! (update-in (session) [:plan-state action-options-key] merge m)))</pre></td></tr><tr><td class="docs"><p>Set precedence modifiers defined on the session.</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc-action-options
  [m]
  (session! (assoc-in (session) [:plan-state action-options-key] m)))</pre></td></tr><tr><td class="docs"><p>Set up local precedence relations between actions, and allows override
of user options.</p>

<p><code>:script-dir</code>
: Controls the directory the script is executed in.</p>

<p><code>:sudo-user</code>
: Controls the user the action runs as.</p>

<p><code>:script-prefix</code>
: Specify a prefix for the script. Disable sudo using <code>:no-sudo</code>. Defaults to
  <code>:sudo</code>.</p>

<p><code>:script-env</code>
: Specify a map of environment variables.</p>

<p><code>:script-comments</code>
: Control the generation of script line number comments</p>

<p><code>:new-login-after-action</code>
: Force a new ssh login after the action.  Useful if the action effects the
  login environment and you want the affect to be visible immediately.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:indent 1} with-action-options
  [m &amp; body]
  `(let [p# (get-action-options)
         m# ~m]
     (update-action-options m#)
     (let [v# (do ~@body)]
       (assoc-action-options p#)
       v#)))</pre></td></tr><tr><td class="docs"><h2>Actions</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Actions are primitives that may be called in a phase or crate function. An
action can have multiple implementations. At this level, actions are
represented by the function that inserts an action map for the action into
the action plan.  This inserter function has the action on its :action
metadata key.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Registers an action map in the action plan for execution. This function is
   responsible for creating a node-value (as node-value-path's have to be unique
   for all instances of an aggregated action) as a handle to the value that will
   be returned when the action map is executed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn insert-action
  [session action-map]
  {:pre [session (map? session)]}
  (let [[node-value action-plan] (schedule-action-map
                                  (get-action-plan session) action-map)]
    [node-value (assoc-action-plan session action-plan)]))</pre></td></tr><tr><td class="docs"><p>Return an action inserter function. This is used for anonymous actions. The
  argument list is not enforced.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- action-inserter-fn
  [action]
  ^{:action action
    :pallet/plan-fn true}
  (fn action-fn [&amp; argv]
    (let [session (session)
          [nv session] (insert-action
                        session
                        (action-map action argv (action-options session)))]
      (session! session)
      nv)))</pre></td></tr><tr><td class="docs"><p>Declare an action. The action-name is a symbol (not necessarily referring to
  a Var).</p>

<p>   The execution model can be specified using the :execution key in <code>metadata</code>,
   with one of the following possible values:</p>

<p>   :in-sequence - The generated action will be applied to the node
        "in order", as it is defined lexically in the source crate.
        This is the default.
   :aggregated - All aggregated actions are applied to the node
        in the order they are defined, but before all :in-sequence
        actions. Note that all of the arguments to any given
        action function are gathered such that there is only ever one
        invocation of each fn within each phase.
   :collected - All collected actions are applied to the node
        in the order they are defined, but after all :in-sequence
        action. Note that all of the arguments to any given
        action function are gathered such that there is only ever one
        invocation of each fn within each phase.
   :delayed-crate-fn - delayed crate functions are phase functions that
        are executed at action-plan translation time.
   :aggregated-crate-fn - aggregate crate functions are phase functions that are
        executed at action-plan translation time, with aggregated arguments, as
        for :aggregated.</p>
</td><td class="codes"><pre class="brush: clojure">(defn declare-action
  [action-symbol metadata]
  (let [action (make-action
                action-symbol
                (:execution metadata :in-sequence)
                (dissoc metadata :execution))]
    (action-inserter-fn action)))</pre></td></tr><tr><td class="docs"><p>Ensures that an argument map contains an :as element, by which the map can be
  referenced.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- args-with-map-as
  [args]
  (map #(if (map? %) (merge {:as (gensym &quot;as&quot;)} %) %) args))</pre></td></tr><tr><td class="docs"><p>Converts a symbolic argument list into a compatible argument vector for
   passing to a function with the same signature.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- arg-values
  [symbolic-args]
  (let [{:keys [args &amp;-seen] :as result}
        (reduce
         (fn [{:keys [args &amp;-seen] :as result} arg]
           (cond
             (= arg '&amp;) (assoc result :&amp;-seen true)
             (map? arg) (if &amp;-seen
                          (update-in
                           result [:args] conj (list `apply `concat (:as arg)))
                          (update-in result [:args] conj (:as arg)))
             :else (update-in result [:args] conj arg)))
         {:args [] :&amp;-seen false}
         symbolic-args)]
    (concat (if &amp;-seen [`apply `vector] [`vector]) args)))</pre></td></tr><tr><td class="docs"><p>Declares a named action.</p>

<p>This doesn't use declare-action, so that the action inserter function
gets the correct signature.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defaction
  {:arglists '[[action-name attr-map? [params*]]]
   :indent 'defun}
  [action-name &amp; body]
  (let [[action-name [args &amp; body]] (name-with-attributes action-name body)
        action-name (vary-meta
                     action-name assoc
                     :arglists (list 'quote [args])
                     :defonce true
                     :pallet/action true
                     :pallet/plan-fn true)
        action-symbol (symbol
                       (or (namespace action-name) (name (ns-name *ns*)))
                       (name action-name))
        metadata (meta action-name)
        args (args-with-map-as args)]
    `(let [action# (make-action
                    '~action-symbol
                    ~(:execution metadata :in-sequence)
                    ~(select-keys metadata [:always-before :always-after]))]
       (defonce ~action-name
         ^{:action action#}
         (fn ~action-name
           [~@args]
           (let [session# (session)
                 [nv# session#] (insert-action
                                 session#
                                 (action-map
                                  action#
                                  ~(arg-values args)
                                  (action-options session#)))]
             (session! session#)
             nv#))))))</pre></td></tr><tr><td class="docs"><p>Define an implementation of an action given the <code>action-inserter</code> function.</p>
</td><td class="codes"><pre class="brush: clojure">(defn implement-action*
  [action-inserter dispatch-val metadata f]
  {:pre [(fn? action-inserter) (-&gt; action-inserter meta :action) (fn? f)]}
  (let [action (-&gt; action-inserter meta :action)]
    (when-not (keyword? dispatch-val)
      (throw
       (compiler-exception
        (IllegalArgumentException.
         (format
          &quot;Attempting to implement action %s with invalid dispatch value %s&quot;
          (action-symbol action) dispatch-val)))))
    (add-action-implementation! action dispatch-val metadata f)))</pre></td></tr><tr><td class="docs"><p>Define an implementation of an action. The dispatch-val is used to dispatch
  on.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro implement-action
  {:arglists '[[action-name dispatch-val attr-map? [params*]]]
   :indent 2}
  [action-inserter dispatch-val &amp; body]
  (let [[impl-name [args &amp; body]] (name-with-attributes action-inserter body)]
    `(let [inserter# ~action-inserter]
       ;; (when-not (-&gt; inserter# meta :action)
       ;;   (throw
       ;;    (compiler-exception
       ;;     (IllegalArgumentException.
       ;;      &quot;action-inserter has no :action metadata&quot;))))
       (implement-action*
        inserter# ~dispatch-val
        ~(meta impl-name)
        (fn ~(symbol (str impl-name &quot;-&quot; (name dispatch-val)))
          [~@args] ~@body)))))</pre></td></tr><tr><td class="docs"><p>Returns the metadata and function for an implementation of an action from an
  action map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn implementation
  [{:keys [action] :as action-map} dispatch-val]
  (let [m (action-implementation action dispatch-val)]
    (if m
      m
      (throw-map
       (format
        &quot;No implementation of type %s found for action %s&quot;
        dispatch-val (action-symbol action))
       {:dispatch-val dispatch-val
        :action-name (action-symbol action)
        :action-map action-map}))))</pre></td></tr><tr><td class="docs"><p>Returns the function for an implementation of an action from an action
   inserter.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-fn
  [action-inserter dispatch-val]
  (let [action (-&gt; action-inserter meta :action)
        m (action-implementation action dispatch-val)]
    (if m
      (:f m)
      (throw-map
       (format
        &quot;No implementation of type %s found for action %s&quot;
        dispatch-val (action-symbol action))
       {:dispatch-val dispatch-val
        :action action}))))</pre></td></tr><tr><td class="docs"><p>Declare an action for a delayed crate function. A delayed crate function
   becomes an action with a single, :default, implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn declare-delayed-crate-action
  [sym f]
  (let [action (declare-action sym {:execution :delayed-crate-fn})]
    (implement-action* action :default {} f)
    action))</pre></td></tr><tr><td class="docs"><p>Declare an action for an aggregated crate function. A delayed crate function
   becomes an action with a single, :default, implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn declare-aggregated-crate-action
  [sym f]
  (let [action (declare-action sym {:execution :aggregated-crate-fn})]
    (implement-action* action :default {} f)
    action))</pre></td></tr><tr><td class="docs"><p>Declare an action for an collected crate function. A delayed crate function
   becomes an action with a single, :default, implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(defn declare-collected-crate-action
  [sym f]
  (let [action (declare-action sym {:execution :collected-crate-fn})]
    (implement-action* action :default {} f)
    action))</pre></td></tr><tr><td class="docs"><p>Creates a clojure action with a :direct implementation. The first argument
will be the session. The clojure code can not return a modified session (use a
full action to do that.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro clj-action-fn
  {:indent 1} [args &amp; impl]
  (let [action-sym (gensym &quot;clj-action&quot;)]
    `(let [action# (declare-action '~action-sym {})]
       (implement-action action# :direct
         {:action-type :fn/clojure :location :origin}
         ~args
         [(fn ~action-sym [~(first args)] ~@impl) ~(first args)])
       action#)))</pre></td></tr><tr><td class="docs"><p>Creates a clojure action with a :direct implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro clj-action
  {:indent 1}
  [args &amp; impl]
  (let [action-sym (gensym &quot;clj-action&quot;)]
    `(let [action# (declare-action '~action-sym {})]
       (implement-action action# :direct
         {:action-type :fn/clojure :location :origin}
         ~args
         [(fn ~action-sym [~(first args)] ~@impl) ~(first args)])
       action#)))</pre></td></tr><tr><td class="docs"><p>Enter a new action scope.</p>
</td><td class="codes"><pre class="brush: clojure">(defn enter-scope
  []
  (session! (update-action-plan (session) push-block)))</pre></td></tr><tr><td class="docs"><p>Leave the current action scope.</p>
</td><td class="codes"><pre class="brush: clojure">(defn leave-scope
  []
  (session! (update-action-plan (session) pop-block)))</pre></td></tr><tr><td class="docs"><p>Local Variables:
mode: clojure
eval: (define-clojure-indent (clj-action 'defun)(implement-action 4))
End:</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action-impl" name="pallet.action-impl"><h1 class="project-name">pallet.action-impl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides a data structure for pallet's actions. This is the internal
  representation of an action. User code should use pallet.action, where actions
  are represented via the functions that insert them into the session action
  plan.</p>

<p>  Each action has a symbol associated with an action is used in error messages.
  The symbol does not have to resolve to a var.</p>

<p>  The <code>execution</code> specifies the execution model for the action.</p>

<p>  Precedence is stored as a map, with :always-before and :always-after keys.</p>

<p>  Each implementation is represented as a map of metadata and function. The map
  is stored in a map in an atom on the ::impls key of the metadata of the
  action, keyed by the dispatch value. This allows for the implementation
  function to be an anonymous named function, while still having metadata
  associated with it.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.action-impl)</pre></td></tr><tr><td class="docs"><p>Function to create an action. The action will have no initial
  implementations.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-action
  [action-symbol execution precedence]
  {:action-symbol action-symbol
   :impls (atom {})
   :execution execution
   :precedence precedence})</pre></td></tr><tr><td class="docs"><p>Return the action's symbol.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-symbol
  [action]
  (:action-symbol action))</pre></td></tr><tr><td class="docs"><p>Return the execution model for the action.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-execution
  [action]
  (:execution action))</pre></td></tr><tr><td class="docs"><p>Return the precedence map for the action.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-precedence
  [action]
  (:precedence action))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn action-implementation
  ([action dispatch-val default]
     (get @(:impls action) dispatch-val (get @(:impls action) default)))
  ([action dispatch-val]
     (get @(:impls action) dispatch-val)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-action-implementation!
  [action dispatch-val metadata f]
  (swap! (:impls action) assoc dispatch-val {:f f :metadata metadata}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.action-plan" name="pallet.action-plan"><h1 class="project-name">pallet.action-plan</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>An action plan contains instances of actions (action maps) for execution.</p>

<p>   The action plan is built by executing a phase function. Each phase function
   calls actions which insert themselves into the action plan.</p>

<p>   The action plan is transformed to provide aggregated operations, run delayed
   crate functions, and to resolve precedence relations between actions.</p>

<p>   A translated plan is executed by passing an executor, which is a function
   that will be passed each action map in the plan.  The executor function is
   responsible for selecting the implementation of the action to be used, and
   calling the implementation with the action-map arguments.</p>

<p>   Note this is an implementation namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.action-plan
  (:require
   [clojure.algo.monads :refer [defmonad domonad m-map m-seq state-m]]
   [clojure.set :refer [union]]
   [clojure.stacktrace :refer [print-cause-trace]]
   [clojure.string :as string]
   [clojure.string :refer [trim]]
   [clojure.tools.logging :as logging]
   [pallet.action-impl :refer :all]
   [pallet.argument :as argument]
   [pallet.context :as context]
   [pallet.context :refer [in-phase-context-scope with-context]]
   [pallet.core.session :refer [session with-session]]
   [pallet.node-value :refer [make-node-value node-value-symbol set-node-value]]
   [pallet.session.action-plan
    :refer [dissoc-action-plan get-session-action-plan]]
   [pallet.stevedore :as stevedore :refer [with-source-line-comments]]))</pre></td></tr><tr><td class="docs"><h2>Action Plan Data Structure</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>The action plan is a stack of action maps, where the action map could itself
be a stack of action-maps (ie a tree of stacks). Branches are transformed
into :blocks of the parent action map.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Push a block onto the action-plan</p>
</td><td class="codes"><pre class="brush: clojure">(defn push-block
  [action-plan]
  (conj (or action-plan '(nil nil)) nil))</pre></td></tr><tr><td class="docs"><p>Take the last block and add it to the :blocks key of the scope below it in
  the stack.  The block is reversed to put it into the order in which elements
  were added.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pop-block
  [action-plan]
  (let [block (peek action-plan)
        stack (pop action-plan)]
    (if-let [stem (next stack)]
      (conj
       stem
       (let [sb (first stack)]
         (conj
          (rest sb)
          (update-in (first sb) [:blocks]
                     (fn [blocks]
                       (conj (or blocks []) (reverse block)))))))
      (if-let [stem (seq (first stack))]
        (list
         (update-in
          stem :blocks (fn [blocks] (conj (or blocks []) (reverse block)))))
        (reverse block)))))</pre></td></tr><tr><td class="docs"><p>Add an action map to the action plan</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-action-map
  [action-plan action-map]
  (let [action-plan (or action-plan '(nil nil))
        block (peek action-plan)
        stack (pop action-plan)]
    (conj stack (conj block action-map))))</pre></td></tr><tr><td class="docs"><h2>Action Instance Representation</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>An instance of an action in the action plan is represented as a map,
generated by <code>action-map</code>.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Set of executions that are delayed until translation time.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true
       :no-doc true
       :doc }
  delayed-execution?
  #{:delayed-crate-fn :aggregated-crate-fn :collected-crate-fn})</pre></td></tr><tr><td class="docs"><p>Return an action map for the given <code>action</code> and <code>args</code>. The action map is an
   instance of an action. The action plan is a tree of action maps.</p>

<p>   <code>options</code> specifies naming and dependencies for this instance of the action,
   and may contain :action-id, :always-before and :always-after keys. If an
   <code>options</code> is supplied, an action-id is generated if none present, to ensure
   that the standard action precedence is not altered. <code>:script-dir</code> and user
   options like <code>:sudo-user</code> may also be specified. <code>:script-prefix</code> can
   be used to prefix with something other than sudo.</p>

<ul>
<li>:action          the action that is scheduled,</li>
<li>:args            the arguments to pass to the action function,</li>
<li>:context         captures the phase context, for use at execution time,</li>
<li>:action-id       a keyword that identifies the instance of an action,</li>
<li>:always-before   a symbol, keyword or set thereof. A symbol references an
                  action, and a keyword references an instance of an action,</li>
<li>:always-after    a symbol, keyword or set thereof,</li>
<li><p>:node-value-path a symbol specifying a node value (added when scheduled).</p>

<p>The action is generated by the specified action function and arguments that
will be applied to the function when the action plan is executed.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn action-map
  [action arg-vector {:as options}]
  (let [options (or (and options
                         (seq (dissoc options :script-comments :script-trace))
                         (update-in options [:action-id]
                                    #(or % (gensym &quot;action-id&quot;))))
                    options)]
    (merge
     (merge (action-precedence action) options)
     {:action action
      :args arg-vector
      :context (if (delayed-execution? (action-execution action))
                 (drop-last (context/phase-context-scope))
                 (context/phase-contexts))})))</pre></td></tr><tr><td class="docs"><p>Helper to return the execution of the action associated with an action-map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-map-execution
  [action-map]
  {:pre [(map? action-map) (:action action-map)]}
  (action-execution (:action action-map)))</pre></td></tr><tr><td class="docs"><h2>Schedule an action map in an action plan</h2>
</td><td class="codes"><pre class="brush: clojure">(declare find-node-value-path)</pre></td></tr><tr><td class="docs"><p>Registers an action map in the action plan for execution. This function is
   responsible for creating a node-value (as node-value-path's have to be unique
   for all instances of an aggregated action) as a handle to the value that will
   be returned when the action map is executed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn schedule-action-map
  [action-plan action-map]
  {:pre [(or (nil? action-plan)
             (instance? clojure.lang.IPersistentStack action-plan))]}
  (let [node-value-path (if (#{:aggregated :collected}
                             (action-map-execution action-map))
                          (or (find-node-value-path action-plan action-map)
                              (node-value-symbol))
                          (node-value-symbol))]
    [(make-node-value node-value-path)
     (add-action-map
      action-plan (assoc action-map :node-value-path node-value-path))]))</pre></td></tr><tr><td class="docs"><p>The string that is used to represent the phase context for :aggregated
  actions.</p>

<h2>Utilities</h2>
</td><td class="codes"><pre class="brush: clojure">(defn multi-context-string
  {:no-doc true}
  [context]
  (when (seq context)
    (str &quot;[&quot; (string/join &quot;: &quot; context) &quot;]&quot;)))</pre></td></tr><tr><td class="docs"><p>The string that is used to represent the phase context for :in-sequence
  actions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn context-string
  {:no-doc true}
  [context]
  (when (seq context)
    (str (string/join &quot;: &quot; context) &quot;: &quot;)))</pre></td></tr><tr><td class="docs"><p>Return a label for an action</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti context-label
  (fn [action] (action-execution action)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod context-label :default
  [{:keys [context] :as action}]
  (when-let [s (context-string context)]
    (trim s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod context-label :aggregated
  [{:keys [context] :as action}]
  (multi-context-string context))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod context-label :collected
  [{:keys [context] :as action}]
  (multi-context-string context))</pre></td></tr><tr><td class="docs"><p>Predicate for testing if action-plan is valid. An action-plan is either a
  sequence of action maps, or an action map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- action-plan?
  [action-plan]
  (if (and action-plan
           (or (sequential? action-plan)
               (map? action-plan)))
    true
    (logging/errorf &quot;action-plan? failed: %s&quot; action-plan)))</pre></td></tr><tr><td class="docs"><h2>Action Plan Transformation</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Transform functions for working with an action-plan containing action-maps..</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Traverses an action-plan structure.  leaf-fn is applied to leaf
   action, list-fn to sequences of actions, and nested-fn to
   a nested scope. nested-fn takes the existing nested scope and a transformed
   arg list</p>
</td><td class="codes"><pre class="brush: clojure">(defn- walk-action-plan
  [leaf-fn list-fn nested-fn action-plan]
  ;;{:pre [(action-plan? action-plan)]}
  (cond
    (sequential? action-plan) (list-fn
                               (map
                                #(walk-action-plan leaf-fn list-fn nested-fn %)
                                action-plan))
    (:blocks action-plan) (nested-fn
                           action-plan
                           (map
                            #(walk-action-plan leaf-fn list-fn nested-fn %)
                            (:blocks action-plan)))
    :else (leaf-fn action-plan)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- assoc-blocks
  [action blocks]
  (assoc action :blocks blocks))</pre></td></tr><tr><td class="docs"><h2>Transform Executions</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Takes the action plan, and reorganises it based on the action
executions.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>The actions are sorted into :aggregated, :in-sequence, :collected order.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Action maps for :aggregated and :collected actions are collapsed down to a
single action map, with its :args as a sequence of all the :args from the
individual action maps.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Transforms a seq of action-maps, generally some with identical action values
   into a sequence of actions where the :args are the concatenation of all of
   the :args of associated with each :impls in the original seq.  Sequence order
   from the original seq is retained. Keys over than :impls and :args are
   assumed identical for a given :impls value.</p>

<p>   e.g. (group-by-function
           [{:impls :a :args [1 2]}
            {:impls :b :args [3 4]}
            {:impls :a :args [5 6]}
            {:impls :c :args [7 8]]])
        => ({:impls :a :args ([1 2] [5 6])}
            {:impls :c :args ([7 8])}
            {:impls :b :args ([3 4])})</p>
</td><td class="codes"><pre class="brush: clojure">(defn- group-by-function
  [action-plan]
  (letfn [(context-combine [result-action-map {:keys [context] :as action-map}]
            (if (string? (first context))
              (update-in result-action-map [:context]
                         conj (multi-context-string context))
              (update-in result-action-map [:context]
                         #(if (seq %) % context))))
          (group-combine [[_ action-calls]]
            (-&gt;
             (reduce
              #(-&gt;
                %
                (update-in [:args] conj (:args %2))
                (context-combine %2))
              (assoc (first action-calls) :args [] :context [])
              action-calls)
             (update-in [:context] #(seq (distinct (filter identity %))))))]
    (-&gt;&gt;
     action-plan
     (group-by (juxt :action :action-id))
     (map group-combine))))</pre></td></tr><tr><td class="docs"><p>Execution specific transforms</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc  :private true :no-doc true}
  execution-transforms
  {:aggregated [group-by-function]
   :collected [group-by-function]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} execution-ordering [:aggregated :in-sequence :collected])
(def ^{:private true} execution-translations {:delayed-crate-fn :in-sequence
                                              :aggregated-crate-fn :aggregated
                                              :collected-crate-fn :collected})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- translate-execution
  [execution]
  (get execution-translations execution execution))</pre></td></tr><tr><td class="docs"><p>Transform an execution by applying execution-transforms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- transform-execution
  [execution action-plan]
  (if-let [transforms (execution-transforms execution)]
    (reduce #(%2 %1) action-plan transforms)
    action-plan))</pre></td></tr><tr><td class="docs"><p>Sort an action plan scope into different executions, applying execution
   specific transforms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- transform-scope-executions
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (let [f (comp translate-execution action-map-execution)
        executions (group-by f action-plan)]
    (mapcat
     #(transform-execution % (% executions))
     execution-ordering)))</pre></td></tr><tr><td class="docs"><p>Sort an action plan into different executions, applying execution specific
   transforms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- transform-executions
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (walk-action-plan
   identity
   transform-scope-executions
   assoc-blocks
   action-plan))</pre></td></tr><tr><td class="docs"><h2>Delayed Crate Functions</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Delayed crate functions are called at action-plan translation time.</p>
</td><td class="codes"><pre class="brush: clojure">(declare execute-delayed-crate-fns)</pre></td></tr><tr><td class="docs"><p>Execute a delayed crate function</p>
</td><td class="codes"><pre class="brush: clojure">(defn- execute-delayed-crate-fn
  [session]
  (fn execute-delayed-crate-fn [action-plan]
    {:pre [(sequential? action-plan)]}
    (letfn [(ex-action-map [{:keys [action args context] :as action-map}]
              (logging/tracef &quot;ex-action-map %s&quot; session)
              (logging/tracef &quot;ex-action-map %s&quot; action-map)
              (if (delayed-execution? (action-execution action))
                ;; execute the delayed phase function
                (with-session session
                  (let [f (-&gt; (action-implementation action :default) :f)
                        _ (if (seq context)
                            (with-context
                              {:kw :ex-with-context :msg &quot;ex-with-context&quot;}
                              (in-phase-context-scope
                               context
                               (apply f args)))
                            (apply f args))
                        [action-plan session] (get-session-action-plan
                                               (pallet.core.session/session))
                        sub-plan (pop-block action-plan)]
                    ;; return the local action-plan
                    (logging/tracef &quot;local action plan is %s&quot; (vec sub-plan))
                    sub-plan))
                ;; return the unmodified action in a vector
                [action-map]))
            (ex [action-plan]
              (if (map? action-plan)
                (ex-action-map action-plan)
                ((execute-delayed-crate-fn session) action-plan)))]
      (mapcat ex action-plan))))</pre></td></tr><tr><td class="docs"><p>Walk the action plan, executing any :delayed-crate-fn actions, and replacing
   them with the action-plan that they generate.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- execute-delayed-crate-fns
  [action-plan session]
  (walk-action-plan
   identity
   (execute-delayed-crate-fn session)
   assoc-blocks
   action-plan))</pre></td></tr><tr><td class="docs"><h3>Enforce Declared Precedence Rules</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Extract an action's id to function mapping</p>

<p>Reorders action maps according to declared precedence rules.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- assoc-action-id
  [m action-map]
  (if-let [id (:action-id action-map)]
    (assoc m id (action-symbol (:action action-map)))
    m))</pre></td></tr><tr><td class="docs"><p>Merge-with clojure.set/union</p>
</td><td class="codes"><pre class="brush: clojure">(defn- merge-union
  [&amp; m]
  (apply merge-with union m))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- action-map-id
  [action-map]
  (assoc (select-keys action-map [:action-id])
    :action-symbol (-&gt; action-map :action action-symbol)))</pre></td></tr><tr><td class="docs"><p>Extract an action's dependencies.  Actions are id'd with keywords
   and dependencies are declared on an action's id or symbol. action-id-map is
   a map of known ids to symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- action-dependencies
  [action-id-map action]
  (let [as-set (fn [x] (if (or (nil? x) (set? x)) x #{x}))
        before (as-set (:always-before action))
        after (as-set (:always-after action))
        self-id (action-map-id action)
        a-&gt;s #(-&gt; % meta :action :action-symbol)]
    (reduce
     (fn [m [id deps]] (update-in m [id] #(conj (or % #{}) deps)))
     {}
     (concat
      ;; before action inserter
      (map
       #(vector {:action-symbol (a-&gt;s %)} self-id)
       (filter fn? before))
      ;; before id
      (map
       #(vector {:action-id % :action-symbol (action-id-map %)} self-id)
       (filter keyword? before))
      ;; after action inserter
      (map
       #(vector self-id {:action-symbol (a-&gt;s %)})
       (filter fn? after))
      ;; after id
      (map
       #(vector self-id {:action-id % :action-symbol (action-id-map %)})
       (filter keyword? after))))))</pre></td></tr><tr><td class="docs"><p>Given a map of dependencies, each with an :action-symbol and maybe
   an :action-id, returns a map where the values are all matching action
   instances.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- action-instances
  [actions dependencies]
  (let [action-id-maps (reduce union (vals dependencies))]
    (reduce
     (fn [instances instance]
       (let [id (action-map-id instance)]
         (if (action-id-maps id)
           (update-in instances [id] #(conj (or % #{}) instance))
           instances)))
     {}
     actions)))</pre></td></tr><tr><td class="docs"><p>Given a sequence of action maps, return a vector containing:
    - a map from id to symbol,
    - a map from symbol and possibly id, to a set of action identifiers
    - a set of all action identifiers
    - a map from action identifier.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- action-scope-dependencies
  [actions]
  (let [action-id-map (reduce assoc-action-id {} actions)
        dependencies (reduce
                      #(merge-union %1 (action-dependencies action-id-map %2))
                      {} actions)
        instances (action-instances actions dependencies)
        dependents (zipmap (keys dependencies)
                           (map
                            (fn [d] (set (mapcat instances d)))
                            (vals dependencies)))]
    (logging/tracef
     &quot;action-scope-dependencies %s&quot;
     [actions action-id-map dependencies instances dependents])
    [action-id-map dependencies instances dependents]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- action-with-dependents
  [actions dependents seen action-map]
  {:pre [(vector? actions) (set? seen) (map? action-map)]}
  (if (seen action-map)
    [actions dependents seen]
    (let [ids (distinct [(action-map-id action-map)
                         (-&gt; action-map :action action-symbol)])
          action-deps (mapcat dependents ids)]
      (let [[add-actions dependents seen]
            (reduce
             (fn add-a-w-d [[actions dependents seen] action-map]
               {:pre [(vector? actions) (set? seen) (map? action-map)]}
               (if (seen action-map)
                 [actions dependents seen]
                 (action-with-dependents actions dependents seen action-map)))
             [actions (reduce dissoc dependents ids) seen]
             action-deps)]
        [(conj add-actions action-map) dependents (conj seen action-map)]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- enforce-scope-dependencies
  [actions]
  (let [[action-id-map dependencies instances dependents]
        (action-scope-dependencies actions)]
    (first (reduce
            (fn add-as-w-d [[actions dependents seen] action]
              {:pre [(vector? actions) (set? seen) (map? action)]}
              (if (seen action)
                [actions dependents seen]
                (action-with-dependents actions dependents seen action)))
            [[] dependents #{}]
            actions))))</pre></td></tr><tr><td class="docs"><p>Enforce precedence relations between actions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- enforce-precedence
  [action-plan]
  (walk-action-plan
   identity
   enforce-scope-dependencies
   assoc-blocks
   action-plan))</pre></td></tr><tr><td class="docs"><p>Process the action-plan, applying groupings and precedence, producing
   an action plan with fully bound functions, ready for execution.</p>

<p>   This is equivalent to using an identity monad with a monadic value
   that is a tree of action maps.</p>

<h2>Translate Action Plan</h2>
</td><td class="codes"><pre class="brush: clojure">(defn translate
  [action-plan session]
  (logging/tracef &quot;translate %s&quot; (count action-plan))
  [(-&gt;
    action-plan
    pop-block ;; pop the default block
    transform-executions
    (execute-delayed-crate-fns session)
    enforce-precedence)
   (dissoc-action-plan session)])</pre></td></tr><tr><td class="docs"><h2>Node Value Path Lookup</h2>
</td><td class="codes"><pre class="brush: clojure">(defn- find-node-value-path
  [action-plan action]
  (letfn [(find-from-action [action-map]
            (when (= (:action action) (:action action-map))
              (:node-value-path action-map)))
          (find-from-actions [action-plan]
            (first (filter identity action-plan)))
          (first-identity [a s]
            s)]
    (when action-plan
      (walk-action-plan
       find-from-action
       find-from-actions
       first-identity
       action-plan))))</pre></td></tr><tr><td class="docs"><p>The pallet action execution monad is fundamentally a state monad,
     where the state is the pallet session map.</p>

<h2>Execute Action Plan</h2>
</td><td class="codes"><pre class="brush: clojure">(def
  ^{:doc
    :private true
    :no-doc true}
  action-exec-m state-m)</pre></td></tr><tr><td class="docs"><p>Predicate to test if an action plan has been translated</p>
</td><td class="codes"><pre class="brush: clojure">(defn translated?
  [action-plan]
  {:pre [(action-plan? action-plan)]}
  (not (and (= 2 (count action-plan))
            (list? (first action-plan))
            (nil? (second action-plan)))))</pre></td></tr><tr><td class="docs"><p>Map exec-action over actions in the action-plan, applying session.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-action-f
  [exec-action action-plan session]
  ((domonad action-exec-m [v (m-map exec-action action-plan)] v)
   session))</pre></td></tr><tr><td class="docs"><p>Evaluate an argument sequence</p>

<h3>Argument Evaluation</h3>
</td><td class="codes"><pre class="brush: clojure">(defn- evaluate-args
  [session args]
  (map (fn [arg] (when arg (argument/evaluate arg session))) args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn evaluate-arguments
  [session {:keys [args] :as action-map}]
  (logging/tracef &quot;evaluate-arguments&quot;)
  (assoc action-map
    :args (case (translate-execution (action-map-execution action-map))
            :in-sequence (evaluate-args session args)
            (map #(evaluate-args session %) args))))</pre></td></tr><tr><td class="docs"><h3>Node Values</h3>
</td><td class="codes"><pre class="brush: clojure">(defn- set-node-value-with-return-value
  [node-value-path [rv session]]
  (logging/tracef &quot;set-node-value %s %s&quot; node-value-path rv)
  [rv (set-node-value session rv node-value-path)])</pre></td></tr><tr><td class="docs"><p>Phase contexts when action was called in a phase</p>

<h3>Defining context</h3>

<p>The defining context is the phase context when the phase function is called.
It is made available at action execution via <em>defining-context</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  ^{:doc 
    :dynamic true
    :no-doc true}
  *defining-context*)</pre></td></tr><tr><td class="docs"><p>Returns a context string for the defining phase context.</p>
</td><td class="codes"><pre class="brush: clojure">(defn defining-context-string
  []
  (context-string *defining-context*))</pre></td></tr><tr><td class="docs"><p>Execute a single action, catching any exception and reporting it as
   an error map.</p>

<h3>Action Map Execution</h3>
</td><td class="codes"><pre class="brush: clojure">(defn execute-action-map
  [executor session
   {:keys [node-value-path context script-comments]
    :or {script-comments false}
    :as action}]
  (logging/tracef &quot;execute-action-map %s %s %s&quot; session action executor)
  (if (= ::stop (::flag session))
    [nil session]
    (try
      (binding [*defining-context* context]
        (let [session (assoc session
                        :action (-&gt; action
                                    (update-in [:action] dissoc :impls)
                                    (dissoc :node-value-path)))]
          (with-source-line-comments script-comments
            (-&gt;&gt;
             action
             (evaluate-arguments session)
             (executor session)
             ((fn [r] (logging/tracef &quot;rv is %s&quot; r) r))
             ((fn [[rv session]]
                [(if (map? rv)
                   (merge {:context (context-string context)}
                          (select-keys (:action action) [:action-symbol])
                          rv)
                   rv)
                 session]))
             (set-node-value-with-return-value node-value-path)))))
      (catch Exception e
        (logging/errorf e &quot;Exception in execute-action-map&quot;)
        [{:error {:type :pallet/action-execution-error
                  :context (context/contexts)
                  :message (format &quot;Unexpected exception: %s&quot; (.getMessage e))
                  ;; :location (with-out-str (print-cause-trace e))
                  :cause e}}
         session]))))</pre></td></tr><tr><td class="docs"><p>:execute-status-fn algorithm to stop execution on an error</p>
</td><td class="codes"><pre class="brush: clojure">(defn stop-execution-on-error
  [[result session]]
  (if (:error result)
    (do
      (logging/debugf &quot;Stopping execution %s&quot; (:error result))
      [result (assoc session ::flag ::stop)])
    [result session]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn exec-action
  [executor execute-status-fn]
  (fn exec-action-action [action]
    (fn exec-action-session [session]
      (logging/tracef &quot;exec-action %s %s %s&quot; session action executor)
      (execute-status-fn (execute-action-map executor session action)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn session-exec-action
  [session]
  (let [executor (get-in session [:action-plans ::executor])
        execute-status-fn (get-in session [:action-plans ::execute-status-fn])]
    (assert executor)
    (assert execute-status-fn)
    (exec-action executor execute-status-fn)))</pre></td></tr><tr><td class="docs"><p>Execute an if action</p>

<h3>Action Map Executor Functions</h3>

<p>Functions for use in executors.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-if
  [session {:keys [blocks] :as action} value]
  (let [exec-action (session-exec-action session)]
    (logging/tracef &quot;execute-if value %s&quot; (pr-str value))
    (if value
      ((domonad action-exec-m [v (m-map exec-action (first blocks))] (last v))
       session)
      (if-let [else (seq (second blocks))]
        ((domonad action-exec-m [v (m-map exec-action else)] (last v))
         session)
        [nil session]))))</pre></td></tr><tr><td class="docs"><h3>Action Plan Execution</h3>
</td><td class="codes"><pre class="brush: clojure">(defn execute
  [action-plan session executor execute-status-fn]
  (logging/tracef
   &quot;execute %s actions with %s %s&quot;
   (count action-plan) executor execute-status-fn)
  (when-not (translated? action-plan)
    (throw
     (ex-info
      &quot;Attempt to execute an untranslated action plan&quot;
      {:type :pallet/execute-called-on-untranslated-action-plan})))
  (letfn [(exec-action [action]
            (fn execute-with-error-check [session]
              (logging/tracef &quot;execute-with-error-check&quot;)
              (execute-status-fn
               (execute-action-map executor session action))))]
    (map-action-f
     exec-action action-plan
     (update-in
      session [:action-plans]
      assoc ::executor executor ::execute-status-fn execute-status-fn))))</pre></td></tr><tr><td class="docs"><p>Return a stevedore script that uses the current context to label the
   action</p>

<h2>Scope and Context Functions</h2>
</td><td class="codes"><pre class="brush: clojure">(defmacro checked-script
  [name &amp; script]
  `(stevedore/checked-script
    (str
     (context-string *defining-context*)
     ~name)
    ~@script))</pre></td></tr><tr><td class="docs"><p>Return a stevedore script that uses the current context to label the
   action</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro checked-commands*
  [name scripts]
  `(stevedore/checked-commands*
    (str
     (context-string (if (bound? #'*defining-context*) *defining-context* []))
     ~name)
    ~scripts))</pre></td></tr><tr><td class="docs"><p>Return a stevedore script that uses the current context to label the
   action</p>
</td><td class="codes"><pre class="brush: clojure">(defn checked-commands
  [name &amp; script]
  (checked-commands* name script))</pre></td></tr><tr><td class="docs"><p>Return an action's data.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-data
  [session {:keys [action args blocks] :as action-m}]
  (let [exec-action (session-exec-action session)
        self-fn (fn [b session]
                  (ffirst
                   ((domonad action-exec-m [v (m-map exec-action b)] v)
                    session)))
        blocks (when (= 'pallet.actions-impl/if-action (:action-symbol action))
                 [(self-fn (first blocks) session)
                  (self-fn (second blocks) session)])]
    [(merge
      {:action-symbol (:action-symbol action)
       :args (vec args)
       :form `(~(:action-symbol action) ~@args
               ~@(when blocks
                   (map :form blocks)))}
      (when blocks
        {:blocks blocks}))
     session]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions" name="pallet.actions"><h1 class="project-name">pallet.actions</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet's action primitives.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions
  (:require
   [clj-schema.schema
    :refer [constraints def-map-schema map-schema optional-path sequence-of]]
   [clojure.java.io :as io]
   [clojure.set :refer [intersection]]
   [clojure.string :refer [trim]]
   [clojure.tools.logging :as logging]
   [pallet.action
    :refer [clj-action defaction enter-scope get-action-options leave-scope
            with-action-options]]
   [pallet.action-plan :refer [checked-script]]
   [pallet.actions-impl :refer :all]
   [pallet.argument :as argument :refer [delayed delayed-argument?]]
   [pallet.contracts :refer [any-value check-spec]]
   [pallet.core.file-upload :refer :all]
   [pallet.core.session :refer [session]]
   [pallet.crate :refer [admin-user packager phase-context role-&gt;nodes-map
                         target]]
   [pallet.node-value :refer [node-value]]
   [pallet.script.lib :as lib :refer [set-flag-value user-home]]
   [pallet.stevedore :as stevedore :refer [fragment with-source-line-comments]]
   [pallet.utils :refer [apply-map log-multiline tmpfile]])
  (:import clojure.lang.Keyword))</pre></td></tr><tr><td class="docs"><h1>Direct Script Execution</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Execute script on the target node. The <code>script</code> is a plain string. <code>type</code>
   specifies the script language (default :bash). You can override the
   interpreter path using the <code>:interpreter</code> option.</p>

<p>Sometimes pallet's other actions will not suffice for what you would like to
achieve, so the exec-script actions allow you to execute arbitrary script.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction exec
  [{:keys [language interpreter version] :or {language :bash}} script])</pre></td></tr><tr><td class="docs"><p>Execute script on the target node. The script is a plain string.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction exec-script*
  [script])</pre></td></tr><tr><td class="docs"><p>Execute a bash script remotely. The script is expressed in stevedore.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro exec-script
  {:pallet/plan-fn true}
  [&amp; script]
  `(exec-script* (delayed [_#] (stevedore/script ~@script))))</pre></td></tr><tr><td class="docs"><p>Execute a bash script remotely, throwing if any element of the
   script fails. The script is expressed in stevedore.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'checked-script]}
  exec-checked-script
  {:pallet/plan-fn true}
  [script-name &amp; script]
  (let [file (.getName (io/file *file*))
        line (:line (meta &amp;form))]
    `(exec-script*
      (delayed [_#]
               (checked-script
                ~(if *script-location-info*
                   `(str ~script-name &quot; (&quot; ~file &quot;:&quot; ~line &quot;)&quot;)
                   script-name)
                ~@script)))))</pre></td></tr><tr><td class="docs"><p>Wrap arbitrary clojure code to be run as an action</p>

<h1>Wrap arbitrary code</h1>
</td><td class="codes"><pre class="brush: clojure">(defmacro as-action
  {:pallet/plan-fn true}
  [&amp; body]
  `((clj-action [~'&amp;session]
      (binding [pallet.argument/*session* ~'&amp;session]
        [(do ~@body) ~'&amp;session]))))</pre></td></tr><tr><td class="docs"><p>Generator for plan flag keywords</p>

<h1>Flow Control</h1>
</td><td class="codes"><pre class="brush: clojure">(defn ^:internal plan-flag-kw
  []
  (keyword (name (gensym &quot;flag&quot;))))</pre></td></tr><tr><td class="docs"><p>Execute the crate-fns-or-actions, only when condition is true.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro plan-when
  {:indent 1
   :pallet/plan-fn true}
  [condition &amp; crate-fns-or-actions]
  (let [nv (gensym &quot;nv&quot;)
        nv-kw (gensym &quot;nv-kw&quot;)
        m (meta &amp;form)
        is-stevedore? (and (sequential? condition)
                           (symbol? (first condition))
                           (#{#'stevedore/script #'stevedore/fragment}
                            (resolve (first condition))))
        is-script? (or (string? condition) is-stevedore?)]
    `(phase-context plan-when {:condition ~(list 'quote condition)}
       (let [~@(when is-script?
                 [nv-kw `(plan-flag-kw)
                  nv `(with-source-line-comments false
                        ~(with-meta
                           `(exec-checked-script
                             (str &quot;Check &quot; ~condition)
                             (~(list `unquote
                                     'pallet.script.lib/set-flag-value)
                              ~(list `unquote nv-kw)
                              @(do
                                 (~@(if is-stevedore?
                                      (rest condition)
                                      [&quot;test&quot; condition])
                                  &quot;&gt;/dev/null 2&gt;&amp;1&quot;)
                                 (~'println @~'?))))
                           m))])]
         (if-action ~(if is-script?
                       `(delayed [s#]
                                 (= (-&gt; (node-value ~nv s#) :flag-values ~nv-kw)
                                    &quot;0&quot;))
                       `(delayed [~'&amp;session] ~condition))))
       (enter-scope)
       ~@crate-fns-or-actions
       (leave-scope))))</pre></td></tr><tr><td class="docs"><p>Execute the crate-fns-or-actions, only when condition is false.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro plan-when-not
  {:indent 1
   :pallet/plan-fn true}
  [condition &amp; crate-fns-or-actions]
  (let [nv (gensym &quot;nv&quot;)
        nv-kw (gensym &quot;nv-kw&quot;)
        m (meta &amp;form)
        is-stevedore? (and (sequential? condition)
                           (symbol? (first condition))
                           (#{#'stevedore/script #'stevedore/fragment}
                            (resolve (first condition))))
        is-script? (or (string? condition) is-stevedore?)]
    `(phase-context plan-when-not {:condition ~(list 'quote condition)}
       (let [~@(when is-script?
                 [nv-kw `(plan-flag-kw)
                  nv `(with-source-line-comments false
                        ~(with-meta
                           `(exec-checked-script
                             (str &quot;Check not &quot; ~condition)
                             (~(list `unquote `set-flag-value)
                              ~(list `unquote nv-kw)
                              @(do
                                 (~@(if is-stevedore?
                                      (rest condition)
                                      [&quot;test&quot; condition])
                                  &quot;&gt;/dev/null 2&gt;&amp;1&quot;)
                                 (~'println @~'?))))
                           m))])]
         (if-action ~(if is-script?
                       `(delayed [s#]
                                 (= (-&gt; (node-value ~nv s#) :flag-values ~nv-kw)
                                    &quot;0&quot;))
                       `(delayed [~'&amp;session] ~condition))))
       (enter-scope)
       (leave-scope)
       (enter-scope)
       ~@crate-fns-or-actions
       (leave-scope))))</pre></td></tr><tr><td class="docs"><p>Creates an action that can transform action return values.  The return
value is itself an action return value.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-action-values
  {:pallet/plan-fn true}
  [[&amp; return-values] &amp; body]
  (let [session (gensym &quot;session&quot;)]
    `((clj-action [~session]
       [(let [~@(mapcat #(vector % `(node-value ~% ~session)) return-values)]
          (logging/tracef &quot;with-action-values %s&quot; ~(vec return-values))
          ~@body)
        ~session]))))</pre></td></tr><tr><td class="docs"><p>Creates an action that can transform return values</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro return-value-expr
  {:pallet/plan-fn true
   :deprecated &quot;0.8.0-beta.8&quot;}
  [[&amp; return-values] &amp; body]
  (let [session (gensym &quot;session&quot;)]
    `((clj-action [~session]
       [(let [~@(mapcat #(vector % `(node-value ~% ~session)) return-values)]
          (logging/tracef &quot;return-value-expr %s&quot; ~(vec return-values))
          ~@body)
        ~session]))))</pre></td></tr><tr><td class="docs"><p>Set the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default).</p>
</td><td class="codes"><pre class="brush: clojure">(defaction assoc-settings
  [facility kv-pairs &amp; {:keys [instance-id]}])</pre></td></tr><tr><td class="docs"><p>Put the specified <code>value</code> (possible a <code>NodeValue</code>) into the settings
  for <code>path</code>, a vector of <code>[facility &amp; keys]</code>, specifying a facility an a path.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction assoc-in-settings
  [path value &amp; {:keys [instance-id]}])</pre></td></tr><tr><td class="docs"><p>Update the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default).</p>
</td><td class="codes"><pre class="brush: clojure">(defaction update-settings
  [facility options-or-f &amp; args]
  {:arglists '[[facility options f &amp; args] [facility f &amp; args]]})</pre></td></tr><tr><td class="docs"><p>Touch or remove a file. Can also set owner and permissions.</p>

<pre><code> - :action    one of :create, :delete, :touch
 - :owner     user name or id for owner of file
 - :group     user name or id for group of file
 - :mode      file permissions
 - :force     when deleting, try and force removal
</code></pre>

<h1>Simple File Management</h1>
</td><td class="codes"><pre class="brush: clojure">(defaction file
  [path &amp; {:keys [action owner group mode force]
           :or {action :create force true}}])</pre></td></tr><tr><td class="docs"><p>Symbolic link management.</p>

<pre><code> - :action    one of :create, :delete
 - :owner     user name or id for owner of symlink
 - :group     user name or id for group of symlink
 - :mode      symlink permissions
 - :force     when deleting, try and force removal
 - :no-deref  do not deref target if it is a symlink to a directory
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defaction symbolic-link
  [from name &amp; {:keys [action owner group mode force]
                :or {action :create force true}}])</pre></td></tr><tr><td class="docs"><p>FIFO pipe management.</p>

<pre><code> - :action    one of :create, :delete
 - :owner     user name or id for owner of fifo
 - :group     user name or id for group of fifo
 - :mode      fifo permissions
 - :force     when deleting, try and force removal
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defaction fifo
  [path &amp; {:keys [action owner group mode force]
           :or {action :create}}])</pre></td></tr><tr><td class="docs"><p>Execute sed on the file at path.  Takes a map of expr to replacement.
     - :separator     the separator to use in generated sed expressions. This
                      will be inferred if not specified.
     - :no-md5        prevent md5 generation for the modified file
     - :restriction   restrict the sed expressions to a particular context.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction sed
  [path exprs-map &amp; {:keys [separator no-md5 restriction]}])</pre></td></tr><tr><td class="docs"><p>Directory management.</p>

<p>   For :create and :touch, all components of path are effected.</p>

<p>   Options are:
    - :action     One of :create, :touch, :delete
    - :recursive  Flag for recursive delete
    - :force      Flag for forced delete
    - :path       flag to create all path elements
    - :owner      set owner
    - :group      set group
    - :mode       set mode</p>

<h1>Simple Directory Management</h1>
</td><td class="codes"><pre class="brush: clojure">(defaction directory
  [dir-path &amp; {:keys [action recursive force path mode verbose owner
                      group]
               :or {action :create recursive true force true path true}}])</pre></td></tr><tr><td class="docs"><p>Directory management of multiple directories with the same
   owner/group/permissions.</p>

<p>   <code>options</code> are as for <code>directory</code> and are applied to each directory in
   <code>paths</code></p>
</td><td class="codes"><pre class="brush: clojure">(defaction directories
  [paths &amp; options])</pre></td></tr><tr><td class="docs"><h1>Remote File Content</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p><code>remote-file</code> has many options for the content of remote files.  Ownership
and mode can of course be specified. By default the remote file is
versioned, and multiple versions are kept.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Modification of remote files outside of pallet cause an error to be raised
by default.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A vector of the options accepted by remote-file.  Can be used for
          option forwarding when calling remote-file from other crates.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  content-options
  [:local-file :remote-file :url :md5 :content :literal :template :values
   :action :blob :blobstore :insecure :link])</pre></td></tr><tr><td class="docs"><p>A vector of options for controlling versions. Can be used for option
          forwarding when calling remote-file from other crates.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  version-options
  [:overwrite-changes :no-versioning :max-versions :flag-on-changed])</pre></td></tr><tr><td class="docs"><p>A vector of options for controlling ownership. Can be used for option
          forwarding when calling remote-file from other crates.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  ownership-options
  [:owner :group :mode])</pre></td></tr><tr><td class="docs"><p>A vector of the options accepted by remote-file.  Can be used for
          option forwarding when calling remote-file from other crates.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  all-options
  (concat content-options version-options ownership-options [:verify]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema remote-file-arguments
  :strict
  (constraints
   (fn [m] (some (set content-options) (keys m))))
  [(optional-path [:local-file]) String
   (optional-path [:remote-file]) String
   (optional-path [:url]) String
   (optional-path [:md5]) String
   (optional-path [:md5-url]) String
   (optional-path [:content]) [:or String delayed-argument?]
   (optional-path [:literal]) any-value
   (optional-path [:template]) String
   (optional-path [:values]) (map-schema :loose [])
   (optional-path [:action]) Keyword
   (optional-path [:blob]) (map-schema :strict
                                       [[:container] String [:path] String])
   (optional-path [:blobstore]) any-value  ; cheating to avoid adding a reqiure
   (optional-path [:insecure]) any-value
   (optional-path [:overwrite-changes]) any-value
   (optional-path [:no-versioning]) any-value
   (optional-path [:max-versions]) Number
   (optional-path [:flag-on-changed]) String
   (optional-path [:owner]) String
   (optional-path [:group]) String
   (optional-path [:mode]) [:or String Number]
   (optional-path [:force]) any-value
   (optional-path [:link]) String
   (optional-path [:verify]) any-value
   (optional-path [::upload-path]) String])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-remote-file-arguments
  [m]
  (check-spec m `remote-file-arguments &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema remote-directory-arguments
  :strict
  (constraints
   (fn [m] (some (set content-options) (keys m))))
  [(optional-path [:local-file]) String
   (optional-path [:remote-file]) String
   (optional-path [:url]) String
   (optional-path [:md5]) String
   (optional-path [:md5-url]) String
   (optional-path [:action]) Keyword
   (optional-path [:blob]) (map-schema :strict
                                       [[:container] String [:path] String])
   (optional-path [:blobstore]) any-value  ; cheating to avoid adding a reqiure
   (optional-path [:overwrite-changes]) any-value
   (optional-path [:owner]) String
   (optional-path [:group]) String
   (optional-path [:recursive]) any-value
   (optional-path [:unpack]) any-value
   (optional-path [:extract-files]) (sequence-of String)
   (optional-path [:mode]) [:or String Number]
   (optional-path [:tar-options]) String
   (optional-path [:unzip-options]) String
   (optional-path [:strip-components]) Number
   (optional-path [:install-new-files]) any-value])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-remote-directory-arguments
  [m]
  (check-spec m `remote-directory-arguments &amp;form))</pre></td></tr><tr><td class="docs"><p>Function to transfer a local file to a remote path.
Prefer remote-file or remote-directory over direct use of this action.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction transfer-file
  [local-path remote-path])</pre></td></tr><tr><td class="docs"><p>Function to transfer a remote file to a local path.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction transfer-file-to-local
  [remote-path local-path])</pre></td></tr><tr><td class="docs"><p>Function to delete a local path.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction delete-local-path
  [local-path])</pre></td></tr><tr><td class="docs"><p>Set boolean flag to control installation of new files</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-install-new-files
  [flag]
  (alter-var-root #'*install-new-files* (fn [_] flag)))</pre></td></tr><tr><td class="docs"><p>Globally force installation of new files, even if content on node has
  changed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-force-overwrite
  [flag]
  (alter-var-root #'*force-overwrite* (fn [_] flag)))</pre></td></tr><tr><td class="docs"><p>Remote file content management.</p>

<p>The <code>remote-file</code> action can specify the content of a remote file in a number
different ways.</p>

<p>By default, the remote-file is versioned, and 5 versions are kept.</p>

<p>The remote content is also verified against its md5 hash.  If the contents
of the remote file have changed (e.g. have been edited on the remote machine)
then by default the file will not be overwritten, and an error will be raised.
To force overwrite, call <code>set-force-overwrite</code> before running <code>converge</code> or
<code>lift</code>.</p>

<p>Options for specifying the file's content are:
<code>url</code>
: download the specified url to the given filepath</p>

<p><code>content</code>
: use the specified content directly</p>

<p><code>local-file</code>
: use the file on the local machine at the given path</p>

<p><code>remote-file</code>
: use the file on the remote machine at the given path</p>

<p><code>link</code>
: file to link to</p>

<p><code>literal</code>
: prevent shell expansion on content</p>

<p><code>md5</code>
: md5 for file</p>

<p><code>md5-url</code>
: a url containing file's md5</p>

<p><code>template</code>
: specify a template to be interpolated</p>

<p><code>values</code>
: values for interpolation</p>

<p><code>blob</code>
: map of <code>container</code>, <code>path</code></p>

<p><code>blobstore</code>
: a jclouds blobstore object (override blobstore in session)</p>

<p><code>insecure</code>
: boolean to specify ignoring of SLL certs</p>

<p>Options for version control are:</p>

<p><code>overwrite-changes</code>
: flag to force overwriting of locally modified content</p>

<p><code>no-versioning</code>
: do not version the file</p>

<p><code>max-versions</code>
: specify the number of versions to keep (default 5)</p>

<p><code>flag-on-changed</code>
: flag to set if file is changed</p>

<p>Options for specifying the file's permissions are:</p>

<p><code>owner</code>
: user-name</p>

<p><code>group</code>
: group-name</p>

<p><code>mode</code>
: file-mode</p>

<p>Options for verifying the file's content:</p>

<p><code>verify</code>
: a command to run on the file on the node, before it is installed</p>

<p>To copy the content of a local file to a remote file:
    (remote-file session "remote/path" :local-file "local/path")</p>

<p>To copy the content of one remote file to another remote file:
    (remote-file session "remote/path" :remote-file "remote/source/path")</p>

<p>To link one remote file to another remote file:
    (remote-file session "remote/path" :link "remote/source/path")</p>

<p>To download a url to a remote file:
    (remote-file session "remote/path" :url "http://a.com/path")</p>

<p>If a url to a md5 file is also available, then it can be specified to prevent
unnecessary downloads and to verify the download.</p>

<pre><code>(remote-file session "remote/path"
  :url "http://a.com/path"
  :md5-url "http://a.com/path.md5")
</code></pre>

<p>If the md5 of the file to download, it can be specified to prevent unnecessary
downloads and to verify the download.</p>

<pre><code>(remote-file session "remote/path"
  :url "http://a.com/path"
  :md5 "6de9439834c9147569741d3c9c9fc010")
</code></pre>

<p>Content can also be copied from a blobstore.</p>

<pre><code>(remote-file session "remote/path"
  :blob {:container "container" :path "blob"})
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn remote-file
  [path &amp; {:keys [action url local-file remote-file link
                  content literal
                  template values
                  md5 md5-url
                  owner group mode force
                  blob blobstore
                  install-new-files
                  overwrite-changes no-versioning max-versions
                  flag-on-changed
                  local-file-options
                  verify]
           :as options}]
  {:pre [path]}
  (check-remote-file-arguments options)
  (verify-local-file-exists local-file)
  (let [action-options (get-action-options)
        script-dir (:script-dir action-options)
        user (if (= :sudo (:script-prefix action-options :sudo))
               (:sudo-user action-options)
               (:username (admin-user)))]
    (when local-file
      (transfer-file local-file path))
    ;; we run as root so we don't get permission issues
    (remote-file-action
     path
     (merge
      {:install-new-files *install-new-files* ; capture bound values
       :overwrite-changes *force-overwrite*
       :owner user}
      options))))</pre></td></tr><tr><td class="docs"><p>Function to call f with a local copy of the sessioned remote path.
   f should be a function taking [session local-path &amp; _], where local-path will
   be a File with a copy of the remote file (which will be unlinked after
   calling f.</p>
</td><td class="codes"><pre class="brush: clojure">(defn with-remote-file
  {:pallet/plan-fn true}
  [f path &amp; args]
  (let [local-path (tmpfile)]
    (phase-context with-remote-file-fn {:local-path local-path}
      (transfer-file-to-local path local-path)
      (apply f local-path args)
      (delete-local-path local-path))))</pre></td></tr><tr><td class="docs"><p>Return a function that returns the content of a file, when used inside
   another action.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remote-file-content
  {:pallet/plan-fn true}
  [path]
  (let [nv (exec-script (~lib/cat ~path))
        c (with-action-values [nv] (:out nv))]
    c))</pre></td></tr><tr><td class="docs"><h1>Remote Directory Content</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Specify the contents of remote directory.</p>

<p>Options:</p>

<p><code>:url</code>
: a url to download content from</p>

<p><code>:unpack</code>
: how download should be extracts (default :tar)</p>

<p><code>:tar-options</code>
: options to pass to tar (default "xz")</p>

<p><code>:unzip-options</code>
: options to pass to unzip (default "-o")</p>

<p><code>:jar-options</code>
: options to pass to unzip (default "xf") jar does not support stripping path
  components</p>

<p><code>:strip-components</code>
: number of path components to remove when unpacking</p>

<p><code>:extract-files</code>
: extract only the specified files or directories from the archive</p>

<p><code>:md5</code>
: md5 of file to unpack</p>

<p><code>:md5-url</code>
: url of md5 file for file to unpack</p>

<p>Ownership options:
<code>:owner</code>
: owner of files</p>

<p><code>:group</code>
: group of files</p>

<p><code>:recursive</code>
: flag to recursively set owner and group</p>

<p>To install the content of an url pointing at a tar file, specify the :url
option.</p>

<pre><code>(remote-directory session path
   :url "http://a.com/path/file.tgz")
</code></pre>

<p>If there is an md5 url with the tar file's md5, you can specify that as well,
to prevent unnecessary downloads and verify the content.</p>

<pre><code>(remote-directory session path
   :url "http://a.com/path/file.tgz"
   :md5-url "http://a.com/path/file.md5")
</code></pre>

<p>To install the content of an url pointing at a zip file, specify the :url
option and :unpack :unzip.</p>

<pre><code>(remote-directory session path
   :url "http://a.com/path/file."
   :unpack :unzip)
</code></pre>

<p>To install the content of an url pointing at a jar/tar/zip file, extracting
only specified files or directories, use the :extract-files option.</p>

<pre><code>(remote-directory session path
   :url "http://a.com/path/file.jar"
   :unpack :jar
   :extract-files ["dir/file" "file2"])
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn remote-directory
  {:pallet/plan-fn true}
  [path &amp; {:keys [action url local-file remote-file
                  unpack tar-options unzip-options jar-options
                  strip-components md5 md5-url owner group recursive
                  force-overwrite
                  local-file-options]
           :or {action :create
                tar-options &quot;xz&quot;
                unzip-options &quot;-o&quot;
                jar-options &quot;xf&quot;
                strip-components 1
                recursive true}
           :as options}]
  (check-remote-directory-arguments options)
  (verify-local-file-exists local-file)
  (let [action-options (get-action-options)
        script-dir (:script-dir action-options)
        user (if (= :sudo (:script-prefix action-options :sudo))
               (:sudo-user action-options)
               (:username (admin-user)))]
    (when local-file
      (transfer-file local-file path))
    ;; we run as root so we don't get permission issues
    (with-action-options (merge
                          {:script-prefix :sudo
                           :sudo-user (:sudo-user (admin-user))}
                          local-file-options)
      (remote-directory-action
       path
       (merge
        {:install-new-files *install-new-files* ; capture bound values
         :overwrite-changes *force-overwrite*
         :owner user}
        options)))))</pre></td></tr><tr><td class="docs"><p>Wait for a file to exist</p>
</td><td class="codes"><pre class="brush: clojure">(defaction wait-for-file
  [path &amp; {:keys [max-retries standoff service-name]
           :or {action :create max-versions 5
                install-new-files true}
           :as options}])</pre></td></tr><tr><td class="docs"><p>Install or remove a package.</p>

<p>   Options
    - :action [:install | :remove | :upgrade]
    - :purge [true|false]         when removing, whether to remove all config
    - :enable [repo|(seq repo)]   enable specific repository
    - :disable [repo|(seq repo)]  disable specific repository
    - :priority n                 priority (0-100, default 50)
    - :disable-service-start      disable service startup (default false)</p>

<p>   Package management occurs in one shot, so that the package manager can
   maintain a consistent view.</p>

<h1>Packages</h1>
</td><td class="codes"><pre class="brush: clojure">(defaction package
  {:execution :aggregated
   :always-after #{:package-manager :package-source}}
  [package-name &amp; {:keys [action y force purge enable disable priority]
                   :or {action :install
                        y true
                        priority 50}}])</pre></td></tr><tr><td class="docs"><p>Install a list of packages keyed on packager.
       (packages session
         :yum ["git" "git-email"]
         :aptitude ["git-core" "git-email"])</p>
</td><td class="codes"><pre class="brush: clojure">(defn packages
  {:pallet/plan-fn true}
  [&amp; {:keys [yum aptitude pacman brew] :as options}]
  (phase-context packages {}
    (let [packager (packager)]
      (doseq [p (or (options packager)
                    (when (#{:apt :aptitude} packager)
                      (options (first (disj #{:apt :aptitude} packager)))))]
        (apply-map package p (dissoc options :aptitude :brew :pacman :yum))))))</pre></td></tr><tr><td class="docs"><p>Package manager controls.</p>

<p>   <code>action</code> is one of the following:
   - :update          - update the list of available packages
   - :list-installed  - output a list of the installed packages
   - :add-scope       - enable a scope (eg. multiverse, non-free)</p>

<p>   To refresh the list of packages known to the package manager:
       (package-manager session :update)</p>

<p>   To enable multiverse on ubuntu:
       (package-manager session :add-scope :scope :multiverse)</p>

<p>   To enable non-free on debian:
       (package-manager session :add-scope :scope :non-free)</p>
</td><td class="codes"><pre class="brush: clojure">(defaction package-manager
  {:always-before package
   :execution :aggregated}
  [action &amp; options])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def package-source-changed-flag &quot;packagesourcechanged&quot;)</pre></td></tr><tr><td class="docs"><p>Control package sources.
   Options are the package manager keywords, each specifying a map of
   packager specific options.</p>

<h2>`:aptitude`</h2>

<p><code>:source-type source-string</code>
: the source type (default "deb")</p>

<p><code>:url url-string</code>
: the repository url</p>

<p><code>:scopes seq</code>
: scopes to enable for repository</p>

<p><code>:release release-name</code>
: override the release name</p>

<p><code>:key-url url-string</code>
: url for key</p>

<p><code>:key-server hostname</code>
: hostname to use as a keyserver</p>

<p><code>:key-id id</code>
: id for key to look it up from keyserver</p>

<h2>`:yum`</h2>

<p><code>:name name</code>
: repository name</p>

<p><code>:url url-string</code>
: repository base url</p>

<p><code>:gpgkey url-string</code>
: gpg key url for repository</p>

<h2>Example</h2>

<pre><code>(package-source "Partner"
  :aptitude {:url "http://archive.canonical.com/"
             :scopes ["partner"]})
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defaction package-source
  {:always-before #{package-manager package}
   :execution :aggregated}
  [name &amp; {:keys [aptitude yum]}])</pre></td></tr><tr><td class="docs"><p>Add an rpm.  Source options are as for remote file.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction add-rpm
  [rpm-name &amp; {:as options}])</pre></td></tr><tr><td class="docs"><p>Add a deb.  Source options are as for remote file.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction install-deb
  [deb-name &amp; {:as options}])</pre></td></tr><tr><td class="docs"><p>Set debconf selections.
Specify <code>:line</code> as a string, or <code>:package</code>, <code>:question</code>, <code>:type</code> and
<code>:value</code> options.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction debconf-set-selections
  {:always-before #{package}}
  [{:keys [line package question type value]}])</pre></td></tr><tr><td class="docs"><p>Add minimal packages for pallet to function</p>
</td><td class="codes"><pre class="brush: clojure">(defaction minimal-packages
  {:always-before #{package-manager package-source package}}
  [])</pre></td></tr><tr><td class="docs"><p>Install the specified repository as a package source.
The :id key must contain a recognised repository.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti repository
  (fn [{:keys [id]}]
    id))</pre></td></tr><tr><td class="docs"><p>Use rsync to copy files from local-path to remote-path</p>

<h1>Synch local file to remote</h1>
</td><td class="codes"><pre class="brush: clojure">(defaction rsync
  [local-path remote-path {:keys [port]}])</pre></td></tr><tr><td class="docs"><p>Use rsync to copy files from remote-path to local-path</p>
</td><td class="codes"><pre class="brush: clojure">(defaction rsync-to-local
  [remote-path local-path {:keys [port]}])</pre></td></tr><tr><td class="docs"><p>Rsync from a local directory to a remote directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn rsync-directory
  {:pallet/plan-fn true}
  [from to &amp; {:keys [owner group mode port] :as options}]
  (phase-context rsync-directory-fn {:name :rsync-directory}
    ;; would like to ensure rsync is installed, but this requires
    ;; root permissions, and doesn't work when this is run without
    ;; root permision
    ;; (package &quot;rsync&quot;)
    (directory to :owner owner :group group :mode mode)
    (rsync from to options)))</pre></td></tr><tr><td class="docs"><p>Rsync from a local directory to a remote directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn rsync-to-local-directory
  {:pallet/plan-fn true}
  [from to &amp; {:keys [owner group mode port] :as options}]
  (phase-context rsync-directory-fn {:name :rsync-directory}
    (rsync-to-local from to options)))</pre></td></tr><tr><td class="docs"><p>User Group Management.</p>

<p><code>:action</code>
: One of :create, :manage, :remove.</p>

<p><code>:gid</code>
: specify the group id</p>

<p><code>:password</code>
: An MD5 crypted password for the user.</p>

<p><code>:system</code>
: Specify the user as a system user.</p>

<h1>Users and Groups</h1>
</td><td class="codes"><pre class="brush: clojure">(defaction group
  [groupname &amp; {:keys [action system gid password]
                :or {action :manage}
                :as options}])</pre></td></tr><tr><td class="docs"><p>User management.</p>

<p><code>:action</code>
: One of :create, :manage, :lock, :unlock or :remove.</p>

<p><code>:shell</code>
: One of :bash, :csh, :ksh, :rsh, :sh, :tcsh, :zsh, :false or a path string.</p>

<p><code>:create-home</code>
: Controls creation of the user's home directory.</p>

<p><code>:base-dir</code>
: The directory in which default user directories should be created.</p>

<p><code>:home</code>
: Specify the user's home directory.</p>

<p><code>:system</code>
: Specify the user as a system user.</p>

<p><code>:comment</code>
: A comment to record for the user.</p>

<p><code>:group</code>
: The user's login group. Defaults to a group with the same name as the user.</p>

<p><code>:groups</code>
: Additional groups the user should belong to.</p>

<p><code>:password</code>
: An MD5 crypted password for the user.</p>

<p><code>:force</code>
: Force user removal.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction user
  {:execution :aggregated
   :always-after #{group}}
  [username &amp; {:keys [action shell base-dir home system create-home
                      password shell comment group groups remove force append]
               :or {action :manage}
               :as options}])</pre></td></tr><tr><td class="docs"><p>Control services.</p>

<ul>
<li>:action  accepts either startstop, restart, enable or disable keywords.</li>
<li>:if-flag  makes start, stop, and restart conditional on the specified flag
           as set, for example, by remote-file :flag-on-changed</li>
<li>:sequence-start  a sequence of [sequence-number level level ...], where
                  sequence number determines the order in which services
                  are started within a level.</li>
<li>:service-impl    either :initd or :upstart</li>
</ul>

<p>Deprecated in favour of pallet.crate.service/service.</p>

<h1>Services</h1>
</td><td class="codes"><pre class="brush: clojure">(defaction service
  [service-name &amp; {:keys [action if-flag if-stopped service-impl]
                   :or {action :start service-impl :initd}
                   :as options}])</pre></td></tr><tr><td class="docs"><p>Stop the given service, execute the body, and then restart.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-service-restart
  [service-name &amp; body]
  `(let [service# ~service-name]
     (phase-context with-restart {:service service#}
       (service service# :action :stop)
       ~@body
       (service service# :action :start))))</pre></td></tr><tr><td class="docs"><p>Install a service script.  Sources as for remote-file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn service-script
  {:pallet/plan-fn true}
  [service-name &amp; {:keys [action url local-file remote-file link
                          content literal template values md5 md5-url
                          force service-impl]
                   :or {action :create service-impl :initd}
                   :as options}]
  (phase-context init-script {}
    (apply-map
     pallet.actions/remote-file
     (service-script-path service-impl service-name)
     :owner &quot;root&quot; :group &quot;root&quot; :mode &quot;0755&quot;
     (merge {:action action} options))))</pre></td></tr><tr><td class="docs"><h1>Retry</h1>

<p>TODO: convert to use a nested scope in the action-plan</p>
</td><td class="codes"><pre class="brush: clojure">(defn loop-until
  {:no-doc true
   :pallet/plan-fn true}
  [service-name condition max-retries standoff]
  (exec-checked-script
   (format &quot;Wait for %s&quot; service-name)
   (group (chain-or (let x 0) true))
   (while (not ~condition)
     (do
       (let x (+ x 1))
       (if (= ~max-retries @x)
         (do
           (println
            ~(format &quot;Timed out waiting for %s&quot; service-name)
            &gt;&amp;2)
           (~lib/exit 1)))
       (println ~(format &quot;Waiting for %s&quot; service-name))
       (&quot;sleep&quot; ~standoff)))))</pre></td></tr><tr><td class="docs"><p>Repeat an action until it succeeds</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro retry-until
  {:pallet/plan-fn true}
  [{:keys [max-retries standoff service-name]
    :or {max-retries 5 standoff 2}}
   condition]
  (let [service-name (or service-name &quot;retryable&quot;)]
    `(loop-until ~service-name ~condition ~max-retries ~standoff)))</pre></td></tr><tr><td class="docs"><p>target filters</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^:internal one-node-filter
  [role-&gt;nodes [role &amp; roles]]
  (let [role-nodes (set (role-&gt;nodes role))
        m (select-keys role-&gt;nodes roles)]
    (or (first (reduce
                (fn [result [role nodes]]
                  (intersection result (set nodes)))
                role-nodes
                m))
        (first role-nodes))))</pre></td></tr><tr><td class="docs"><p>Execute the body on just one node of the specified roles. If there is no
   node in the union of nodes for all the roles, the nodes for the first role
   are used.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro on-one-node
  {:pallet/plan-fn true}
  [roles &amp; body]
  `(let [target# (target)
         role-&gt;nodes# (role-&gt;nodes-map)]
     (plan-when
         (= target# (one-node-filter role-&gt;nodes# ~roles))
       ~@body)))</pre></td></tr><tr><td class="docs"><p>Log the result of a script action.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro log-script-output
  ;; This is a macro so that logging occurs in the caller's namespace
  [script-return-value
   {:keys [out err exit fmt]
    :or {out :debug err :info exit :none fmt &quot;%s&quot;}}]
  `(with-action-values
    [~script-return-value]
    (when (and (not= ~out :none) (:out ~script-return-value))
      (log-multiline ~out ~fmt (trim (:out ~script-return-value))))
    (when (and (not= ~err :none) (:err ~script-return-value))
      (log-multiline ~err ~fmt (trim (:err ~script-return-value))))
    (when (not= ~exit :none)
      (log-multiline ~exit ~fmt (:exit ~script-return-value)))))</pre></td></tr><tr><td class="docs"><p>Local Variables:
mode: clojure
eval: (define-clojure-indent (plan-when 1)(plan-when-not 1))
eval: (define-clojure-indent (with-action-values 1)(with-service-restart 1))
eval: (define-clojure-indent (on-one-node 1))
End:</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct" name="pallet.actions.direct"><h1 class="project-name">pallet.actions.direct</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Direct execution action implementations</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct )</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require
 'pallet.actions.direct.conditional
 'pallet.actions.direct.directory
 'pallet.actions.direct.exec-script
 'pallet.actions.direct.file
 'pallet.actions.direct.package
 'pallet.actions.direct.remote-directory
 'pallet.actions.direct.remote-file
 'pallet.actions.direct.rsync
 'pallet.actions.direct.service
 'pallet.actions.direct.settings
 'pallet.actions.direct.user)           ; prevent slamhound removing these</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.conditional" name="pallet.actions.direct.conditional"><h1 class="project-name">pallet.actions.direct.conditional</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Conditional action execution.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.conditional
  (:require
   [pallet.action :refer [implement-action]]
   [pallet.actions-impl :refer [if-action]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action if-action :direct
  {:action-type :flow/if :location :origin}
  [session value]
  [value session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.directory" name="pallet.actions.direct.directory"><h1 class="project-name">pallet.actions.direct.directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A directory manipulation action, to create and remove directories
   with given ownership and mode.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.directory
  (:require
   [pallet.action :refer [action-fn implement-action]]
   [pallet.actions :refer [directories directory]]
   [pallet.script.lib :as lib]
   [pallet.action-plan :as action-plan]
   [pallet.stevedore :as stevedore]))</pre></td></tr><tr><td class="docs"><p>Script to set the ownership and mode of a directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn adjust-directory
  [path {:keys [owner group mode recursive] :as opts}]
  (stevedore/chain-commands*
   (filter
    identity
    [(when owner
       (stevedore/script
        (~lib/chown ~owner ~path :recursive ~recursive)))
     (when group
       (stevedore/script
        (~lib/chgrp ~group ~path :recursive ~recursive)))
     (when mode
       (stevedore/script
        (~lib/chmod ~mode ~path)))])))</pre></td></tr><tr><td class="docs"><p>Script to create a directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-directory
  [dir-path &amp; {:keys [path verbose mode recursive] :as opts}]
  (action-plan/checked-commands
   (str &quot;Directory &quot; dir-path)
   (stevedore/script
    (~lib/mkdir ~dir-path :path ~path :verbose ~verbose :mode ~mode))
   (adjust-directory dir-path opts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action directory :direct
  {:action-type :script :location :target}
  [session dir-path &amp; {:keys [action recursive force path mode verbose owner
                              group]
                       :or {action :create recursive true force true path true}
                       :as options}]
  [[{:language :bash}
    (case action
      :delete (action-plan/checked-script
               (str &quot;Delete directory &quot; dir-path)
               (~lib/rm ~dir-path :recursive ~recursive :force ~force))
      :create (make-directory
               dir-path
               :path path :mode mode :verbose verbose
               :owner owner :group group :recursive recursive)
      :touch (make-directory
              dir-path
              :path path :mode mode :verbose verbose
              :owner owner :group group :recursive recursive))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action directories :direct
  {:action-type :script :location :target}
  [session paths &amp; options]
  [[{:language :bash}
    (stevedore/chain-commands*
      (map
       #(-&gt; (apply (action-fn directory :direct) session % options)
            first second)
       paths))]
   session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.exec-script" name="pallet.actions.direct.exec-script"><h1 class="project-name">pallet.actions.direct.exec-script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Script execution. Script generation occurs with the correct script context.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.exec-script
  (:require
   [pallet.action :refer [implement-action]]
   [pallet.actions :refer [exec exec-script*]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action exec :direct
  {:action-type :script :location :target}
  [session
   {:keys [language interpreter version] :or {language :bash} :as options}
   script]
  [[options script] session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action exec-script* :direct
  {:action-type :script :location :target}
  [session script]
  [[{:language :bash} script] session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.file" name="pallet.actions.direct.file"><h1 class="project-name">pallet.actions.direct.file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>File manipulation.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.file
  (:require
   [pallet.action :refer [implement-action]]
   [pallet.action-plan :as action-plan]
   [pallet.actions :refer [fifo file sed symbolic-link]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn adjust-file [path options]
  (stevedore/chain-commands*
   (filter
    identity
    [(when (:owner options)
       (stevedore/script (~lib/chown ~(options :owner) ~path)))
     (when (:group options)
       (stevedore/script (~lib/chgrp ~(options :group) ~path)))
     (when (:mode options)
       (stevedore/script (&quot;chmod&quot; ~(options :mode) ~path)))])))</pre></td></tr><tr><td class="docs"><p>Create a .md5 file for the specified input file</p>
</td><td class="codes"><pre class="brush: clojure">(defn write-md5-for-file
  [path md5-path]
  (stevedore/script
   &quot;(&quot;
   (chain-and
    (var cp @(~lib/canonical-path ~path))
    (&quot;cd&quot; @(~lib/dirname @cp))
    ((~lib/md5sum @(~lib/basename @cp))))
   &quot;)&quot; &gt; ~md5-path))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn touch-file [path {:keys [force] :as options}]
  (stevedore/chain-commands
   (stevedore/script
    (~lib/touch ~path :force ~force))
   (adjust-file path options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action file :direct
  {:action-type :script :location :target}
  [session path &amp; {:keys [action owner group mode force]
                   :or {action :create force true}
                   :as options}]
  [[{:language :bash}
    (case action
      :delete (action-plan/checked-script
               (str &quot;delete file &quot; path)
               (~lib/rm ~path :force ~force))
      :create (action-plan/checked-commands
               (str &quot;file &quot; path)
               (touch-file path options))
      :touch (action-plan/checked-commands
              (str &quot;file &quot; path)
              (touch-file path options)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action symbolic-link :direct
  {:action-type :script :location :target}
  [session from name &amp; {:keys [action owner group mode force no-deref]
                        :or {action :create force true}}]
  [[{:language :bash}
    (case action
      :delete (action-plan/checked-script
               (str &quot;Link %s &quot; name)
               (~lib/rm ~name :force ~force))
      :create (action-plan/checked-script
               (format &quot;Link %s as %s&quot; from name)
               (~lib/ln ~from ~name :force ~force :symbolic ~true
                        :no-deref ~no-deref)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action fifo :direct
  {:action-type :script :location :target}
  [session path &amp; {:keys [action owner group mode force]
                   :or {action :create} :as options}]
  [[{:language :bash}
    (case action
      :delete (action-plan/checked-script
               (str &quot;fifo &quot; path)
               (~lib/rm ~path :force ~force))
      :create (action-plan/checked-commands
               (str &quot;fifo &quot; path)
               (stevedore/script
                (if-not (file-exists? ~path)
                  (&quot;mkfifo&quot; ~path)))
               (adjust-file path options)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action sed :direct
  {:action-type :script :location :target}
  [session path exprs-map
   &amp; {:keys [seperator no-md5 restriction] :as options}]
  [[{:language :bash}
    (action-plan/checked-script
     (format &quot;sed file %s&quot; path)
     (~lib/sed-file ~path ~exprs-map ~options)
     ~(when-not no-md5
        (write-md5-for-file path (str path &quot;.md5&quot;))))]
   session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.package" name="pallet.actions.direct.package"><h1 class="project-name">pallet.actions.direct.package</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Package management action.</p>

<p>   <code>package</code> is used to install or remove a package.</p>

<p>   <code>package-source</code> is used to specify a non-standard source for packages.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.package
  (:require
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.action :refer [action-fn implement-action]]
   [pallet.action-plan :refer [checked-commands]]
   [pallet.actions
    :refer [add-rpm
            debconf-set-selections
            install-deb
            minimal-packages
            package
            package-manager
            package-source
            package-source-changed-flag
            sed]]
   [pallet.actions-impl :refer [remote-file-action]]
   [pallet.core.session :refer [os-family packager]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [checked-script fragment with-source-line-comments]]
   [pallet.utils :refer [apply-map]]
   [pallet.version-dispatch :refer [os-map os-map-lookup]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require 'pallet.actions.direct.remote-file)  ; stop slamhound from removing it</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
  remote-file* (action-fn remote-file-action :direct))
(def ^{:private true}
  sed* (action-fn sed :direct))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti adjust-packages
  (fn [session &amp; _]
    (packager session)))</pre></td></tr><tr><td class="docs"><p>http://algebraicthunk.net/~dburrows/projects/aptitude/doc/en/ch02s03s01.html</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} aptitude-escape-map
  {\+ &quot;\\+&quot;
   \- &quot;\\-&quot;
   \. &quot;\\.&quot;
   \( &quot;\\&quot;
   \) &quot;\\)&quot;
   \| &quot;\\|&quot;
   \[ &quot;\\[&quot;
   \] &quot;\\]&quot;
   \^ &quot;\\^&quot;
   \$ &quot;\\$&quot;})</pre></td></tr><tr><td class="docs"><p>aptitude and apt can install, remove and purge all in one command, so we just
need to split by enable/disable options.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod adjust-packages :aptitude
  [session packages]
  (logging/tracef &quot;adjust-packages :aptitude %s&quot; (vec packages))
  (checked-commands
   &quot;Packages&quot;
   (stevedore/script (~lib/package-manager-non-interactive))
   (stevedore/script (defn enableStart [] (lib/rm &quot;/usr/sbin/policy-rc.d&quot;)))
   (stevedore/chain-commands*
    (for [[opts packages] (-&gt;&gt;
                           packages
                           (group-by #(select-keys % [:enable :allow-unsigned
                                                      :disable-service-start]))
                           (sort-by #(apply min (map :priority (second %)))))]
      (stevedore/chained-script
       ~(if (:disable-service-start opts)
          (do
            (stevedore/script
             (chain-and
              (&quot;trap&quot; enableStart EXIT)
              (lib/heredoc &quot;/usr/sbin/policy-rc.d&quot; &quot;#!/bin/sh\nexit 101&quot; {}))))
          &quot;&quot;)
       (&quot;aptitude&quot;
        install -q -y
        ~(string/join &quot; &quot; (map #(str &quot;-t &quot; %) (:enable opts)))
        ~(if (:allow-unsigned opts)
           &quot;-o 'APT::Get::AllowUnauthenticated=true'&quot;
           &quot;&quot;)
        ~(string/join
          &quot; &quot;
          (for [[action packages] (group-by :action packages)
                {:keys [package force purge]} packages]
            (case action
              :install (format &quot;%s+&quot; package)
              :remove (if purge
                        (format &quot;%s_&quot; package)
                        (format &quot;%s-&quot; package))
              :upgrade (format &quot;%s+&quot; package)
              (throw
               (IllegalArgumentException.
                (str
                 action &quot; is not a valid action for package action&quot;)))))))
       ~(if (:disable-service-start opts)
          (do
            (stevedore/script
             (chain-and
              (&quot;enableStart&quot;)
              (&quot;trap&quot; - EXIT))))
          &quot;&quot;))))
   ;; aptitude doesn't report failed installed in its exit code
   ;; so explicitly check for success
   (stevedore/chain-commands*
    (for [{:keys [package action]} packages
          :let [escaped-package (string/escape package aptitude-escape-map)]]
      (cond
       (#{:install :upgrade} action)
       (stevedore/script
        (pipe (&quot;aptitude&quot;
               search
               --disable-columns
               (quoted
                (str &quot;?and(?installed, ?name(^&quot; ~escaped-package &quot;$))&quot;)))
              (&quot;grep&quot; (quoted ~package))))
       (= :remove action)
       (stevedore/script
        (not (pipe (&quot;aptitude&quot;
                    search
                    --disable-columns
                    (quoted
                     (str &quot;?and(?installed, ?name(^&quot; ~escaped-package &quot;$))&quot;)))
                   (&quot;grep&quot; (quoted ~package))))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod adjust-packages :apt
  [session packages]
  (checked-commands
   &quot;Packages&quot;
   (stevedore/script (~lib/package-manager-non-interactive))
   (stevedore/script (defn enableStart [] (lib/rm &quot;/usr/sbin/policy-rc.d&quot;)))
   (stevedore/chain-commands*
    (for [[opts packages] (-&gt;&gt;
                           packages
                           (group-by #(select-keys % [:enable :allow-unsigned
                                                      :disable-service-start]))
                           (sort-by #(apply min (map :priority (second %)))))]
      (stevedore/chained-script
       ~(if (:disable-service-start opts)
          (do
            (stevedore/script
             (chain-and
              (&quot;trap&quot; enableStart EXIT)
              (lib/heredoc &quot;/usr/sbin/policy-rc.d&quot; &quot;#!/bin/sh\nexit 101&quot; {}))))
          &quot;&quot;)
       (&quot;apt-get&quot;
        -q -y install
        ~(string/join &quot; &quot; (map #(str &quot;-t &quot; %) (:enable opts)))
        ~(if (:allow-unsigned opts) &quot;--allow-unauthenticated&quot; &quot;&quot;)
        ~(string/join
          &quot; &quot;
          (for [[action packages] (group-by :action packages)
                {:keys [package force purge]} packages]
            (case action
              :install (format &quot;%s+&quot; package)
              :remove (if purge
                        (format &quot;%s_&quot; package)
                        (format &quot;%s-&quot; package))
              :upgrade (format &quot;%s+&quot; package)
              (throw
               (IllegalArgumentException.
                (str
                 action &quot; is not a valid action for package action&quot;)))))))
       ~(if (:disable-service-start opts)
          (do
            (stevedore/script
             (chain-and
              (&quot;enableStart&quot;)
              (&quot;trap&quot; - EXIT))))
          &quot;&quot;))))
   (stevedore/script (~lib/list-installed-packages))))</pre></td></tr><tr><td class="docs"><p>Define the order of actions</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true :doc }
  action-order {:install 10 :remove 20 :upgrade 30})</pre></td></tr><tr><td class="docs"><p><code>yum</code> has separate install, remove and purge commands, so we just need to
split by enable/disable options and by command.  We install before removing.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod adjust-packages :yum
  [session packages]
  (checked-commands
   &quot;Packages&quot;
   (stevedore/chain-commands*
    (conj
     (vec
      (for [[action packages] (-&gt;&gt; packages
                                   (sort-by #(action-order (:action %)))
                                   (group-by :action))
            [opts packages] (-&gt;&gt;
                             packages
                             (group-by
                              #(select-keys % [:enable :disable :exclude]))
                             (sort-by #(apply min (map :priority (second %)))))]
        (stevedore/script
         (&quot;yum&quot;
          ~(name action) -q -y
          ~(string/join &quot; &quot; (map #(str &quot;--disablerepo=&quot; %) (:disable opts)))
          ~(string/join &quot; &quot; (map #(str &quot;--enablerepo=&quot; %) (:enable opts)))
          ~(string/join &quot; &quot; (map #(str &quot;--exclude=&quot; %) (:exclude opts)))
          ~(string/join
            &quot; &quot;
            (distinct (map :package packages)))))))
     (stevedore/script (~lib/list-installed-packages))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod adjust-packages :default
  [session packages]
  (checked-commands
   &quot;Packages&quot;
   (stevedore/chain-commands*
    (list*
     (stevedore/script (~lib/package-manager-non-interactive))
     (for [[action packages] (group-by :action packages)
           {:keys [package force purge]} packages]
       (case action
         :install (stevedore/script
                   (~lib/install-package ~package :force ~force))
         :remove (if purge
                   (stevedore/script (~lib/purge-package ~package))
                   (stevedore/script (~lib/remove-package ~package)))
         :upgrade (stevedore/script (~lib/upgrade-package ~package))
         (throw
          (IllegalArgumentException.
           (str action &quot; is not a valid action for package action&quot;)))))))))</pre></td></tr><tr><td class="docs"><p>Convert the args into a single map</p>
</td><td class="codes"><pre class="brush: clojure">(defn- package-map
  [session package-name
   &amp; {:keys [action y force purge priority enable disable allow-unsigned]
      :as options}]
  (logging/tracef &quot;package-map %s %s&quot; package-name options)
  (letfn [(as-seq [x] (if (or (string? x) (symbol? x) (keyword? x))
                        [(name x)] x))]
    (-&gt;
     {:action :install :y true :priority 50}
     (merge options)
     (assoc :package package-name)
     (update-in [:enable] as-seq)
     (update-in [:disable] as-seq))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action package :direct
  &quot;Install or remove a package.

   Options
    - :action [:install | :remove | :upgrade]
    - :purge [true|false]          when removing, whether to remove all config
    - :enable [repo|(seq repo)]    enable specific repository
    - :disable [repo|(seq repo)]   disable specific repository
    - :priority n                  priority (0-100, default 50)
    - :allow-unsigned [true|false] allow unsigned packages
    - :disable-service-start       disable service startup (default false)

   Package management occurs in one shot, so that the package manager can
   maintain a consistent view.&quot;
  {:action-type :script
   :location :target}
  [session &amp; args]
  (logging/tracef &quot;package %s&quot; (vec args))
  [[{:language :bash
     :summary (str &quot;package &quot; (string/join &quot; &quot; (apply concat args)))}
    (adjust-packages
     session (map #(apply package-map session %) (distinct args)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def source-location
  {:aptitude &quot;/etc/apt/sources.list.d/%s.list&quot;
   :apt &quot;/etc/apt/sources.list.d/%s.list&quot;
   :yum &quot;/etc/yum.repos.d/%s.repo&quot;})</pre></td></tr><tr><td class="docs"><p>Format a package source definition</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti format-source
  (fn [packager &amp; _] packager))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod format-source :aptitude
  [_ name options]
  (format
   &quot;%s %s %s %s\n&quot;
   (:source-type options &quot;deb&quot;)
   (:url options)
   (:release options (with-source-line-comments false
                       (stevedore/script (~lib/os-version-name))))
   (string/join &quot; &quot; (:scopes options [&quot;main&quot;]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod format-source :apt
  [_ name options]
  (format-source :aptitude name options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod format-source :yum
  [_ name {:keys [url mirrorlist gpgcheck gpgkey priority failovermethod
                  enabled]
           :or {enabled 1}
           :as options}]
  (string/join
   &quot;\n&quot;
   (filter
    identity
    [(format &quot;[%s]\nname=%s&quot; name name)
     (when url (format &quot;baseurl=%s&quot; url))
     (when mirrorlist (format &quot;mirrorlist=%s&quot; mirrorlist))
     (format &quot;gpgcheck=%s&quot; (or (and gpgkey 1) 0))
     (when gpgkey (format &quot;gpgkey=%s&quot; gpgkey))
     (when priority (format &quot;priority=%s&quot; priority))
     (when failovermethod (format &quot;failovermethod=%s&quot; failovermethod))
     (format &quot;enabled=%s&quot; enabled)
     &quot;&quot;])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *default-apt-keyserver* &quot;subkeys.pgp.net&quot;)</pre></td></tr><tr><td class="docs"><p>Add a packager source.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti package-source*
  (fn  [session name &amp; {:keys [apt aptitude yum] :as options}]
    (packager session)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ubuntu-ppa-add
  (atom                                 ; allow for open extension
   (os-map
    {{:os :ubuntu :os-version [[10] [12 04]]} &quot;python-software-properties&quot;
     {:os :ubuntu :os-version [[12 10] nil]} &quot;software-properties-common&quot;})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- package-source-apt
  [session name &amp; {:keys [apt aptitude yum] :as options}]
  (checked-commands
   &quot;Package source&quot;
   (let [^String key-url (or (:url aptitude) (:url apt))]
     (if (and key-url (.startsWith key-url &quot;ppa:&quot;))
       (let [list-file (str
                        (string/replace (subs key-url 4) &quot;/&quot; &quot;-&quot;)
                        &quot;-&quot;
                        (fragment (lib/os-version-name))
                        &quot;.list&quot;)]
         (stevedore/chain-commands
          (if-let [package (os-map-lookup @ubuntu-ppa-add)]
            (stevedore/script
             (chain-and
              (&quot;apt-cache&quot; show ~package &quot;&gt;&quot; &quot;/dev/null&quot;) ; fail if unavailable
              (~lib/install-package ~package))))
          (stevedore/script
           (when (not (file-exists? (lib/file &quot;/etc/apt/sources.list.d&quot;
                                              ~list-file)))
             (chain-and
              (pipe (println ) (&quot;add-apt-repository&quot; ~key-url))
              (~lib/update-package-list))))))
       (-&gt;
        (remote-file*
         session
         (format (source-location :apt) name)
         {:content (format-source
                    :apt name (or (:apt options) (:aptitude options)))
          :flag-on-changed package-source-changed-flag})
        first second)))
   (if-let [key-id (or (:key-id aptitude) (:key-id apt))]
     (let [key-server (or (:key-server aptitude) (:key-server apt)
                          *default-apt-keyserver*)]
       (stevedore/script
        (&quot;apt-key&quot;
         adv
         &quot;--keyserver&quot; ~key-server
         &quot;--recv-keys&quot; ~key-id))))
   (if-let [key-url (or (:key-url aptitude) (:key-url apt))]
     (stevedore/chain-commands
      (-&gt;
       (remote-file*
        session &quot;aptkey.tmp&quot;
        {:url key-url :flag-on-changed package-source-changed-flag})
       first second)
      (stevedore/script (&quot;apt-key&quot; add aptkey.tmp))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-source* :aptitude
  [session name &amp; {:keys [apt aptitude yum] :as options}]
  (apply-map package-source-apt session name options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-source* :apt
  [session name &amp; {:keys [apt aptitude yum] :as options}]
  (apply-map package-source-apt session name options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-source* :yum
  [session name &amp; {:keys [apt aptitude yum] :as options}]
  (let [packager (packager session)]
    (checked-commands
     &quot;Package source&quot;
     (-&gt;
      (remote-file*
       session
       (format (source-location packager) name)
       {:content (format-source packager name (packager options))
        :literal true
        :flag-on-changed package-source-changed-flag})
      first second)
     (when-let [key (and (= packager :yum) (:gpgkey yum))]
       (stevedore/script (&quot;rpm&quot; &quot;--import&quot; ~key))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-source* :default
  [session name &amp; {:as options}]
  (let [packager (packager session)]
    (checked-commands
     &quot;Package source&quot;
     (-&gt;
      (remote-file*
       session
       (format (source-location packager) name)
       {:content (format-source packager name (packager options))
        :flag-on-changed package-source-changed-flag})
      first second))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action package-source :direct
  &quot;Control package sources.
   Options are the package manager keywords, each specifying a map of
   packager specific options.

   :aptitude
     - :source-type string   - source type (deb)
     - :url url              - repository url
     - :scopes seq           - scopes to enable for repository
     - :key-url url          - url for key
     - :key-id id            - id for key to look it up from keyserver
     - :key-server           - the hostname of the key server to lookup keys

   :yum
     - :name                 - repository name
     - :url url          - repository base url
     - :gpgkey url           - gpg key url for repository

   Example
       (package-source \&quot;Partner\&quot;
         :aptitude {:url \&quot;http://archive.canonical.com/\&quot;
                    :scopes [\&quot;partner\&quot;]})&quot;
  {:action-type :script :location :target}
  [session &amp; args]
  [[{:language :bash
     :summary (str &quot;package-source &quot; (string/join &quot; &quot; (map vec args)))}
    (stevedore/do-script*
     (map (fn [x] (apply package-source* session x)) args))]
   session])</pre></td></tr><tr><td class="docs"><p>Add a scope to all the existing package sources. Aptitude specific.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-scope*
  [type scope file]
  (stevedore/chained-script
   (var tmpfile @(&quot;mktemp&quot; -t addscopeXXXX))
   (~lib/cp ~file @tmpfile :preserve true)
   (&quot;awk&quot; &quot;'{if ($1 ~&quot; ~(str &quot;/^&quot; type &quot;/&quot;) &quot;&amp;&amp; !&quot; ~(str &quot;/&quot; scope &quot;/&quot;)
        &quot; ) print $0 \&quot; \&quot; \&quot;&quot; ~scope  &quot;\&quot; ; else print; }'&quot;
        ~file &gt; @tmpfile)
   (~lib/mv @tmpfile ~file :force ~true)))</pre></td></tr><tr><td class="docs"><p>Add a scope to an apt source</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-scope
  [opts]
  (add-scope*
   (or (opts :type) &quot;deb.*&quot;)
   (:scope opts)
   (or (opts :file) &quot;/etc/apt/sources.list&quot;)))</pre></td></tr><tr><td class="docs"><p>Configure the package manager</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti configure-package-manager
  (fn [session packager options] packager))</pre></td></tr><tr><td class="docs"><p>Provide packager specific options</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti package-manager-option
  (fn [session packager option value] [packager option]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-manager-option [:aptitude :proxy]
  [session packager proxy proxy-url]
  (format &quot;ACQUIRE::http::proxy \&quot;%s\&quot;;&quot; proxy-url))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-manager-option [:apt :proxy]
  [session packager proxy proxy-url]
  (package-manager-option session :aptitude proxy proxy-url))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-manager-option [:yum :proxy]
  [session packager proxy proxy-url]
  (format &quot;proxy=%s&quot; proxy-url))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-manager-option [:pacman :proxy]
  [session packager proxy proxy-url]
  (format
   (str &quot;XferCommand = /usr/bin/wget &quot;
        &quot;-e \&quot;http_proxy = %s\&quot; -e \&quot;ftp_proxy = %s\&quot; &quot;
        &quot;--passive-ftp --no-verbose -c -O %%o %%u&quot;)
   proxy-url proxy-url))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-installonlypkgs
  (str &quot;kernel kernel-smp kernel-bigmem kernel-enterprise kernel-debug &quot;
       &quot;kernel-unsupported&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod package-manager-option [:yum :installonlypkgs]
  [session packager installonly packages]
  (format
   &quot;installonlypkgs=%s %s&quot; (string/join &quot; &quot; packages) default-installonlypkgs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configure-package-manager :aptitude
  [session packager {:keys [priority prox] :or {priority 50} :as options}]
  (-&gt;
   (remote-file*
    session
    (format &quot;/etc/apt/apt.conf.d/%spallet&quot; priority)
    {:content (string/join
               \newline
               (map
                #(package-manager-option session packager (key %) (val %))
                (dissoc options :priority)))
     :literal true})
   first second))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configure-package-manager :apt
  [session packager {:as options}]
  (configure-package-manager session :aptitude options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configure-package-manager :yum
  [session packager {:keys [proxy] :as options}]
  (stevedore/chain-commands
   (-&gt;
    (remote-file*
     session
     &quot;/etc/yum.pallet.conf&quot;
     {:content (string/join
                \newline
                (map
                 #(package-manager-option session packager (key %) (val %))
                 (dissoc options :priority)))
      :literal true})
    first second)
   ;; include yum.pallet.conf from yum.conf
   (stevedore/script
    (if (not @(&quot;fgrep&quot; &quot;yum.pallet.conf&quot; &quot;/etc/yum.conf&quot;))
      (do
        (&quot;cat&quot; &quot;&gt;&gt;&quot; &quot;/etc/yum.conf&quot; &quot; &lt;&lt;'EOFpallet'&quot;)
        &quot;include=file:///etc/yum.pallet.conf&quot;
        &quot;EOFpallet&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configure-package-manager :pacman
  [session packager {:keys [proxy] :as options}]
  (stevedore/chain-commands
   (-&gt;
    (remote-file*
     session
     &quot;/etc/pacman.pallet.conf&quot;
     {:content (string/join
                \newline
                (map
                 #(package-manager-option session packager (key %) (val %))
                 (dissoc options :priority)))
      :literal true})
    first second)
   ;; include pacman.pallet.conf from pacman.conf
   (stevedore/script
    (if (not @(&quot;fgrep&quot; &quot;pacman.pallet.conf&quot; &quot;/etc/pacman.conf&quot;))
      (do
        ~(-&gt; (sed*
              session
              &quot;/etc/pacman.conf&quot;
              &quot;a Include = /etc/pacman.pallet.conf&quot;
              :restriction &quot;/\\[options\\]/&quot;)
             first second))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configure-package-manager :default
  [session packager {:as options}]
  (comment &quot;do nothing&quot;))</pre></td></tr><tr><td class="docs"><p>Package management.</p>
</td><td class="codes"><pre class="brush: clojure">(defn package-manager*
  [session action &amp; options]
  (let [packager (packager session)]
    (checked-commands
     (format &quot;package-manager %s %s&quot; (name action) (string/join &quot; &quot; options))
     (case action
       :update (stevedore/script (apply ~lib/update-package-list ~options))
       :upgrade (stevedore/script (~lib/upgrade-all-packages))
       :list-installed (stevedore/script (~lib/list-installed-packages))
       :add-scope (add-scope (apply hash-map options))
       :multiverse (add-scope (apply hash-map :scope &quot;multiverse&quot; options))
       :universe (add-scope (apply hash-map :scope &quot;universe&quot; options))
       :debconf (if (#{:aptitude :apt} packager)
                  (stevedore/script
                   (apply ~lib/debconf-set-selections ~options)))
       :configure (configure-package-manager session packager options)
       (throw (IllegalArgumentException.
               (str action
                    &quot; is not a valid action for package-manager action&quot;)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action package-manager :direct
  &quot;Package manager controls.

   `action` is one of the following:
   - :update          - update the list of available packages
   - :list-installed  - output a list of the installed packages
   - :add-scope       - enable a scope (eg. multiverse, non-free)

   To refresh the list of packages known to the pakage manager:
       (package-manager session :update)

   To enable multiverse on ubuntu:
       (package-manager session :add-scope :scope :multiverse)

   To enable non-free on debian:
       (package-manager session :add-scope :scope :non-free)&quot;
  {:action-type :script :location :target}
  [session &amp; package-manager-args]
  (logging/tracef &quot;package-manager-args %s&quot; (vec package-manager-args))
  [[{:language :bash
     :summary (str &quot;package-manager &quot;
                   (string/join &quot; &quot; (distinct (map vec package-manager-args))))}
    (stevedore/do-script*
     (map #(apply package-manager* session %) (distinct package-manager-args)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action add-rpm :direct
  &quot;Add an rpm.  Source options are as for remote file.&quot;
  {:action-type :script :location :target}
  [session rpm-name &amp; {:as options}]
  [[{:language :bash}
    (stevedore/do-script
     (-&gt; (remote-file*
          session rpm-name
          (merge
           {:install-new-files pallet.actions-impl/*install-new-files*
            :overwrite-changes pallet.actions-impl/*force-overwrite*}
           options))
         first second)
     (checked-script
      (format &quot;Install rpm %s&quot; rpm-name)
      (if-not (&quot;rpm&quot; -q @(&quot;rpm&quot; -pq ~rpm-name) &gt; &quot;/dev/null&quot; &quot;2&gt;&amp;1&quot;)
        (do (&quot;rpm&quot; -U --quiet ~rpm-name)))))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action install-deb :direct
  &quot;Install a deb file.  Source options are as for remote file.&quot;
  {:action-type :script :location :target}
  [session deb-name &amp; {:as options}]
  [[{:language :bash}
    (stevedore/do-script
     (-&gt; (remote-file*
          session deb-name
          (merge
           {:install-new-files pallet.actions-impl/*install-new-files*
            :overwrite-changes pallet.actions-impl/*force-overwrite*}
           options))
         first second)
     (checked-script
      (format &quot;Install deb %s&quot; deb-name)
      (&quot;dpkg&quot; -i --skip-same-version ~deb-name)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action debconf-set-selections :direct
  &quot;Set debconf selections.
Specify :line, or the other options.&quot;
  {:action-type :script :location :target}
  [session {:keys [line package question type value]}]
  {:pre [(or line (and package question type (not (nil? value))))]}
  [[{:language :bash}
    (stevedore/do-script
     (checked-script
      (format &quot;Preseed %s&quot;
              (or line (string/join &quot; &quot; [package question type value])))
      (pipe
       (println
        (quoted ~@(if line
                    [line]
                    [(name package) question (name type) (pr-str value)])))
       (&quot;/usr/bin/debconf-set-selections&quot;))))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action minimal-packages :direct
  &quot;Add minimal packages for pallet to function&quot;
  {:action-type :script :location :target}
  [session]
  (let [os-family (os-family session)]
    [[{:language :bash}
      (cond
        (#{:ubuntu :debian} os-family) (checked-script
                                        &quot;Add minimal packages&quot;
                                        (~lib/update-package-list)
                                        (~lib/install-package &quot;coreutils&quot;)
                                        (~lib/install-package &quot;sudo&quot;))
        (= :arch os-family) (checked-script
                             &quot;Add minimal packages&quot;
                             (&quot;{&quot; (chain-or pacman-db-upgrade true) &quot;; } &quot;
                              &quot;2&gt; /dev/null&quot;)
                             (~lib/update-package-list)
                             (~lib/upgrade-package &quot;pacman&quot;)
                             (println &quot;  checking for pacman-db-upgrade&quot;)
                             (&quot;{&quot; (chain-or (chain-and
                                             pacman-db-upgrade
                                             (~lib/update-package-list))
                                            true) &quot;; } &quot;
                              &quot;2&gt; /dev/null&quot;)
                             (~lib/install-package &quot;sudo&quot;)))]
     session]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.remote-directory" name="pallet.actions.direct.remote-directory"><h1 class="project-name">pallet.actions.direct.remote-directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Action to specify the content of a remote directory.  At present the
   content can come from a downloaded tar or zip file.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.remote-directory
  (:require
   [clojure.string :as string]
   [pallet.action :refer [action-fn implement-action]]
   [pallet.action-plan :refer [checked-commands]]
   [pallet.actions :refer [directory]]
   [pallet.actions-impl
    :refer [md5-filename
            new-filename
            remote-directory-action
            remote-file-action]]
   [pallet.actions.direct.remote-file :refer [file-uploader]]
   [pallet.core.file-upload :refer [upload-file-path]]
   [pallet.script.lib :as lib :refer [user-default-group]]
   [pallet.stevedore :as stevedore :refer [fragment]]
   [pallet.stevedore :refer [with-source-line-comments]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require 'pallet.actions.direct.directory)
(require 'pallet.actions.direct.remote-file)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
  directory* (action-fn directory :direct))
(def ^{:private true}
  remote-file* (action-fn remote-file-action :direct))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- source-to-cmd-and-path
  [session path url local-file remote-file md5 md5-url
   install-new-files overwrite-changes upload-path]
  (cond
   url (let [tarpath (str
                      (with-source-line-comments false
                        (stevedore/script (~lib/tmp-dir))) &quot;/&quot;
                      (.getName
                       (java.io.File. (.getFile (java.net.URL. url)))))]
         [(-&gt;
           (remote-file* session tarpath
                         {:url url :md5 md5 :md5-url md5-url
                          :install-new-files install-new-files
                          :overwrite-changes overwrite-changes})
           first second)
          tarpath])
   local-file [
               upload-path
               (md5-filename session (-&gt; session :action :script-dir) path)]
   remote-file [ remote-file (str remote-file &quot;.md5&quot;)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action remote-directory-action :direct
  {:action-type :script :location :target}
  [session path {:keys [action url local-file remote-file
                        unpack tar-options unzip-options jar-options
                        strip-components md5 md5-url owner group recursive
                        install-new-files overwrite-changes extract-files]
                 :or {action :create
                      tar-options &quot;xz&quot;
                      unzip-options &quot;-o&quot;
                      jar-options &quot;xf&quot;
                      strip-components 1
                      recursive true
                      install-new-files true}
                 :as options}]
  [[{:language :bash}
    (case action
      :create (let [uploader (file-uploader options)
                    url (options :url)
                    unpack (options :unpack :tar)
                    upload-path (upload-file-path uploader session path options)
                    options (if (and owner (not group))
                              (assoc options
                                :group (fragment @(user-default-group ~owner)))
                              options)]
                (when (and (or url local-file remote-file) unpack)
                  (let [[cmd tarpath tar-md5] (source-to-cmd-and-path
                                               session path
                                               url local-file remote-file
                                               md5 md5-url
                                               install-new-files
                                               overwrite-changes
                                               upload-path)
                        tar-md5 (str tarpath &quot;.md5&quot;)
                        path-md5 (str path &quot;/.pallet.directory.md5&quot;)
                        extract-files (string/join \space extract-files)]
                    (checked-commands
                     &quot;remote-directory&quot;
                     (-&gt;
                      (directory*
                       session path :owner owner :group group :recursive false)
                      first second)
                     cmd
                     (stevedore/script
                      (when (or (not (file-exists? ~tar-md5))
                                (or (not (file-exists? ~path-md5))
                                    (not (&quot;diff&quot; ~tar-md5 ~path-md5))))
                        ~(condp = unpack
                          :tar (stevedore/checked-script
                                (format &quot;Untar %s&quot; tarpath)
                                (var rdf @(lib/canonical-path ~tarpath))
                                (&quot;cd&quot; ~path)
                                (&quot;tar&quot;
                                 ~tar-options
                                 ~(str &quot;--strip-components=&quot; strip-components)
                                 -f @rdf
                                 ~extract-files)
                                (&quot;cd&quot; -))
                          :unzip (stevedore/checked-script
                                  (format &quot;Unzip %s&quot; tarpath)
                                  (var rdf @(lib/canonical-path ~tarpath))
                                  (&quot;cd&quot; ~path)
                                  (&quot;unzip&quot; ~unzip-options @rdf ~extract-files)
                                  (&quot;cd&quot; -))
                          :jar (stevedore/checked-script
                                (format &quot;Unjar %s&quot; tarpath)
                                (var rdf @(lib/canonical-path ~tarpath))
                                (&quot;cd&quot; ~path)
                                (&quot;jar&quot; ~jar-options @rdf ~extract-files)
                                (&quot;cd&quot; -)))
                        (when (file-exists? ~tar-md5)
                          (&quot;cp&quot; ~tar-md5 ~path-md5))))
                     (if recursive
                       (-&gt;
                        (directory*
                         session path
                         :owner owner
                         :group group
                         :recursive recursive)
                        first second)))))))]
   session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.remote-file" name="pallet.actions.direct.remote-file"><h1 class="project-name">pallet.actions.direct.remote-file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Action to specify remote file content.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.remote-file
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]
   [pallet.action :refer [action-options implement-action]]
   [pallet.action-plan :as action-plan]
   [pallet.actions
    :refer [content-options
            delete-local-path
            transfer-file
            transfer-file-to-local
            wait-for-file]]
   [pallet.actions-impl
    :refer [copy-filename md5-filename new-filename upload-filename
            remote-file-action]]
   [pallet.actions.direct.file :as file]
   [pallet.blobstore :as blobstore]
   [pallet.core.file-upload
    :refer [upload-file upload-file-path user-file-path]]
   [pallet.core.session :refer [effective-username]]
   [pallet.environment-impl :refer [get-for]]
   [pallet.script.lib :as lib
    :refer [canonical-path chgrp chmod chown dirname exit mkdir
            path-group path-mode path-owner user-default-group]]
   [pallet.script.lib :refer [wait-while]]
   [pallet.ssh.file-upload.sftp-upload :refer [sftp-upload]]
   [pallet.ssh.node-state
    :refer [new-file-content record-checksum verify-checksum]]
   [pallet.ssh.node-state.state-root
    :refer [state-root-backup state-root-checksum]]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [fragment script]]
   [pallet.template :as templates]
   [pallet.utils :refer [first-line]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-file-uploader (sftp-upload {}))
(def default-checksum (state-root-checksum {}))
(def default-backup (state-root-backup {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn file-uploader
  [action-options]
  (or (:file-uploader action-options) default-file-uploader))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action delete-local-path :direct
                  {:action-type :fn/clojure :location :origin}
                  [session ^java.io.File local-path]
  [(fn [session]
     (.delete (io/file local-path))
     [local-path session])
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action transfer-file-to-local :direct
                  {:action-type :transfer/to-local :location :origin}
                  [session remote-path local-path]
  [[(.getPath (io/file remote-path))
    (.getPath (io/file local-path))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action transfer-file :direct
                  {:action-type :transfer/from-local :location :origin}
                  [session local-path remote-path]
  [[(.getPath (io/file local-path))
    (.getPath (io/file remote-path))
    (fn []
      ;; return function that will do the upload
      (let [action-options (action-options session)
            uploader (or (:file-uploader action-options)
                         default-file-uploader)]
        (upload-file uploader session
                     (.getPath (io/file local-path))
                     (.getPath (io/file remote-path))
                     action-options)))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- summarise-content
  [m]
  (if (:content m)
    (update-in m [:content] #(str (first-line %) &quot;...&quot;))
    m))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action remote-file-action :direct
                  {:action-type :script :location :target}
                  [session path {:keys [action url local-file remote-file link
                                        content literal
                                        template values
                                        md5 md5-url
                                        owner group mode force
                                        blob blobstore
                                        install-new-files
                                        overwrite-changes
                                        no-versioning max-versions
                                        flag-on-changed
                                        force
                                        insecure
                                        verify]
                                 :or {action :create max-versions 5
                                      install-new-files true}
                                 :as options}]
  [[{:language :bash
     :summary (str &quot;remote-file &quot; path &quot; &quot;
                   (string/join
                    &quot; &quot;
                    (-&gt;&gt; (select-keys options content-options)
                         (summarise-content)
                         (apply concat)
                         (map pr-str))))}
    (let [action-options (action-options session)
          uploader (file-uploader action-options)
          file-checksum (or (:file-checksum action-options) default-checksum)
          file-backup (or (:file-backup action-options) default-backup)

          new-path (if local-file
                     (upload-file-path uploader session path action-options)
                     (user-file-path uploader session path action-options
                                     (effective-username session)))
          md5-path (str new-path &quot;.md5&quot;)

          proxy (get-for session [:proxy] nil)
          options (if (and owner (not group))
                    (assoc options
                      :group (fragment @(user-default-group ~owner)))
                    options)]
      (case action
        :create
        (action-plan/checked-commands
         (str &quot;remote-file &quot; path)

         ;; check for local modifications
         (if overwrite-changes
           &quot;&quot;
           (verify-checksum file-checksum session path))

         ;; create upload dir if needed
         (stevedore/script
          (mkdir @(dirname ~new-path) :path true))

         ;; Create the new content
         (cond
          (and url md5) (stevedore/chained-script
                         (if (chain-or (not (file-exists? ~path))
                                       (!= ~md5 @((pipe
                                                   (~lib/md5sum ~path)
                                                   (~lib/cut &quot;&quot;
                                                             :fields 1
                                                             :delimiter &quot; &quot;)))))
                           ~(stevedore/chained-script
                             (~lib/download-file
                              ~url ~new-path
                              :proxy ~proxy :insecure ~insecure))))
          ;; Download md5 to temporary directory.
          (and url md5-url) (stevedore/chained-script
                             (var tmpdir (quoted (lib/make-temp-dir &quot;rf&quot;)))
                             (var basefile
                                  (quoted
                                   (str @tmpdir &quot;/&quot; @(lib/basename ~path))))
                             (var newmd5path (quoted (str @basefile &quot;.md5&quot;)))
                             (lib/download-file
                              ~md5-url @newmd5path :proxy ~proxy
                              :insecure ~insecure)
                             (lib/normalise-md5 @newmd5path)
                             (if (chain-or (not (file-exists? ~md5-path))
                                           (not (lib/diff @newmd5path ~md5-path)))
                               (do
                                 (lib/download-file
                                  ~url ~new-path :proxy ~proxy
                                  :insecure ~insecure)
                                 (lib/ln ~new-path @basefile)
                                 (if-not (~lib/md5sum-verify @newmd5path)
                                   (do
                                     (println ~(str &quot;Download of &quot; url
                                                    &quot; failed to match md5&quot;))
                                     (lib/rm @tmpdir
                                             :force ~true :recursive ~true)
                                     (lib/exit 1)))))
                             (lib/rm @tmpdir :force ~true :recursive ~true))
          url (stevedore/chained-script
               (~lib/download-file
                ~url ~new-path :proxy ~proxy :insecure ~insecure))
          content (stevedore/script
                   (~lib/heredoc
                    ~new-path ~content ~(select-keys options [:literal])))
          local-file (do)               ; file already in place at new-path
          remote-file (stevedore/script
                       (~lib/cp ~remote-file ~new-path :force ~true))
          template (stevedore/script
                    (~lib/heredoc
                     ~new-path
                     ~(templates/interpolate-template
                       template (or values {}) session)
                     ~(select-keys options [:literal])))
          link (stevedore/script
                (~lib/ln ~link ~path :force ~true :symbolic ~true))
          blob (action-plan/checked-script
                &quot;Download blob&quot;
                (~lib/download-request
                 ~new-path
                 ~(blobstore/sign-blob-request
                   (or blobstore (get-for session [:blobstore] nil)
                       (throw (IllegalArgumentException.
                               &quot;No :blobstore given for blob content.&quot;) ))
                   (:container blob) (:path blob)
                   {:method :get})))
          :else (throw
                 (IllegalArgumentException.
                  (str &quot;remote-file &quot; path &quot; specified without content.&quot;))))

         ;; process the new file accordingly
         (when verify
           (stevedore/checked-script
            (str &quot;Verify &quot; new-path &quot; with &quot; verify)
            (~verify ~new-path)))

         (when (and install-new-files (not link))
           (stevedore/chained-script
            ;; get the diff between current and new
            (var contentdiff &quot;&quot;)
            (if (&amp;&amp; (file-exists? ~path) (file-exists? ~new-path))
              (do
                (~lib/diff ~path ~new-path :unified true)
                (set! contentdiff &quot;$?&quot;)))

            ;; install the file if the content is different
            (if (&amp;&amp; (not (== @contentdiff 0)) (file-exists? ~new-path))
              ~(stevedore/chain-commands
                ;; adjust ownership/permissions before putting the
                ;; file in place
                (file/adjust-file new-path options)
                (script (lib/mv ~new-path ~path :force ~true))
                (if flag-on-changed
                  (script (lib/set-flag ~flag-on-changed)))
                (new-file-content
                 file-backup session path
                 (select-keys
                  options [:max-versions :no-versioning :versioning]))
                (record-checksum file-checksum session path))))))

        :delete (action-plan/checked-script
                 (str &quot;delete remote-file &quot; path)
                 (~lib/rm ~path :force ~force))))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action wait-for-file :direct
  {:action-type :script :location :target}
  [session path &amp; {:keys [action max-retries standoff service-name]
                   :or {action :create
                        max-retries 5 standoff 2}
                   :as options}]
  [[{:language :bash}
    (let [[test-expr waiting-msg failed-msg]
          (case action
            :create [(fragment (not (file-exists? ~path)))
                     (str &quot;Waiting for &quot; path &quot; to exist&quot;)
                     (str &quot;Failed waiting for &quot; path &quot; to exist&quot;)]
            :remove [(fragment (file-exists? ~path))
                     (str &quot;Waiting for &quot; path &quot; to be removed&quot;)
                     (str &quot;Failed waiting for &quot; path &quot; to be removed&quot;)])]
      (wait-while test-expr standoff max-retries waiting-msg failed-msg))]
   session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.retry" name="pallet.actions.direct.retry"><h1 class="project-name">pallet.actions.direct.retry</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides an action that can be repeated if it fails</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.retry)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.rsync" name="pallet.actions.direct.rsync"><h1 class="project-name">pallet.actions.direct.rsync</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.rsync
  (:require
   [clojure.tools.logging :as logging]
   [pallet.action :refer [action-options implement-action]]
   [pallet.actions :refer [rsync rsync-to-local]]
   [pallet.crate :refer [target-node]]
   [pallet.core.session :refer [admin-user target-ip]]
   [pallet.node :refer [ssh-port]]
   [pallet.script.lib :refer [sudo]]
   [pallet.stevedore :as stevedore :refer [fragment]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
  cmd &quot;/usr/bin/rsync -e '%s' -F -F %s %s %s@%s:%s&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
  cmd-to-local &quot;/usr/bin/rsync -e '%s' -F -F %s '%s@%s:%s' %s&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rsync-sudo-user [session]
  (let [user (:user session)]
    (or (:sudo-user (action-options session))
        (and (not (:no-sudo user))
             (or (:sudo-user user)
                 &quot;root&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn default-options
  [session]
  {:r true :delete true :copy-links true
   :rsync-path (if-let [sudo-user (rsync-sudo-user session)]
                 (fragment ((sudo :no-prompt true :user ~sudo-user) &quot;rsync&quot;))
                 &quot;rsync&quot;)
   :owner true
   :perms true})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rsync-command
  [from to username address port options]
  (let [ssh (str &quot;/usr/bin/ssh -o \&quot;StrictHostKeyChecking no\&quot; &quot;
                 (if port (format &quot;-p %s&quot; port))) ]
    (format
     cmd ssh
     (stevedore/map-to-arg-string options)
     from username
     address to)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action rsync :direct
                  {:action-type :script :location :origin}
                  [session from to {:keys [port] :as options}]
  (logging/debugf &quot;rsync %s to %s&quot; from to)
  (let [extra-options (dissoc options :port)
        port (or port (ssh-port (target-node)))
        cmd (rsync-command
             from to
             (:username (admin-user session))
             (target-ip session)
             port
             (merge (default-options session) extra-options))]
    (logging/debugf &quot;rsync %s&quot; cmd)
    [[{:language :bash}
      (stevedore/checked-commands (format &quot;rsync %s to %s&quot; from to) cmd)]
     session]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action rsync-to-local :direct
                  {:action-type :script :location :origin}
                  [session from to {:keys [port] :as options}]
  (logging/debugf &quot;rsync %s to %s&quot; from to)
  (let [extra-options (dissoc options :port)
        ssh (str &quot;/usr/bin/ssh -o \&quot;StrictHostKeyChecking no\&quot; &quot;
                 (if-let [port (or port (ssh-port (target-node)))]
                   (format &quot;-p %s&quot; port)))
        cmd (format
             cmd-to-local ssh
             (stevedore/map-to-arg-string
              (merge (default-options session) {:delete false} extra-options))
             (:username (admin-user session))
             (target-ip session)
             from
             to)]
    (logging/debugf &quot;rsync-to-local %s&quot; cmd)
    [[{:language :bash}
      (stevedore/checked-commands (format &quot;rsync %s to %s&quot; from to) cmd)]
     session]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.service" name="pallet.actions.direct.service"><h1 class="project-name">pallet.actions.direct.service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Service control. Deprecated in favour of pallet.crate.service.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.service
  (:require
   [pallet.action :refer [implement-action]]
   [pallet.actions :refer [service]]
   [pallet.actions-impl :refer [init-script-path]]
   [pallet.script.lib :as lib]
   [pallet.action-plan :as action-plan]
   [pallet.stevedore :as stevedore]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti service-impl
  (fn [session service-name &amp; {:keys [action if-flag if-stopped
                                      service-impl]
                               :or {action :start service-impl :initd}
                               :as options}]
    service-impl))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-impl :initd
  [session service-name &amp; {:keys [action if-stopped
                                  service-impl]
                           :or {action :start}
                           :as options}]
  (if (#{:enable :disable :start-stop} action)
    (stevedore/checked-script
     (format &quot;Configure service %s&quot; service-name)
     (~lib/configure-service ~service-name ~action ~options))
    (if if-stopped
      (stevedore/script
       (println ~(name action) ~service-name &quot;if stopped&quot;)
       (if-not (~(init-script-path service-name) status)
         (~(init-script-path service-name) ~(name action))))
      (stevedore/script
       (println ~(name action) ~service-name)
       (~(init-script-path service-name) ~(name action))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-impl :upstart
  [session service-name &amp; {:keys [action if-flag if-stopped
                                  service-impl]
                           :or {action :start}
                           :as options}]
  (if (#{:enable :disable :start-stop} action)
      (action-plan/checked-script
       (format &quot;Configure service %s&quot; service-name)
       (~lib/configure-service ~service-name ~action ~options))
      (if if-flag
        (stevedore/script
         (println ~(name action) ~service-name &quot;if config changed&quot;)
         (if (== &quot;1&quot; (~lib/flag? ~if-flag))
           (&quot;service&quot; ~service-name ~(name action))))
        (if if-stopped
          (stevedore/script
           (println ~(name action) ~service-name &quot;if stopped&quot;)
           (if-not (&quot;service&quot; ~service-name status)
             (&quot;service&quot; ~service-name ~(name action))))
          (stevedore/script
           (println ~(name action) ~service-name)
           (&quot;service&quot; ~service-name ~(name action)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action service :direct
  {:action-type :script :location :target}
  [session service-name &amp; {:as options}]
  [[{:language :bash}
    (apply-map service-impl session service-name options)]
   session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.settings" name="pallet.actions.direct.settings"><h1 class="project-name">pallet.actions.direct.settings</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.settings
  (:require
   [pallet.action :refer [implement-action]]
   [pallet.actions :refer [assoc-in-settings assoc-settings update-settings]]
   [pallet.core.plan-state :as plan-state]
   [pallet.core.session :as session]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action assoc-settings :direct
  {:action-type :fn/clojure :location :origin}
  [session facility kv-pairs &amp; {:keys [instance-id] :as options}]
  [(fn [session]
     [kv-pairs (update-in
                session [:plan-state]
                plan-state/assoc-settings
                (session/target-id session) facility kv-pairs options)])
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action assoc-in-settings :direct
  {:action-type :fn/clojure :location :origin}
  [session [facility &amp; path] value &amp; {:keys [instance-id] :as options}]
  [(fn [session]
     [value (update-in
             session [:plan-state]
             plan-state/update-settings
             (session/target-id session) facility assoc-in [path value]
             options)])
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action update-settings :direct
  {:action-type :fn/clojure :location :origin}
  [session facility options &amp; args]
  (clojure.tools.logging/warnf
   &quot;facility %s options %s args %s&quot;
   facility options (vec args))
  (let [[options f args] (if (or (nil? options) (map? options))
                           [options (first args) (rest args)]
                           [{} options args])]
    (assert f &quot;Must supply a function&quot;)
    [(fn [session]
       [[f args] (update-in
                  session [:plan-state]
                  plan-state/update-settings
                  (session/target-id session) facility f args options)])
     session]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions.direct.user" name="pallet.actions.direct.user"><h1 class="project-name">pallet.actions.direct.user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>User management action.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions.direct.user
  (:require
   [clojure.string :as string]
   [pallet.action :refer [implement-action]]
   [pallet.actions :refer [group user]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]))</pre></td></tr><tr><td class="docs"><p>Map for looking up shell path based on keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  ^{:doc  :private true}
  shell-names
  {:bash &quot;/bin/bash&quot; :csh &quot;/bin/csh&quot; :ksh &quot;/bin/ksh&quot; :rsh &quot;/bin/rsh&quot;
   :sh &quot;/bin/sh&quot; :tcsh &quot;/bin/tcsh&quot; :zsh &quot;/bin/zsh&quot; :false &quot;/bin/false&quot;})</pre></td></tr><tr><td class="docs"><p>Require a user</p>
</td><td class="codes"><pre class="brush: clojure">(defn user*
  [session username &amp; {:keys [action shell base-dir home system create-home
                              password shell comment groups remove force append]
                       :or {action :manage}
                       :as options}]
  {:pre [(string? username)]}
  (let [opts (if-let [shell (get shell-names shell shell)]
               (merge options {:shell shell})
               options)]
    (case action
      :create
      (stevedore/script
       (if-not (~lib/user-exists? ~username)
         (~lib/create-user
          ~username ~(select-keys opts [:base-dir :home :system :comment
                                        :create-home :password :shell
                                        :group :groups]))))
      :manage
      (let [mod-keys (select-keys opts [:home :shell :comment :group :groups
                                        :password :append])]
        (stevedore/script
         (if (~lib/user-exists? ~username)
           ~(if (seq mod-keys)
              (stevedore/script (~lib/modify-user ~username ~mod-keys))
              &quot;:&quot;)
           (~lib/create-user
            ~username ~(select-keys opts [:base-dir :home :system :comment
                                          :create-home :password :shell
                                          :group :groups])))))
      :lock
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/lock-user ~username)))
      :unlock
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/unlock-user ~username)))
      :remove
      (stevedore/script
       (if (~lib/user-exists? ~username)
         (~lib/remove-user ~username ~(select-keys opts [:remove :force]))))
      (throw (IllegalArgumentException.
              (str action &quot; is not a valid action for user action&quot;))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action user :direct
  {:action-type :script :location :target}
  [session &amp; user-args]
  [[{:language :bash}
    (string/join \newline (map #(apply user* session %) user-args))]
   session])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(implement-action group :direct
  {:action-type :script :location :target}
  [session groupname &amp; {:keys [action system gid password]
                        :or {action :manage}
                        :as options}]
  [[{:language :bash}
    (case action
      :create
      (stevedore/script
       (if-not (~lib/group-exists? ~groupname)
         (~lib/create-group
          ~groupname ~(select-keys options [:system :gid :password]))))
      :manage
      (stevedore/script
       (if (~lib/group-exists? ~groupname)
         (~lib/modify-group
          ~groupname ~(select-keys options [:gid :password]))
         (~lib/create-group
          ~groupname ~(select-keys options [:system :gid :password]))))
      :remove
      (stevedore/script
       (if (~lib/group-exists? ~groupname)
         (~lib/remove-group ~groupname {})))
      (throw (IllegalArgumentException.
              (str action &quot; is not a valid action for group action&quot;))))]
   session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.actions-impl" name="pallet.actions-impl"><h1 class="project-name">pallet.actions-impl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation namespace for Pallet's action primitives.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.actions-impl
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]
   [pallet.action :refer [defaction]]
   [pallet.common.context :refer [throw-map]]
   [pallet.context :as context]
   [pallet.core.session :as session :refer [session]]
   [pallet.crate :refer [admin-user]]
   [pallet.script.lib :as lib]
   [pallet.script.lib :refer [file state-root user-home]]
   [pallet.stevedore :refer [fragment script]]
   [pallet.utils :refer [base64-md5]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *script-location-info* true)</pre></td></tr><tr><td class="docs"><p>An 'if' flow control action, that claims the next (up to two) nested scopes.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction if-action
  [condition])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn verify-local-file-exists
  [local-file]
  (when-let [^java.io.File f (and local-file (io/file local-file))]
    (when (not (and (.exists f) (.isFile f) (.canRead f)))
      (throw-map
       (format
               (str &quot;'%s' does not exist, is a directory, or is unreadable; &quot;
                    &quot;cannot register it for transfer.&quot;)
               local-file)
       {:local-file local-file}))))</pre></td></tr><tr><td class="docs"><p>Var to control installation of new file content on remote nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :dynamic true}
  *install-new-files* true)</pre></td></tr><tr><td class="docs"><p>Var to control overwriting of modified file content on remote
             nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :dynamic true}
  *force-overwrite* false)</pre></td></tr><tr><td class="docs"><p>An action that implements most of remote-file, but requires a helper in order
to deal with local file transfer.</p>
</td><td class="codes"><pre class="brush: clojure">(defaction remote-file-action
  [path {:keys [action url local-file
                remote-file link content literal template values md5 md5-url
                owner group mode force blob blobstore overwrite-changes
                install-new-files no-versioning max-versions
                flag-on-changed force insecure]
         :or {action :create max-versions 5}
         :as options}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defaction remote-directory-action
  [path {:keys [action url local-file remote-file
                unpack tar-options unzip-options jar-options
                strip-components md5 md5-url owner group recursive]
         :or {action :create
              tar-options &quot;xz&quot;
              unzip-options &quot;-o&quot;
              jar-options &quot;xf&quot;
              strip-components 1
              recursive true}
         :as options}])</pre></td></tr><tr><td class="docs"><p>Path to the specified initd script</p>
</td><td class="codes"><pre class="brush: clojure">(defn init-script-path
  [service-name]
  (str (script (~lib/etc-init)) &quot;/&quot; service-name))</pre></td></tr><tr><td class="docs"><h1>Service Supervision</h1>

<p>TODO - remove these</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti service-script-path
  (fn [service-impl service-name] service-impl))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-script-path :initd
  [_ service-name]
  (str (fragment (lib/etc-init)) &quot;/&quot; service-name))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-script-path :upstart
  [_ service-name]
  (str (fragment (lib/upstart-script-dir)) &quot;/&quot; service-name &quot;.conf&quot;))</pre></td></tr><tr><td class="docs"><h1>File Names for Pallet Internals</h1>
</td><td class="codes"><pre class="brush: clojure">(defn- adjust-root
  [^String script-dir ^String path]
  (if (or (.startsWith path &quot;/&quot;)
          (.startsWith path &quot;$&quot;))
    path
    (fragment
     (file ~(or script-dir
                ;; use /home so we have a path tha doesn't
                ;; involve shell vars
                (str &quot;/home/&quot; (:username (admin-user))))
           ~path))))</pre></td></tr><tr><td class="docs"><p>This is where pallet will keep backups and md5 files.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pallet-state-root
  [session]
  (or (:state-root (session/admin-user session))
      (fragment (file (state-root) &quot;pallet&quot;))))</pre></td></tr><tr><td class="docs"><h2>File Names for Transfers from localhost</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>These provide an upload path that will have ownership assigned
to the admin user, so that the admin user can always overwrite files
at these paths (ie. for re-upload).</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Generate a temporary file name for a given path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn upload-filename
  [session script-dir path]
  (str (pallet-state-root session)
       (adjust-root nil (base64-md5 path))))</pre></td></tr><tr><td class="docs"><p>(defn upload-md5-filename
  "Generate a temporary file name for a given path."
  [session script-dir path]
  (str (pallet-state-root session)
       (str "/home/" (:username (admin-user))) "/.pallet-uploads"
       (adjust-root script-dir path)
       ".md5"))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>File Names for Pallet State</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>These paths create a parallel directory tree under "/var/lib/pallet" which
contains the up/downloaded files, the md5s and the installed file history.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>To facilitate md5 checks the basename of the generated copy-filename should
match the original basename, and the md5 file should be in the same
directory.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Note that we can not use remote evaluated expressions in these paths, as
they are used locally.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Generate a temporary file name for a given path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn new-filename
  [session script-dir path]
  (str (pallet-state-root session) (adjust-root script-dir path) &quot;.new&quot;))</pre></td></tr><tr><td class="docs"><p>Generate a md5 file name for a given path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn md5-filename
  [session script-dir path]
  (str (pallet-state-root session) (adjust-root script-dir path) &quot;.md5&quot;))</pre></td></tr><tr><td class="docs"><p>Generate a file name for a copy of the given path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn copy-filename
  [session script-dir path]
  (str (pallet-state-root session) (adjust-root script-dir path)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.api" name="pallet.api"><h1 class="project-name">pallet.api</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Pallet API</h1>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.api
  (:require
   [clojure.java.io :refer [input-stream resource]]
   [clojure.pprint :refer [print-table]]
   [clojure.set :refer [union]]
   [clojure.string :refer [blank?]]
   [clojure.tools.logging :as logging]
   [pallet.action :refer [action-options-key]]
   [pallet.algo.fsmop :refer [dofsm operate result succeed]]
   [pallet.compute :as compute]
   [pallet.configure :as configure]
   [pallet.contracts
    :refer [check-converge-options
            check-group-spec
            check-lift-options
            check-node-spec
            check-server-spec
            check-user]]
   [pallet.core.api :refer [environment-image-execution-settings]]
   [pallet.core.api-impl
    :refer [merge-spec-algorithm merge-specs node-has-group-name?]]
   [pallet.core.operations :as ops]
   [pallet.core.primitives
    :refer [bootstrapped-meta execute-and-flag execute-on-unflagged
            phases-with-meta unbootstrapped-meta]]
   [pallet.core.session :refer [session-context]]
   [pallet.core.user :as user]
   [pallet.crate :refer [phase-context]]
   [pallet.crate.os :refer [os]]
   [pallet.environment :refer [group-with-environment merge-environments]]
   [pallet.node :refer [node-map node?]]
   [pallet.plugin :refer [load-plugins]]
   [pallet.thread-expr :refer [when-&gt;]]
   [pallet.utils :refer [apply-map maybe-update-in total-order-merge]]))</pre></td></tr><tr><td class="docs"><p>Returns the pallet version.</p>

<h2>Pallet version</h2>
</td><td class="codes"><pre class="brush: clojure">(let [v (atom nil)
      properties-path &quot;META-INF/maven/com.palletops/pallet/pom.properties&quot;]
  (defn version
    []
    (or
     @v
     (if-let [path (resource properties-path)]
       (with-open [in (input-stream path)]
         (let [properties (doto (java.util.Properties.) (.load in))]
           {:version (.getProperty properties &quot;version&quot;)
            :revision (.getProperty properties &quot;revision&quot;)}))
       {:version :unknown :revision :unknown}))))</pre></td></tr><tr><td class="docs"><h2>Domain Model</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Vector of keywords recognised by node-spec</p>

<h3>Node Spec</h3>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :private true}
  node-spec-keys [:image :hardware :location :network])</pre></td></tr><tr><td class="docs"><p>Create a node-spec.</p>

<p>   Defines the compute image and hardware selector template.</p>

<p>   This is used to filter a cloud provider's image and hardware list to select
   an image and hardware for nodes created for this node-spec.</p>

<p>   :image     a map describing a predicate for matching an image:
              os-family os-name-matches os-version-matches
              os-description-matches os-64-bit
              image-version-matches image-name-matches
              image-description-matches image-id</p>

<p>   :location  a map describing a predicate for matching location:
              location-id
   :hardware  a map describing a predicate for matching hardware:
              min-cores min-ram smallest fastest biggest architecture
              hardware-id
   :network   a map for network connectivity options:
              inbound-ports
   :qos       a map for quality of service options:
              spot-price enable-monitoring</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-spec
  [&amp; {:keys [image hardware location network qos] :as options}]
  {:pre [(or (nil? image) (map? image))]}
  (check-node-spec (vary-meta (or options {}) assoc :type ::node-spec)))</pre></td></tr><tr><td class="docs"><h3>Server Spec</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><h4>Phase Metadata</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Phase metadata is used to control how a phase is executed.  There are
currently two possible keys for the metadata attached to a plan function,
<code>:execution-settings-f</code> and <code>:phase-execution-f</code>.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Phase metadata is merged when phase functions are composed.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a metadata map that specifies a phase should be run using the image
credentials (rather than the admin-user).  The map is suitable for use as a
value in a map passed to the <code>:phases-meta</code> clause of a <code>server-spec</code> or
<code>group-spec</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-with-image-credentials-metadata
  []
  {:execution-settings-f (environment-image-execution-settings)})</pre></td></tr><tr><td class="docs"><p>Returns a metadata map that specifies a phase should be run only if the
specified <code>flag-kw</code> is not set on a node.  The map is suitable for use as a
value in a map passed to the <code>:phases-meta</code> clause of a <code>server-spec</code> or
<code>group-spec</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-on-unflagged-metadata
  [flag-kw]
  {:phase-execution-f (execute-on-unflagged flag-kw)})</pre></td></tr><tr><td class="docs"><p>Returns a metadata map that specifies a phase should be run only if
the specified <code>flag-kw</code> is not set on a node.  When the phase complete
the flag will be set.  The map is suitable for use as a value in a map
passed to the <code>:phases-meta</code> clause of a <code>server-spec</code> or
<code>group-spec</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-and-flag-metadata
  [flag-kw]
  {:phase-execution-f (execute-and-flag flag-kw)})</pre></td></tr><tr><td class="docs"><h4>Phase Extension</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Merge in the inherited specs</p>
</td><td class="codes"><pre class="brush: clojure">(defn extend-specs
  ([spec inherits algorithms]
     (if inherits
       (merge-specs
        algorithms
        (if (map? inherits)
          inherits
          (reduce #(merge-specs algorithms %1 %2) {} inherits))
        spec)
       spec))
  ([spec inherits]
     (extend-specs spec inherits merge-spec-algorithm)))</pre></td></tr><tr><td class="docs"><h4>Server-spec</h4>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Create a server-spec.</p>

<ul>
<li>:phases         a hash-map used to define phases. Phases are inherited by
                 anything that :extends the server-spec.
                 Standard phases are:
<ul><li>:bootstrap    run on first boot of a new node</li>
<li>:configure    defines the configuration of the node</li></ul></li>
<li>:default-phases a sequence specifying the default phases</li>
<li>:phases-meta    metadata to add to the phases</li>
<li>:extends        takes a server-spec, or sequence thereof, and is used to
                 inherit phases, etc.</li>
<li>:roles          defines a sequence of roles for the server-spec. Inherited
                 by anything that :extends the server-spec.</li>
<li>:node-spec      default node-spec for this server-spec</li>
<li>:packager       override the choice of packager to use</li>
</ul>

<p>For a given phase, inherited phase functions are run first, in the order
specified in the <code>:extends</code> argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn server-spec
  [&amp; {:keys [phases phases-meta default-phases packager node-spec extends roles]
      :as options}]
  (check-server-spec
   (-&gt;
    (or node-spec {})                    ; ensure we have a map and not nil
    (merge options)
    (when-&gt; roles
            (update-in [:roles] #(if (keyword? %) #{%} (into #{} %))))
    (extend-specs extends)
    (maybe-update-in [:phases] phases-with-meta phases-meta)
    (update-in [:default-phases] #(or default-phases % [:configure]))
    (dissoc :extends :node-spec :phases-meta)
    (vary-meta assoc :type ::server-spec))))</pre></td></tr><tr><td class="docs"><h3>Group-spec</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Create a group-spec.</p>

<p>   <code>name</code> is used for the group name, which is set on each node and links a node
   to its node-spec</p>

<ul>
<li><p>:extends        specify a server-spec, a group-spec, or sequence thereof
                 and is used to inherit phases, etc.</p></li>
<li><p>:phases         used to define phases. Standard phases are:</p></li>
<li>:phases-meta    metadata to add to the phases</li>
<li>:default-phases a sequence specifying the default phases</li>
<li>:bootstrap      run on first boot of a new node</li>
<li><p>:configure      defines the configuration of the node.</p></li>
<li><p>:count          specify the target number of nodes for this node-spec</p></li>
<li>:packager       override the choice of packager to use</li>
<li>:node-spec      default node-spec for this group-spec</li>
<li>:node-filter    a predicate that tests if a node is a member of this
                 group.</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn group-spec
  ;; Note that the node-filter is not set here for the default group-name based
  ;; membership, so that it does not need to be updated by functions that modify
  ;; a group's group-name.
  [name
   &amp; {:keys [extends count image phases phases-meta default-phases packager
             node-spec roles node-filter]
      :as options}]
  {:pre [(or (nil? image) (map? image))]}
  (let [group-name (keyword (clojure.core/name name))]
    (check-group-spec
     (-&gt;
      (or node-spec {})
      (merge options)
      (when-&gt; roles
              (update-in [:roles] #(if (keyword? %) #{%} (into #{} %))))
      (extend-specs extends)
      (maybe-update-in [:phases] phases-with-meta phases-meta)
      (update-in [:default-phases] #(or default-phases % [:configure]))
      (dissoc :extends :node-spec :phases-meta)
      (assoc :group-name group-name)
      (vary-meta assoc :type ::group-spec)))))</pre></td></tr><tr><td class="docs"><p>Expand a node-set into its groups</p>
</td><td class="codes"><pre class="brush: clojure">(defn expand-cluster-groups
  [node-set]
  (cond
   (sequential? node-set) (mapcat expand-cluster-groups node-set)
   (map? node-set) (if-let [groups (:groups node-set)]
                     (mapcat expand-cluster-groups groups)
                     [node-set])
   :else [node-set]))</pre></td></tr><tr><td class="docs"><p>Expand a converge node spec into its groups</p>
</td><td class="codes"><pre class="brush: clojure">(defn expand-group-spec-with-counts
  ([node-set spec-count]
     (letfn [(*1 [x y] (* (or x 1) y))
             (scale-spec [spec factor]
               (update-in spec [:count] *1 factor))
             (set-spec [node-spec]
               (mapcat
                (fn [[node-spec spec-count]]
                  (if-let [groups (:groups node-spec)]
                    (expand-group-spec-with-counts groups spec-count)
                    [(assoc node-spec :count spec-count)]))
                node-set))]
       (cond
        (sequential? node-set) (mapcat
                                #(expand-group-spec-with-counts % spec-count)
                                node-set)
        (map? node-set) (if-let [groups (:groups node-set)]
                          (let [spec (scale-spec node-set spec-count)]
                            (mapcat
                             #(expand-group-spec-with-counts % (:count spec))
                             groups))
                          (if (:group-name node-set)
                            [(scale-spec node-set spec-count)]
                            (set-spec node-spec)))
        :else [(scale-spec node-set spec-count)])))
  ([node-set] (expand-group-spec-with-counts node-set 1)))</pre></td></tr><tr><td class="docs"><p>Create a cluster-spec.</p>

<p>   <code>name</code> is used as a prefix for all groups in the cluster.</p>

<ul>
<li><p>:groups    specify a sequence of groups that define the cluster</p></li>
<li><p>:extends   specify a server-spec, a group-spec, or sequence thereof
            for all groups in the cluster</p></li>
<li><p>:phases    define phases on all groups.</p></li>
<li><p>:node-spec default node-spec for the nodes in the cluster</p></li>
<li><p>:roles     roles for all group-specs in the cluster</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn cluster-spec
  [cluster-name
   &amp; {:keys [extends groups phases node-spec roles] :as options}]
  (let [cluster-name (name cluster-name)
        group-prefix (if (blank? cluster-name) &quot;&quot; (str cluster-name &quot;-&quot;))]
    (-&gt;
     options
     (update-in [:groups]
                (fn [group-specs]
                  (map
                   (fn [group-spec]
                     (-&gt;
                      node-spec
                      (merge (dissoc group-spec :phases))
                      (update-in
                       [:group-name]
                       #(keyword (str group-prefix (name %))))
                      (update-in [:roles] union roles)
                      (extend-specs extends)
                      (extend-specs [{:phases phases}])
                      (extend-specs [(select-keys group-spec [:phases])])))
                   (expand-group-spec-with-counts group-specs 1))))
     (dissoc :extends :node-spec)
     (assoc :cluster-name (keyword cluster-name))
     (vary-meta assoc :type ::cluster-spec))))</pre></td></tr><tr><td class="docs"><p>Returns a compute service object, used to perform actions on a cloud
  provider.</p>

<h2>Compute Service</h2>

<p>The compute service is used to communicate with the cloud provider</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service
  [service-or-provider-name &amp; options]
  (apply configure/compute-service service-or-provider-name options))</pre></td></tr><tr><td class="docs"><p>Create a plan function from a sequence of plan function invocations.</p>

<p>   eg. (plan-fn
         (file "/some-file")
         (file "/other-file"))</p>

<p>   This generates a new plan function, and adds code to verify the state
   around each plan function call.</p>

<h3>plan functions</h3>
</td><td class="codes"><pre class="brush: clojure">(defmacro plan-fn
  [&amp; body]
  (let [n? (string? (first body))
        n (when n? (first body))
        body (if n? (rest body) body)]
    (if n
      `(fn [] (phase-context ~(gensym n) {} ~@body))
      `(fn [] (session-context ~(gensym &quot;a-plan-fn&quot;) {} ~@body)))))</pre></td></tr><tr><td class="docs"><h2>Operations</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Process phases. Returns a phase list and a phase-map. Functions specified in
  <code>phases</code> are identified with a keyword and a map from keyword to function.
  The return vector contains a sequence of phase keywords and the map
  identifying the anonymous phases.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- process-phases
  [phases]
  (let [phases (if (or (keyword? phases) (fn? phases)) [phases] phases)]
    (reduce
     (fn [[phase-kws phase-map] phase]
       (if (or (keyword? phase)
               (and (or (vector? phase) (seq? phase)) (keyword? (first phase))))
         [(conj phase-kws phase) phase-map]
         (let [phase-kw (-&gt; (gensym &quot;phase&quot;)
                            name keyword)]
           [(conj phase-kws phase-kw)
            (assoc phase-map phase-kw phase)])))
     [[] {}] phases)))</pre></td></tr><tr><td class="docs"><p>Adds the phases from phase-map into each group in the sequence <code>groups</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- groups-with-phases
  [groups phase-map]
  (letfn [(add-phases [group]
            (update-in group [:phases] merge phase-map))]
    (map add-phases groups)))</pre></td></tr><tr><td class="docs"><p>Expand a node-set into its groups</p>
</td><td class="codes"><pre class="brush: clojure">(defn expand-cluster-groups
  [node-set]
  (cond
   (sequential? node-set) (mapcat expand-cluster-groups node-set)
   (map? node-set) (if-let [groups (:groups node-set)]
                     (mapcat expand-cluster-groups groups)
                     [node-set])
   :else [node-set]))</pre></td></tr><tr><td class="docs"><p>Split a node-set into groups and targets. Returns a map with
:groups and :targets keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn split-groups-and-targets
  [node-set]
  (logging/tracef &quot;split-groups-and-targets %s&quot; (vec node-set))
  (-&gt;
   (group-by
    #(if (and (map? %)
              (every? map? (keys %))
              (every?
               (fn node-or-nodes? [x] (or (node? x) (sequential? x)))
               (vals %)))
       :targets
       :groups)
    node-set)
   (update-in
    [:targets]
    #(mapcat
      (fn [m]
        (reduce
         (fn [result [group nodes]]
           (if (sequential? nodes)
             (concat result (map (partial assoc group :node) nodes))
             (conj result (assoc group :node nodes))))
         []
         m))
      %))))</pre></td></tr><tr><td class="docs"><p>Returns a FSM to retrieve the service state for the specified groups</p>
</td><td class="codes"><pre class="brush: clojure">(defn- all-group-nodes
  [compute groups all-node-set]
  (if compute
    (ops/group-nodes
     compute
     (concat
      groups
      (map
       (fn [g] (update-in g [:phases] select-keys [:settings]))
       all-node-set)))
    (result nil)))</pre></td></tr><tr><td class="docs"><p>Arguments that are forwarded to be part of the environment</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  environment-args [:compute :blobstore :user :provider-options])</pre></td></tr><tr><td class="docs"><p>Returns a FSM to converge the existing compute resources with the counts
   specified in <code>group-spec-&gt;count</code>.  Options are as for <code>converge</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-node-maps
  [compute groups &amp; {:keys [async timeout-ms timeout-val]
                     :as options}]
  (let [fsm (all-group-nodes compute groups nil)]
    (if async
      (operate fsm)
      (if timeout-ms
        (deref (operate fsm) timeout-ms timeout-val)
        (deref (operate fsm))))))</pre></td></tr><tr><td class="docs"><p>Returns a FSM to converge the existing compute resources with the counts
   specified in <code>group-spec-&gt;count</code>.  Options are as for <code>converge</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn converge*
  [group-spec-&gt;count &amp; {:keys [compute blobstore user phase
                               all-node-set consider-groups
                               environment plan-state
                               debug os-detect]
                        :or {os-detect true}
                        :as options}]
  (check-converge-options options)
  (logging/tracef &quot;environment %s&quot; environment)
  (let [[phases phase-map] (process-phases phase)
        phase-map (if os-detect
                    (assoc phase-map
                      :pallet/os (vary-meta
                                  (plan-fn (os)) merge unbootstrapped-meta)
                      :pallet/os-bs (vary-meta
                                     (plan-fn (os)) merge bootstrapped-meta))
                    phase-map)
        groups (if (map? group-spec-&gt;count)
                 [group-spec-&gt;count]
                 group-spec-&gt;count)
        groups (expand-group-spec-with-counts group-spec-&gt;count)
        {:keys [groups targets]} (-&gt; groups
                                     expand-cluster-groups
                                     split-groups-and-targets)
        _ (logging/tracef &quot;groups %s&quot; (vec groups))
        _ (logging/tracef &quot;targets %s&quot; (vec targets))
        _ (logging/tracef &quot;environment keys %s&quot;
                          (select-keys options environment-args))
        environment (merge-environments
                     {:user user/*admin-user*}
                     (pallet.environment/environment compute)
                     environment
                     (select-keys options environment-args))
        groups (groups-with-phases groups phase-map)
        targets (groups-with-phases targets phase-map)
        groups (map (partial group-with-environment environment) groups)
        targets (map (partial group-with-environment environment) targets)
        lift-options (select-keys options ops/lift-options)
        initial-plan-state (assoc (or plan-state {})
                             action-options-key
                             (select-keys debug
                                          [:script-comments :script-trace]))
        phases (or (seq phases)
                   (apply total-order-merge
                          (map :default-phases (concat groups targets))))]
    (doseq [group groups] (check-group-spec group))
    (dofsm converge
      [nodes-set (all-group-nodes compute groups all-node-set)
       nodes-set (result (concat nodes-set targets))
       consider-set (all-group-nodes compute consider-groups all-node-set)
       _ (succeed
          (or compute (seq nodes-set))
          {:error :no-nodes-and-no-compute-service})
       {:keys [new-nodes plan-state targets service-state] :as converge-result}
       (ops/converge
        compute groups nodes-set initial-plan-state environment
        phases lift-options)
       {:keys [plan-state] :as lift1}
       (ops/lift-partitions
        service-state plan-state environment
        (concat (when os-detect [:pallet/os-bs :pallet/os])
                [:settings])
        (assoc lift-options :targets (distinct (concat consider-set targets))))
       {:keys [plan-state results]}
       (ops/lift-partitions
        service-state plan-state environment
        (concat [:bootstrap] phases)
        (assoc lift-options :targets targets))]
      (-&gt; converge-result
          (update-in [:results] concat (:results lift1) results)
          (assoc :plan-state (dissoc plan-state :node-values)
                 :environment environment
                 :initial-plan-state initial-plan-state)))))</pre></td></tr><tr><td class="docs"><p>Converge the existing compute resources with the counts specified in
<code>group-spec-&gt;count</code>. New nodes are started, or nodes are destroyed to obtain the
specified node counts.</p>

<p><code>group-spec-&gt;count</code> can be a map from group-spec to node count, or can be a
sequence of group-specs containing a :count key.</p>

<p>This applies the <code>:bootstrap</code> phase to all new nodes and, by default,
the :configure phase to all running nodes whose group-name matches a key in the
node map.  Phases can also be specified with the <code>:phase</code> option, and will be
applied to all matching nodes.  The :configure phase is the default phase
applied.</p>

<h2>Options</h2>

<p><code>:compute</code>
: a compute service.</p>

<p><code>:blobstore</code>
: a blobstore service.</p>

<p><code>:phase</code>
: a phase keyword, phase function, or sequence of these.</p>

<p><code>:user</code>
: the admin-user on the nodes.</p>

<p><code>:consider-groups</code>
: a sequence of group-specs, which should have just the :settings
  phase run on them, so that their configuration is available for
  other nodes to query.  The numbe of nodes in these groups will not
  be adjusted.</p>

<h3>Partitioning</h3>

<p><code>:partition-f</code>
: a function that takes a sequence of targets, and returns a sequence of
  sequences of targets.  Used to partition or filter the targets.  Defaults to
  any :partition metadata on the phase, or no partitioning otherwise.</p>

<h2>Post phase options</h2>

<p><code>:post-phase-f</code>
: specifies an optional function that is run after a phase is applied.  It is
  passed <code>targets</code>, <code>phase</code> and <code>results</code> arguments, and is called before any
  error checking is done.  The return value is ignored, so this is for side
  affect only.</p>

<p><code>:post-phase-fsm</code>
: specifies an optional fsm returning function that is run after a phase is
  applied.  It is passed <code>targets</code>, <code>phase</code> and <code>results</code> arguments, and is
  called before any error checking is done.  The return value is ignored, so
  this is for side affect only.</p>

<h3>Asynchronous and Timeouts</h3>

<p><code>:async</code>
: a flag to control whether the function executes asynchronously.  When truthy,
  the function returns an Operation that can be deref'd like a future.  When not
  truthy, <code>:timeout-ms</code> may be used to specify a timeout.  Defaults to nil.</p>

<p><code>:timeout-ms</code>
: an integral number of milliseconds to wait for completion before timeout.
  Only applies if <code>:async</code> is not truthy (the default).</p>

<p><code>:timeout-val</code>
: a value to be returned should the operation time out.</p>

<h3>Algorithm options</h3>

<p><code>:phase-execution-f</code>
: specifies the function used to execute a phase on the targets.  Defaults
  to <code>pallet.core.primitives/build-and-execute-phase</code>.</p>

<p><code>:execution-settings-f</code>
: specifies a function that will be called with a node argument, and which
  should return a map with <code>:user</code>, <code>:executor</code> and <code>:executor-status-fn</code> keys.</p>

<h3>OS detection</h3>

<p><code>:os-detect</code>
: controls detection of nodes' os (default true).</p>
</td><td class="codes"><pre class="brush: clojure">(defn converge
  [group-spec-&gt;count &amp; {:keys [compute blobstore user phase
                               all-node-set environment
                               async timeout-ms timeout-val
                               debug plan-state]
                        :as options}]
  (load-plugins)
  (if async
    (operate (apply-map converge* group-spec-&gt;count options))
    (if timeout-ms
      (deref (operate (apply-map converge* group-spec-&gt;count options))
             timeout-ms timeout-val)
      (deref (operate (apply-map converge* group-spec-&gt;count options))))))</pre></td></tr><tr><td class="docs"><p>Returns a FSM to lift the running nodes in the specified node-set by applying
   the specified phases.  Options as specified in <code>lift</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lift*
  [node-set &amp; {:keys [compute phase all-node-set consider-groups environment
                      debug plan-state os-detect]
               :or {os-detect true}
               :as options}]
  (check-lift-options options)
  (let [[phases phase-map] (process-phases phase)
        phase-map (if os-detect
                    (assoc phase-map :pallet/os (plan-fn (os)))
                    phase-map)
        {:keys [groups targets]} (-&gt; node-set
                                     expand-cluster-groups
                                     split-groups-and-targets)
        _ (logging/tracef &quot;groups %s&quot; (vec groups))
        _ (logging/tracef &quot;targets %s&quot; (vec targets))
        _ (logging/tracef &quot;environment keys %s&quot;
                          (select-keys options environment-args))
        _ (logging/tracef &quot;options %s&quot; options)
        environment (merge-environments
                     {:user user/*admin-user*}
                     (and compute (pallet.environment/environment compute))
                     environment
                     (select-keys options environment-args))
        groups (groups-with-phases groups phase-map)
        targets (groups-with-phases targets phase-map)
        groups (map (partial group-with-environment environment) groups)
        targets (map (partial group-with-environment environment) targets)
        initial-plan-state (assoc (or plan-state {})
                             action-options-key
                             (select-keys debug
                                          [:script-comments :script-trace]))
        lift-options (select-keys options ops/lift-options)
        phases (or (seq phases)
                   (apply total-order-merge
                          (map :default-phases (concat groups targets))))]
    (doseq [group groups] (check-group-spec group))
    (dofsm lift
      [nodes-set (all-group-nodes compute groups all-node-set)
       nodes-set (result (concat nodes-set targets))
       consider-set (all-group-nodes compute consider-groups all-node-set)
       _ (succeed
          (or compute (seq nodes-set))
          {:error :no-nodes-and-no-compute-service})
       {:keys [plan-state]} (ops/lift
                             (distinct (concat consider-set nodes-set))
                             initial-plan-state environment
                             (concat
                              (when os-detect [:pallet/os])
                              [:settings])
                             {})
       results (ops/lift-partitions
                (distinct (concat consider-set nodes-set))
                plan-state environment (remove #{:settings} phases)
                (assoc lift-options
                  :targets nodes-set))]
      (assoc results
        :environment environment
        :initial-plan-state initial-plan-state))))</pre></td></tr><tr><td class="docs"><p>Lift the running nodes in the specified node-set by applying the specified
phases.  The compute service may be supplied as an option, otherwise the
bound compute-service is used.  The configure phase is applied by default
unless other phases are specified.</p>

<p>node-set can be a group spec, a sequence of group specs, or a map
of group specs to nodes. Examples:</p>

<pre><code>[group-spec1 group-spec2 {group-spec #{node1 node2}}]
group-spec
{group-spec #{node1 node2}}
</code></pre>

<h2>Options:</h2>

<p><code>:compute</code>
: a compute service.</p>

<p><code>:blobstore</code>
: a blobstore service.</p>

<p><code>:phase</code>
: a phase keyword, phase function, or sequence of these.</p>

<p><code>:user</code>
: the admin-user on the nodes.</p>

<p><code>:consider-groups</code>
: a sequence of group-specs, which should have just the :settings
  phase run on them, so that their configuration is available for
  other nodes to query.</p>

<h3>Partitioning</h3>

<p><code>:partition-f</code>
: a function that takes a sequence of targets, and returns a sequence of
  sequences of targets.  Used to partition or filter the targets.  Defaults to
  any :partition metadata on the phase, or no partitioning otherwise.</p>

<h2>Post phase options</h2>

<p><code>:post-phase-f</code>
: specifies an optional function that is run after a phase is applied.  It is
  passed <code>targets</code>, <code>phase</code> and <code>results</code> arguments, and is called before any
  error checking is done.  The return value is ignored, so this is for side
  affect only.</p>

<p><code>:post-phase-fsm</code>
: specifies an optional fsm returning function that is run after a phase is
  applied.  It is passed <code>targets</code>, <code>phase</code> and <code>results</code> arguments, and is
  called before any error checking is done.  The return value is ignored, so
  this is for side affect only.</p>

<h3>Asynchronous and Timeouts</h3>

<p><code>:async</code>
: a flag to control whether the function executes asynchronously.  When truthy,
  the function returns an Operation that can be deref'd like a future.  When not
  truthy, <code>:timeout-ms</code> may be used to specify a timeout.  Defaults to nil.</p>

<p><code>:timeout-ms</code>
: an integral number of milliseconds to wait for completion before timeout.
  Only applies if <code>:async</code> is not truthy (the default).</p>

<p><code>:timeout-val</code>
: a value to be returned should the operation time out.</p>

<h3>Algorithm options</h3>

<p><code>:phase-execution-f</code>
: specifies the function used to execute a phase on the targets.  Defaults
  to <code>pallet.core.primitives/build-and-execute-phase</code>.</p>

<p><code>:execution-settings-f</code>
: specifies a function that will be called with a node argument, and which
  should return a map with <code>:user</code>, <code>:executor</code> and <code>:executor-status-fn</code> keys.</p>

<h3>OS detection</h3>

<p><code>:os-detect</code>
: controls detection of nodes' os (default true).</p>
</td><td class="codes"><pre class="brush: clojure">(defn lift
  [node-set &amp; {:keys [compute phase user all-node-set environment
                      async timeout-ms timeout-val
                      partition-f post-phase-f post-phase-fsm
                      phase-execution-f execution-settings-f
                      debug plan-state]
               :as options}]
  (load-plugins)
  (if async
    (operate (apply-map lift* node-set options))
    (if timeout-ms
      (deref (operate (apply-map lift* node-set options))
             timeout-ms timeout-val)
      (deref (operate (apply-map lift* node-set options))))))</pre></td></tr><tr><td class="docs"><p>Lift <code>targets</code>, a sequence of node-maps, using the specified <code>phases</code>.  This
provides a way of lifting phases, which doesn't tie you to working with all
nodes in a group.  Consider using this only if the functionality in <code>lift</code> is
insufficient.</p>

<p><code>phases</code>
: a sequence of phase keywords (identifying phases) or plan functions, that
  should be applied to the target nodes.  Note that there are no default phases.</p>

<h2>Options:</h2>

<p><code>:user</code>
: the admin-user to use for operations on the target nodes.</p>

<p><code>:environment</code>
: an environment map, to be merged into the environment.</p>

<p><code>:plan-state</code>
: an state map, which can be used to passing settings across multiple lift-nodes
  invocations.</p>

<p><code>:async</code>
: a flag to control whether the function executes asynchronously.  When truthy,
  the function returns an Operation that can be deref'd like a future.  When not
  truthy, <code>:timeout-ms</code> may be used to specify a timeout.  Defaults to nil.</p>

<p><code>:timeout-ms</code>
: an integral number of milliseconds to wait for completion before timeout.
  Only applies if <code>:async</code> is not truthy (the default).</p>

<p><code>:timeout-val</code>
: a value to be returned should the operation time out.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lift-nodes
  [targets phases
   &amp; {:keys [user environment plan-state async timeout-ms timeout-val]
      :or {environment {} plan-state {}}
      :as options}]
  (let [[phases phase-map] (process-phases phases)
        targets (groups-with-phases targets phase-map)
        environment (merge-environments
                     {:user user/*admin-user*}
                     environment
                     (select-keys options environment-args))]
    (letfn [(lift-nodes* []
              (operate
               (ops/lift-partitions
                targets plan-state environment phases
                (dissoc options
                        :environment :plan-state :async
                        :timeout-val :timeout-ms))))]
      (if async
        (lift-nodes*)
        (if timeout-ms
          (deref (lift-nodes*) timeout-ms timeout-val)
          (deref (lift-nodes*)))))))</pre></td></tr><tr><td class="docs"><p>Return a sequence of node-maps for each node in the specified group-specs.</p>

<h2>Options:</h2>

<p><code>:async</code>
: a flag to control whether the function executes asynchronously.  When truthy,
  the function returns an Operation that can be deref'd like a future.  When not
  truthy, <code>:timeout-ms</code> may be used to specify a timeout.  Defaults to nil.</p>

<p><code>:timeout-ms</code>
: an integral number of milliseconds to wait for completion before timeout.
  Only applies if <code>:async</code> is not truthy (the default).</p>

<p><code>:timeout-val</code>
: a value to be returned should the operation time out.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-nodes
  [compute groups &amp; {:keys [async timeout-ms timeout-val]}]
  (letfn [(group-nodes* [] (operate (ops/group-nodes compute groups)))]
    (if async
      (group-nodes*)
      (if timeout-ms
        (deref (group-nodes*) timeout-ms timeout-val)
        (deref (group-nodes*))))))</pre></td></tr><tr><td class="docs"><p>Creates a User record with the given username and options. Generally used
   in conjunction with <em>admin-user</em> and pallet.api/with-admin-user, or passed
   to <code>lift</code> or <code>converge</code> as the named :user argument.</p>

<p>   Options:
    - :public-key-path (defaults to ~/.ssh/id_rsa.pub)
    - :private-key-path (defaults to ~/.ssh/id_rsa)
    - :passphrase
    - :password
    - :sudo-password (defaults to :password)
    - :no-sudo</p>

<h3>Admin user</h3>
</td><td class="codes"><pre class="brush: clojure">(defn make-user
  [username &amp; {:keys [public-key-path private-key-path passphrase
                      password sudo-password no-sudo sudo-user] :as options}]
  (check-user
   (user/make-user
    username
    (merge
     (if (:password options)
       {:sudo-password (:password options)}
       {:private-key-path (user/default-private-key-path)
        :public-key-path (user/default-public-key-path)})
     options))))</pre></td></tr><tr><td class="docs"><p>Specify the admin user for running remote commands.  The user is specified
   either as pallet.utils.User record (see the pallet.utils/make-user
   convenience fn) or as an argument list that will be passed to make-user.</p>

<p>   This is mainly for use at the repl, since the admin user can be specified
   functionally using the :user key in a lift or converge call, or in the
   environment.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-admin-user
  [user &amp; exprs]
  `(binding [user/*admin-user* ~user]
    ~@exprs))</pre></td></tr><tr><td class="docs"><p>Print the targets of an operation</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-nodes
  [nodes]
  (let [ks [:primary-ip :private-ip :hostname :group-name :roles]]
    (print-table ks
                 (for [node nodes
                       :let [node (node-map node)]]
                   (select-keys node ks)))))</pre></td></tr><tr><td class="docs"><p>Print the targets of an operation</p>
</td><td class="codes"><pre class="brush: clojure">(defn print-targets
  [op]
  (let [ks [:primary-ip :private-ip :hostname :group-name :roles]]
    (print-table ks
                 (for [{:keys [node roles]} (:targets op)]
                   (assoc (select-keys (node-map node) ks)
                     :roles roles)))))</pre></td></tr><tr><td class="docs"><p>Local Variables:
mode: clojure
eval: (define-clojure-indent (cluster-spec 1)(group-spec 1))
End:</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.argument" name="pallet.argument"><h1 class="project-name">pallet.argument</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Arguments to actions.  Adds capability of evaluating arguments at
   action application</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.argument)</pre></td></tr><tr><td class="docs"><p>Provides a session inside a delayed function. This should be
considered an implementation detail.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :dynamic true}
  *session*)</pre></td></tr><tr><td class="docs"><p>A protocol for passing arguments, with delayed evaluation.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol DelayedArgument
  (evaluate [x session]))</pre></td></tr><tr><td class="docs"><p>By default, arguments should evaluate to themselves</p>
</td><td class="codes"><pre class="brush: clojure">(extend-type
    Object
  DelayedArgument
  (evaluate [x session] x))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type
    clojure.lang.PersistentHashMap
  DelayedArgument
  (evaluate [x session]
    (into {} (map
              #(vector (key %) (when-let [v (val %)] (evaluate v session)))
              x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type
    clojure.lang.PersistentArrayMap
  DelayedArgument
  (evaluate [x session]
    (into {} (map
              #(vector (key %) (when-let [v (val %)] (evaluate v session)))
              x))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype DelayedFunction
    [f]
  DelayedArgument
  (evaluate [_ session]
    (binding [*session* session]
      (loop [v (f session)]
        (if (satisfies? DelayedArgument v)
          (let [v1 (evaluate v session)]
            (if (= v v1)
              v
              (recur v1)))
          v)))))</pre></td></tr><tr><td class="docs"><p>Pass a function with a single argument, to be used to compute an argument at
   action application time.</p>
</td><td class="codes"><pre class="brush: clojure">(defn delayed-fn
  [f]
  (DelayedFunction. f))</pre></td></tr><tr><td class="docs"><p>Pass an argument to be evaluated at action application time.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro delayed
  [[session-sym] &amp; body]
  `(DelayedFunction. (fn [~session-sym] ~@body)))</pre></td></tr><tr><td class="docs"><p>Predicate to test if <code>x</code> is a delayed argument type.</p>
</td><td class="codes"><pre class="brush: clojure">(defn delayed-argument?
  [x]
  (satisfies? DelayedArgument x))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore" name="pallet.blobstore"><h1 class="project-name">pallet.blobstore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Blobstore abstraction</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.blobstore
  (:require
   [pallet.blobstore.implementation :as implementation]
   [pallet.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>Instantiate a blobstore service based on the given arguments</p>

<p>Blobstore service instantiation</p>
</td><td class="codes"><pre class="brush: clojure">(defn service
  [provider-name
   &amp; {:keys [identity credential extensions] :as options}]
  (implementation/load-providers)
  (implementation/service provider-name options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   &quot;Create a signed request&quot;)
  (put
   [blobstore container path payload]
   &quot;Upload a file, string, input stream, etc&quot;)
  (put-file
   [blobstore container path file]
   &quot;Upload a file&quot;)
  (containers
   [blobstore]
   &quot;List containers&quot;)
  (close
   [blobstore]
   &quot;Close the blobstore&quot;))</pre></td></tr><tr><td class="docs"><p>Predicate to test if argument is a blobstore.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore?
  [b]
  (satisfies? Blobstore b))</pre></td></tr><tr><td class="docs"><p>Add deprecated forwarding functions
 blobstore-from-map
 blobstore-from-config
 blobstore-from-config-file</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(utils/fwd-to-configure blobstore-from-map)
(utils/fwd-to-configure blobstore-from-config)
(utils/fwd-to-configure blobstore-from-config-file)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.implementation" name="pallet.blobstore.implementation"><h1 class="project-name">pallet.blobstore.implementation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation details</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.blobstore.implementation
  (:require
   [chiba.plugin :refer [plugins]]))</pre></td></tr><tr><td class="docs"><p>Instantiate a blobstore. Providers should implement a method for this.
   See pallet.blobstore/blobstore-service.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti service
  (fn [provider-name &amp; _] (keyword provider-name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def blobstore-prefix &quot;pallet.blobstore.&quot;)
(def exclude-blobstore-ns
  #{'pallet.blobstore.implementation})
(def exclude-regex #&quot;.*test.*&quot;)
(def provider-list (atom nil))</pre></td></tr><tr><td class="docs"><p>Find the available providers.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- providers
  []
  (-&gt;&gt; (plugins blobstore-prefix exclude-regex)
       (remove exclude-blobstore-ns)))</pre></td></tr><tr><td class="docs"><p>Require all providers, ensuring no errors if individual providers can not be
   loaded</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-providers
  []
  (when-not @provider-list
    (reset! provider-list (providers))
    (let [loaded (filter
                  identity
                  (doall
                   (for [provider @provider-list]
                     (try
                       (require provider)
                       provider
                       (catch Throwable _)))))]
      (reset! provider-list loaded)))
  @provider-list)</pre></td></tr><tr><td class="docs"><p>Create a list of supported providers</p>
</td><td class="codes"><pre class="brush: clojure">(defn supported-providers
  []
  (-&gt;&gt;
   (doall
    (for [provider (load-providers)]
      (when-let [providers (ns-resolve provider 'supported-providers)]
        (@providers))))
   (filter identity)
   (apply concat)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.url-blobstore" name="pallet.blobstore.url-blobstore"><h1 class="project-name">pallet.blobstore.url-blobstore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A url based blobstore implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.blobstore.url-blobstore
  (:require
   [pallet.blobstore :as blobstore]
   [pallet.blobstore.implementation :as implementation]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord UrlBlobstore
    [base-url]
  pallet.blobstore/Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   {:endpoint (format &quot;%s/%s/%s&quot; base-url container path)
    :headers nil})
  (close
   [blobstore]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod implementation/service :url-blobstore
  [provider {:keys [base-url]
             :or {base-url &quot;http://localhost&quot;}}]
  (UrlBlobstore. base-url))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.command-line" name="pallet.command-line"><h1 class="project-name">pallet.command-line</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Process command-line arguments according to a given cmdspec</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.command-line
  (:refer-clojure :exclude [group-by]))</pre></td></tr><tr><td class="docs"><p>Returns a string of all elements in coll, separated by
  separator.  Like Perl's join.</p>
</td><td class="codes"><pre class="brush: clojure">(defn #^String join
  [#^String separator coll]
  (apply str (interpose separator coll)))</pre></td></tr><tr><td class="docs"><p>Returns a sorted map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-by ;; in clojure 1.2 core
  [f coll]
  (reduce
   (fn [ret x]
     (let [k (f x)]
       (assoc ret k (conj (get ret k []) x))))
   (sorted-map) coll))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-map [args cmdspec]
  (let [{spec true [rest-sym] false} (group-by vector? cmdspec)
        rest-str (str rest-sym)
        key-data (into {} (for [[syms [_ default]] (map #(split-with symbol? %)
                                                        (conj spec '[help? h?]))
                                sym syms]
                            [(re-find #&quot;^.*[^?]&quot; (str sym))
                             {:sym (str (first syms)) :default default}]))
        defaults (into {} (for [[_ {:keys [default sym]}] key-data
                                :when default]
                            [sym default]))]
    (loop [[argkey &amp; [argval :as r]] args
           cmdmap (assoc defaults :cmdspec cmdspec rest-str [])]
      (if argkey
        (let [[_ &amp; [keybase]] (re-find #&quot;^--?(.*)&quot; argkey)]
          (cond
            (= keybase nil) (recur r (update-in cmdmap [rest-str] conj argkey))
            (= keybase )  (update-in cmdmap [rest-str] #(apply conj % r))
            :else (if-let [found (key-data keybase)]
                    (if (= \? (last (:sym found)))
                      (recur r (assoc cmdmap (:sym found) true))
                      (recur (next r) (assoc cmdmap (:sym found)
                                             (if (or (nil? r) (= \- (ffirst r)))
                                               (:default found)
                                               (first r)))))
                    (throw (Exception. (str &quot;Unknown option &quot; argkey))))))
        cmdmap))))</pre></td></tr><tr><td class="docs"><p>Align strings given as vectors of columns, with first vector
   specifying right or left alignment (:r or :l) for each column.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- align
   [spec &amp; rows]
   (let [maxes (vec (for [n (range (count (first rows)))]
                      (apply max (map (comp count #(nth % n)) rows))))
         fmt (join &quot; &quot;
                   (for [n (range (count maxes))]
                     (str &quot;%&quot;
                          (when-not (zero? (maxes n))
                            (str (when (= (spec n) :l) &quot;-&quot;) (maxes n)))
                          &quot;s&quot;)))]
     (join &quot;\n&quot;
           (for [row rows]
             (apply format fmt row)))))</pre></td></tr><tr><td class="docs"><p>Remove ?</p>
</td><td class="codes"><pre class="brush: clojure">(defn- rmv-q
   [#^String s]
   (if (.endsWith s &quot;?&quot;)
      (.substring s 0 (dec (count s)))
      s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn print-help [desc cmdmap]
  (println desc)
  (println &quot;Options&quot;)
  (println
     (apply align [:l :l :l]
        (for [spec (:cmdspec cmdmap) :when (vector? spec)]
            (let [[argnames [text default]] (split-with symbol? spec)
                  [_ opt q] (re-find #&quot;^(.*[^?])(\??)$&quot;
                                 (str (first argnames)))
                  argnames  (map (comp rmv-q str) argnames)
                  argnames
                        (join &quot;, &quot;
                          (for [arg argnames]
                            (if (= 1 (count arg))
                              (str &quot;-&quot; arg)
                              (str &quot;--&quot; arg))))]
               [(str &quot;  &quot; argnames (when (=  q) &quot; &lt;arg&gt;&quot;) &quot; &quot;)
                text
                (if-not default
                  (str &quot; [default &quot; default &quot;]&quot;))])))))</pre></td></tr><tr><td class="docs"><p>Bind locals to command-line args.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-command-line
  [args desc cmdspec &amp; body]
  (let [locals (vec (for [spec cmdspec]
                      (if (vector? spec)
                        (first spec)
                        spec)))]
    `(let [{:strs ~locals :as cmdmap#} (make-map ~args '~cmdspec)]
       (if (cmdmap# &quot;help?&quot;)
         (print-help ~desc cmdmap#)
         (do ~@body)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

; example of usage:

(with-command-line *command-line-args*
  &quot;tojs -- Compile ClojureScript to JavaScript&quot;
  [[simple? s? &quot;Runs some simple built-in tests&quot;]
   [serve      &quot;Starts a repl server on the given port&quot; 8081]
   [mkboot?    &quot;Generates a boot.js file&quot;]
   [verbose? v? &quot;Includes extra fn names and comments in js&quot;]
   filenames]
  (binding [*debug-fn-names* verbose? *debug-comments* verbose?]
    (cond
      simple? (simple-tests)
      serve   (start-server (Integer/parseInt serve))
      mkboot? (mkboot)
      :else   (doseq [filename filenames]
                 (filetojs filename)))))

)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute" name="pallet.compute"><h1 class="project-name">pallet.compute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Abstraction of the compute interface</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.compute
  (:require
   [pallet.compute.implementation :as implementation]
   [pallet.core.version-dispatch :refer [version-map]]
   [pallet.versions :refer [as-version-vector]]))</pre></td></tr><tr><td class="docs"><p>Return a list of supported provider names.
Each name is suitable to be passed to compute-service.</p>

<p>Meta</p>
</td><td class="codes"><pre class="brush: clojure">(defn supported-providers
  []
  (implementation/supported-providers))</pre></td></tr><tr><td class="docs"><p>Compute Service instantiation</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private
  missing-provider-re
  #&quot;No method in multimethod 'service' for dispatch value: (.*)&quot;)</pre></td></tr><tr><td class="docs"><p>Instantiate a compute service. The provider name should be a recognised
jclouds provider, "node-list", "hybrid", or "localhost". The other
arguments are keyword value pairs.</p>

<ul>
<li>:identity     username or key</li>
<li>:credential   password or secret</li>
<li>:extensions   extension modules for jclouds</li>
<li>:node-list    a list of nodes for the "node-list" provider.</li>
<li>:environment  an environment map with service specific values.</li>
</ul>

<p>Provider specific options may also be passed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn instantiate-provider
  [provider-name
   &amp; {:keys [identity credential extensions node-list endpoint environment
             sub-services]
      :as options}]
  (implementation/load-providers)
  (try
    (implementation/service provider-name options)
    (catch IllegalArgumentException e
      (if-let [[_ provider] (re-find missing-provider-re (.getMessage e))]
        (let [cause (cond
                     (= provider &quot;:vmfest&quot;)
                     &quot;Possible missing dependency on pallet-vmfest.&quot;
                     (find-ns 'pallet.compute.jclouds)
                     &quot;Possible missing dependency on a jclouds provider.&quot;
                     :else
                     &quot;Possible missing dependency.&quot;)]
          (throw (ex-info
                  (str &quot;No pallet provider found for &quot; provider
                       &quot;.  &quot; cause)
                  {:provider provider
                   :cause cause})))
        (throw e)))))</pre></td></tr><tr><td class="docs"><p>Actions</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>TODO
the executor should be passed to the compute service to allow remote
execution of the init script using the executor abstraction.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>However, the executor uses the session abstraction, so that would need
passing too</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol ComputeService
  (nodes [compute] &quot;List nodes&quot;)
  (run-nodes
    [compute group-spec node-count user init-script options]
    &quot;Start node-count nodes for group-spec, executing an init-script
     on each, using the specified user and options.&quot;)
  (reboot [compute nodes]
    &quot;Reboot the specified nodes&quot;)
  (boot-if-down
   [compute nodes]
   &quot;Boot the specified nodes, if they are not running.&quot;)
  (shutdown-node [compute node user] &quot;Shutdown a node.&quot;)
  (shutdown [compute nodes user] &quot;Shutdown specified nodes&quot;)
  (ensure-os-family
   [compute group-spec]
   &quot;Called on startup of a new node to ensure group-spec has an os-family
   attached to it.&quot;)
  (destroy-nodes-in-group [compute group-name])
  (destroy-node [compute node])
  (images [compute])
  (close [compute]))</pre></td></tr><tr><td class="docs"><p>Predicate for the argument satisfying the ComputeService protocol.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service?
  [c]
  (satisfies? ComputeService c))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ComputeServiceProperties
  (service-properties [compute]
    &quot;Return a map of service details.  Contains a :provider key at a minimum.
    May contain current credentials.&quot;))</pre></td></tr><tr><td class="docs"><p>Provides a SPI for tagging nodes with values.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodeTagReader
  (node-tag [compute node tag-name] [compute node tag-name default-value]
    &quot;Return the specified tag on the node.&quot;)
  (node-tags [compute node]
    &quot;Return the tags on the node.&quot;))</pre></td></tr><tr><td class="docs"><p>Provides a SPI for adding tags to nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodeTagWriter
  (tag-node! [compute node tag-name value]
    &quot;Set a value on the given tag-name on the node.&quot;)
  (node-taggable? [compute node]
    &quot;Predicate to test the availability of tags on a node.&quot;))</pre></td></tr><tr><td class="docs"><p>(defn nodes-by-tag [nodes]
  (reduce #(assoc %1
             (keyword (tag %2))
             (conj (get %1 (keyword (tag %2)) []) %2)) {} nodes))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn node-counts-by-tag [nodes]
  (reduce #(assoc %1
             (keyword (tag %2))
             (inc (get %1 (keyword (tag %2)) 0))) {} nodes))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Hierarchies</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def os-hierarchy
  (-&gt; (make-hierarchy)
      (derive :linux :os)
      ;; base distibutions
      (derive :rh-base :linux)
      (derive :debian-base :linux)
      (derive :arch-base :linux)
      (derive :suse-base :linux)
      (derive :bsd-base :linux)
      (derive :gentoo-base :linux)
      ;; distibutions
      (derive :centos :rh-base)
      (derive :rhel :rh-base)
      (derive :amzn-linux :rh-base)
      (derive :fedora :rh-base)
      (derive :debian :debian-base)
      (derive :ubuntu :debian-base)
      (derive :jeos :debian-base)
      (derive :suse :suse-base)
      (derive :arch :arch-base)
      (derive :gentoo :gentoo-base)
      (derive :darwin :bsd-base)
      (derive :os-x :bsd-base)))</pre></td></tr><tr><td class="docs"><p>Defines a defmulti used to abstract over the target operating system. The
   function dispatches based on the target operating system, that is extracted
   from the session passed as the first argument.</p>

<p>   Version comparisons are not included</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmulti-os
  [name [&amp; args]]
  `(do
     (defmulti ~name
       (fn [~@args] (-&gt; ~(first args) :server :image :os-family))
       :hierarchy #'os-hierarchy)
     (defmethod ~name :default [~@args]
       (throw
        (ex-info
         (format
          &quot;%s does not support %s&quot;
          ~name (-&gt; ~(first args) :server :image :os-family))
         {:type :pallet/unsupported-os})))))</pre></td></tr><tr><td class="docs"><p>target mapping</p>
</td><td class="codes"><pre class="brush: clojure">(def packager-map
  (version-map os-hierarchy :os :os-version
               {{:os :debian-base} :apt
                {:os :rh-base} :yum
                {:os :arch-base} :pacman
                {:os :gentoo-base} :portage
                {:os :suse-base} :zypper
                {:os :os-x} :brew
                {:os :darwin} :brew}))</pre></td></tr><tr><td class="docs"><p>Package manager</p>
</td><td class="codes"><pre class="brush: clojure">(defn packager-for-os
  [os-family os-version]
  (or
   (get packager-map {:os os-family :os-version (as-version-vector os-version)})
   (throw
    (ex-info
     (format &quot;Unknown packager for %s %s&quot; os-family os-version)
     {:type :unknown-packager}))))</pre></td></tr><tr><td class="docs"><p>Base distribution for the target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:deprecated base-distribution
  [target]
  (or
   (:base-distribution target)
   (let [os-family (:os-family target)]
     (cond
      (#{:ubuntu :debian :jeos} os-family) :debian
      (#{:centos :rhel :amzn-linux :fedora} os-family) :rh
      (#{:arch} os-family) :arch
      (#{:suse} os-family) :suse
      (#{:gentoo} os-family) :gentoo
      (#{:darwin :os-x} os-family) :os-x
      :else (throw
             (ex-info
              (format &quot;Unknown base-distribution for %s - target is %s&quot;
                      os-family target)
              {:type :unknown-packager}))))))</pre></td></tr><tr><td class="docs"><p>User that remote commands are run under</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-group
  ([target]
     (admin-group (-&gt; target :image :os-family) nil))
  ([os-family os-version]
     (case os-family
       :centos &quot;wheel&quot;
       :rhel &quot;wheel&quot;
       &quot;adm&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.hybrid" name="pallet.compute.hybrid"><h1 class="project-name">pallet.compute.hybrid</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Hybrid provider service implementation.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.compute.hybrid
  (:require
   [clojure.tools.logging :as logging]
   [pallet.compute.implementation :as implementation]
   [pallet.configure :as configure]
   [pallet.node :as node]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn supported-providers []
  [&quot;hybrid&quot;])</pre></td></tr><tr><td class="docs"><p>Return the service objects from the service map</p>
</td><td class="codes"><pre class="brush: clojure">(defn- services
  [service-map]
  (vals service-map))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype HybridService
    [service-map dispatch environment]
  pallet.compute/ComputeService
  (nodes [compute]
    (mapcat pallet.compute/nodes (services service-map)))
  (run-nodes [compute group-spec node-count user init-script options]
    (pallet.compute/run-nodes
     (dispatch service-map group-spec)
     group-spec node-count user init-script options))
  (reboot [compute nodes]
    (doseq [node nodes]
      (pallet.compute/reboot (node/compute-service node) node)))
  (boot-if-down [compute nodes]
    (doseq [node nodes]
      (pallet.compute/boot-if-down (node/compute-service node) node)))
  (shutdown-node [compute node user]
    (pallet.compute/shutdown-node (node/compute-service node) node user))
  (shutdown [compute nodes user]
    (doseq [node nodes]
      (pallet.compute/shutdown-node (node/compute-service node) node user)))
  (ensure-os-family [compute group-spec]
    (pallet.compute/ensure-os-family
     (dispatch service-map group-spec)
     group-spec))
  (destroy-nodes-in-group [compute group-name]
    (pallet.compute/destroy-nodes-in-group
     (dispatch service-map (name group-name))
     group-name))
  (destroy-node [compute node]
    (pallet.compute/destroy-node (node/compute-service node) node))
  (images [compute] (mapcat pallet.compute/images (services service-map)))
  (close [compute] (mapcat pallet.compute/close (services service-map)))
  pallet.environment.Environment
  (environment [_]
    (apply merge (conj (map pallet.environment/environment
                                     (vals service-map))
                                environment))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ensure-service-dispatch
  [f]
  (fn [service-map group-spec]
    (service-map
     (or
      (f service-map group-spec)
      (throw
       (RuntimeException.
        (str &quot;No dispatch for group &quot; group-spec)))))))</pre></td></tr><tr><td class="docs"><p>Return a dispatch function based on a map from service to groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-dispatcher
  [groups-for-services]
  (let [g-&gt;s (into {} (apply concat
                             (for [[service groups] groups-for-services]
                               (map #(vector % service) groups))))]
    (logging/infof &quot;Hybrid dispatch function: %s&quot; g-&gt;s)
    (fn group-dispatch-fn
      [spec-or-name]
      (if (string? spec-or-name)
        (g-&gt;s (keyword spec-or-name))
        (g-&gt;s (:group-name spec-or-name))))))</pre></td></tr><tr><td class="docs"><p>service factory implementation for hybrid provider</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn compute-provider-from-definition [definition]
  (if (map? definition)
    (configure/compute-service-from-map definition)
    definition))</pre></td></tr><tr><td class="docs"><p>sub-services is either a sequence of service keywords, or a map
from service name to a service configuration map.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod implementation/service :hybrid
  [provider {:keys [sub-services
                    groups-for-services
                    service-dispatcher
                    environment]
             :as options}]
  (let [service-map
        (if (map? sub-services)
          (zipmap (keys sub-services)
                  (map compute-provider-from-definition (vals sub-services)))
          (into {} (map #(vector % (configure/compute-service %)) sub-services)))]
    (logging/infof &quot;sub-services for hybrid provider: %s&quot; service-map)
    (logging/debugf &quot;groups-for-services map: %s&quot; groups-for-services)
    (HybridService.
     service-map
     (or (and
          service-dispatcher
          (ensure-service-dispatch service-dispatcher))
         (and
          groups-for-services
          (ensure-service-dispatch (group-dispatcher groups-for-services))))
     environment)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.implementation" name="pallet.compute.implementation"><h1 class="project-name">pallet.compute.implementation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation details</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.compute.implementation
  (:require
   [chiba.plugin :refer [plugins]]
   [clojure.tools.logging :as logging]))</pre></td></tr><tr><td class="docs"><p>Instantiate a compute service. Providers should implement a method for this.
   See pallet.compute/instantiate-provider.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti service
  (fn [provider-name &amp; _] (keyword provider-name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def compute-prefix &quot;pallet.compute&quot;)
(def exclude-compute-ns
  #{'pallet.compute
    'pallet.compute.jvm
    'pallet.compute.implementation})
(def exclude-regex #&quot;.*test.*&quot;)
(def provider-list (atom nil))</pre></td></tr><tr><td class="docs"><p>Find the available providers.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- providers
  []
  (-&gt;&gt; (plugins compute-prefix exclude-regex)
       (remove exclude-compute-ns)))</pre></td></tr><tr><td class="docs"><p>Require all providers, ensuring no errors if individual providers can not be
   loaded</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-providers
  []
  (when-not @provider-list
    (reset! provider-list (providers))
    (let [loaded (filter
                  identity
                  (doall
                   (for [provider @provider-list]
                     (try
                       (require provider)
                       provider
                       (catch Throwable e
                         (logging/debugf
                          &quot;%s provider failed to load: %s&quot;
                          provider
                          (.getMessage e)))))))]
      (reset! provider-list loaded)))
  @provider-list)</pre></td></tr><tr><td class="docs"><p>Create a list of supported providers</p>
</td><td class="codes"><pre class="brush: clojure">(defn supported-providers
  []
  (-&gt;&gt;
   (doall
    (for [provider (load-providers)]
      (when-let [providers (ns-resolve provider 'supported-providers)]
        (@providers))))
   (filter identity)
   (apply concat)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.jvm" name="pallet.compute.jvm"><h1 class="project-name">pallet.compute.jvm</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Information from local jvm</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.compute.jvm )</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def jvm-os-map
  {&quot;Mac OS X&quot; :os-x})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn os-name []
  (System/getProperty &quot;os.name&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn os-family []
  (or (jvm-os-map (os-name)) :ubuntu))</pre></td></tr><tr><td class="docs"><p>Predicate to test for log4j on the classpath.</p>
</td><td class="codes"><pre class="brush: clojure">(defn log4j?
  []
  (try
    (import org.apache.log4j.Logger)
    true
    (catch java.lang.ClassNotFoundException _
      false)))</pre></td></tr><tr><td class="docs"><p>Predicate to test for slf4j on the classpath.</p>
</td><td class="codes"><pre class="brush: clojure">(defn slf4j?
  []
  (try
    (import org.slf4j.LoggerFactory)
    true
    (catch java.lang.ClassNotFoundException _
      false)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.localhost" name="pallet.compute.localhost"><h1 class="project-name">pallet.compute.localhost</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Localhost provider service implementation.</p>

<p>This enables your localhost to masquerade as a node for any group.</p>

<p><code>run-nodes</code> will set the group-name for the localhost node, but is otherwise a
no-op.  The localhost node is marked as bootstrapped to prevent bootstrap
actions from occurring on group-name changes.</p>

<p>Node removal functions are no-ops.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.compute.localhost
  (:require
   [pallet.compute :as compute]
   [pallet.compute.implementation :as implementation]
   [pallet.compute.node-list :as node-list]
   [pallet.core.api :refer [set-state-for-node]]
   [pallet.node :as node]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype NodeTagEphemeral
    [tags]
  pallet.compute.NodeTagReader
  (node-tag [_ node tag-name]
    (@tags tag-name))
  (node-tag [_ node tag-name default-value]
    (@tags tag-name default-value))
  (node-tags [_ node]
    @tags)
  pallet.compute.NodeTagWriter
  (tag-node! [_ node tag-name value]
    (swap! tags assoc tag-name value))
  (node-taggable? [_ node] true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype LocalhostService [node environment tag-provider]
  pallet.compute/ComputeService
  (nodes [compute] [@node])
  (run-nodes [compute group-spec node-count user init-script options]
    (reset! node (node-list/make-localhost-node
                  :group-name (:group-name group-spec)
                  :service compute))
    ;; make sure we don't bootstrap
    (set-state-for-node :bootstrapped {:node @node})
    [@node])
  (reboot [compute nodes])
  (boot-if-down [compute nodes])
  (shutdown-node [compute node user])
  (shutdown [compute nodes user])
  (ensure-os-family [compute group-spec]
    (update-in group-spec [:image]
               #(merge {:os-family (node/os-family @node)
                        :os-version (node/os-version @node)})))
  (destroy-nodes-in-group [compute group-name])
  (destroy-node [compute node])
  (images [compute])
  (close [compute])
  pallet.environment.Environment
  (environment [_] environment)
  pallet.compute.NodeTagReader
  (node-tag [compute node tag-name]
    (compute/node-tag tag-provider node tag-name))
  (node-tag [compute node tag-name default-value]
    (compute/node-tag tag-provider node tag-name default-value))
  (node-tags [compute node]
    (compute/node-tags tag-provider node))
  pallet.compute.NodeTagWriter
  (tag-node! [compute node tag-name value]
    (compute/tag-node! tag-provider node tag-name value))
  (node-taggable? [compute node]
    (compute/node-taggable? tag-provider node))
  pallet.compute.ComputeServiceProperties
  (service-properties [_]
    {:provider :localhost
     :environment environment}))</pre></td></tr><tr><td class="docs"><p>Compute Service SPI</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn supported-providers
  {:no-doc true
   :doc &quot;Returns a sequence of providers that are supported&quot;}
  [] [&quot;localhost&quot;])</pre></td></tr><tr><td class="docs"><p>service factory implementation for localhost provider</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod implementation/service :localhost
  [provider {:keys [environment tag-provider]
             :or {tag-provider (-&gt;NodeTagEphemeral (atom {}))}
             :as options}]
  (let [service (LocalhostService. (atom nil) environment tag-provider)
        node (node-list/make-localhost-node :service service)]
    (reset! (.node service) node)
    (set-state-for-node :bootstrapped {:node node})
    service))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.node-list" name="pallet.compute.node-list"><h1 class="project-name">pallet.compute.node-list</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A simple node list provider.</p>

<p>   The node-list provider enables pallet to work with a server rack or existing
   virtual machines. It works by maintaining a list of nodes. Each node
   minimally provides an IP address, a host name, a group name and an operating
   system. Nodes are constructed using <code>make-node</code>.</p>

<p>   An instance of the node-list provider can be built using
   <code>node-list-service</code>.</p>

<pre><code>   (node-list-service
     [["host1" "fullstack" "192.168.1.101" :ubuntu]
      ["host2" "fullstack" "192.168.1.102" :ubuntu]])
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.compute.node-list
  (:require
   [clojure.string :as string]
   [pallet.compute :as compute]
   [pallet.compute.implementation :as implementation]
   [pallet.compute.jvm :as jvm]
   [pallet.environment :as environment]
   [pallet.node :as node]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Node
    [name group-name ip os-family os-version id ssh-port private-ip is-64bit
     running service hardware proxy image-user]
  pallet.node.Node
  (ssh-port [node] ssh-port)
  (primary-ip [node] ip)
  (private-ip [node] private-ip)
  (is-64bit? [node] (:is-64bit node))
  (group-name [node] group-name)
  (running? [node] running)
  (terminated? [node] (not running))
  (os-family [node] os-family)
  (os-version [node] os-version)
  (hostname [node] name)
  (id [node] id)
  (compute-service [node] service)
  pallet.node.NodePackager
  (packager [node] (compute/packager-for-os os-family os-version))
  pallet.node.NodeHardware
  (hardware [node] hardware)
  pallet.node.NodeImage
  (image-user [node] image-user)
  pallet.node.NodeProxy
  (proxy [node] proxy))</pre></td></tr><tr><td class="docs"><p>Returns a node, suitable for use in a node-list.</p>

<p>Node utilities</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-node
  [name group-name ip os-family
   &amp; {:keys [id ssh-port private-ip is-64bit running os-version service
             hardware proxy image-user]
      :or {ssh-port 22 is-64bit true running true}}]
  (Node.
   name
   group-name
   ip
   os-family
   os-version
   (or id (str name &quot;-&quot; (string/replace ip #&quot;\.&quot; &quot;-&quot;)))
   ssh-port
   private-ip
   is-64bit
   running
   service
   hardware
   proxy
   image-user))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype NodeTagStatic
    [static-tags]
  pallet.compute.NodeTagReader
  (node-tag [_ node tag-name]
    (get static-tags tag-name))
  (node-tag [_ node tag-name default-value]
    (or (get static-tags tag-name) default-value))
  (node-tags [_ node]
    static-tags)
  pallet.compute.NodeTagWriter
  (tag-node! [_ node tag-name value]
    (throw
     (ex-info
      &quot;Attempt to call node-tags on a node that doesn't support mutable tags.
You can pass a :tag-provider to the compute service constructor to enable
support.&quot;
      {:reason :unsupported-operation
       :operation :pallet.compute/node-tags})))
  (node-taggable? [_ node] false))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype NodeList
    [node-list environment tag-provider]
  pallet.compute.ComputeService
  (nodes [compute-service] @node-list)
  (ensure-os-family
    [compute-service group-spec]
    (when (not (-&gt; group-spec :image :os-family))
      (throw
       (ex-info
        &quot;Node list contains a node without os-family&quot;
        {:type :no-os-family-specified}))))
  ;; Not implemented
  (run-nodes [compute group-spec node-count user init-script options]
    nil)
  ;; (reboot &quot;Reboot the specified nodes&quot;)
  (boot-if-down [compute nodes] nil)
  ;; (shutdown-node &quot;Shutdown a node.&quot;)
  ;; (shutdown &quot;Shutdown specified nodes&quot;)
  ;; this forgets about the nodes
  (destroy-nodes-in-group [_ group]
    (swap! node-list (fn [nl] (remove #(= (node/group-name %) group) nl))))
  (close [compute])
  pallet.environment.Environment
  (environment [_] environment)
  pallet.compute.NodeTagReader
  (node-tag [compute node tag-name]
    (compute/node-tag tag-provider node tag-name))
  (node-tag [compute node tag-name default-value]
    (compute/node-tag tag-provider node tag-name default-value))
  (node-tags [compute node]
    (compute/node-tags tag-provider node))
  pallet.compute.NodeTagWriter
  (tag-node! [compute node tag-name value]
    (compute/tag-node! tag-provider node tag-name value))
  (node-taggable? [compute node]
    (compute/node-taggable? tag-provider node))
  pallet.compute.ComputeServiceProperties
  (service-properties [_]
    {:provider :node-list
     :nodes @node-list
     :environment environment}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod clojure.core/print-method Node
  [^Node node ^java.io.Writer writer]
  (.write
   writer
   (format
    &quot;%14s\t %s %s public: %s  private: %s  %s&quot;
    (:group-name node)
    (:os-family node)
    (:running node)
    (:ip node)
    (:private-ip node)
    (:id node))))</pre></td></tr><tr><td class="docs"><p>Make a node representing the local host. This calls <code>make-node</code> with values
   inferred for the local host. Takes options as for <code>make-node</code>.</p>

<pre><code>   :name "localhost"
   :group-name "local"
   :ip "127.0.0.1"
   :os-family (pallet.compute.jvm/os-family)
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn make-localhost-node
  [&amp; {:keys [name group-name ip os-family id]
      :or {name &quot;localhost&quot;
           group-name &quot;local&quot;
           ip &quot;127.0.0.1&quot;
           os-family (jvm/os-family)}
      :as options}]
  (apply
   make-node name group-name ip os-family
   (apply concat (merge {:id &quot;localhost&quot;} options))))</pre></td></tr><tr><td class="docs"><p>Compute Service SPI</p>
</td><td class="codes"><pre class="brush: clojure">(defn supported-providers
  {:no-doc true
   :doc &quot;Returns a sequence of providers that are supported&quot;}
  [] [&quot;node-list&quot;])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod implementation/service :node-list
  [_ {:keys [node-list environment tag-provider]
      :or {tag-provider (NodeTagStatic. {&quot;pallet/state&quot; &quot;{:bootstrapped true}&quot;})}}]
  (let [nodes (atom (vec
                     (map
                      #(if (vector? %)
                         (apply make-node %)
                         %)
                      node-list)))
        nodelist (NodeList. nodes environment tag-provider)]
    (swap! nodes #(map (fn [node] (assoc node :service nodelist)) %))
    nodelist))</pre></td></tr><tr><td class="docs"><p>Create a node-list compute service, based on a sequence of nodes. Each
   node is passed as either a node object constructed with <code>make-node</code>,
   or as a vector of arguments for <code>make-node</code>.</p>

<p>   Optionally, an environment map can be passed using the :environment keyword.
   See <code>pallet.environment</code>.</p>

<p>Compute service constructor</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-list-service
  {:added &quot;0.6.8&quot;}
  [node-list &amp; {:keys [environment tag-provider] :as options}]
  (apply-map
   compute/instantiate-provider
   :node-list (assoc options :node-list node-list)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.config-file.format" name="pallet.config-file.format"><h1 class="project-name">pallet.config-file.format</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Some standard file formating.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.config-file.format
  (:require
   [clojure.string :as string]))</pre></td></tr><tr><td class="docs"><p>A property file.
   The properties are written "key value", one per line.
     m                   a key-value map
     :separator chars    separator to use between key and value
                         (default is a single space)</p>
</td><td class="codes"><pre class="brush: clojure">(defn name-values
  [m &amp; {:keys [separator] :or {separator &quot; &quot;}}]
  (string/join
   (map
    (fn [[key-name value]] (format &quot;%s%s%s\n&quot; (name key-name) separator value))
    m)))</pre></td></tr><tr><td class="docs"><p>A sectioned property file.
   This is modeled as a map of maps. The keys of the outer map are the section
   names.  The inner maps are keyword value maps.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sectioned-properties
  [m &amp; {:keys [separator] :or {separator &quot; = &quot;}}]
  (letfn [(format-section
           [[section-name kv-map]]
           (format
            &quot;[%s]\n%s\n&quot; (name section-name)
                         (name-values kv-map :separator separator)))]
    (string/join (map format-section m))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.configure" name="pallet.configure"><h1 class="project-name">pallet.configure</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet configuration using ~/.pallet/config.clj, the pallet.config namespace
   or from settings.xml.</p>

<p>   config.clj should be in ~/.pallet or a directory specified by the PALLET_HOME
   environment variable.</p>

<p>   service definitions can also be specified as clojure maps in
   ~/.pallet/services/*.clj</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.configure
  (:require
   [chiba.plugin :refer [data-plugins]]
   [clojure.core.incubator :refer [-?&gt;]]
   [clojure.java.io :as java-io]
   [clojure.java.io :refer [resource]]
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [clojure.walk :as walk]
   [pallet.blobstore :as blobstore]
   [pallet.common.deprecate :as deprecate]
   [pallet.compute :refer [instantiate-provider]]
   [pallet.core.user :refer [make-user]]
   [pallet.environment :as environment]
   [pallet.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>A var to be set by defpallet, so that it may be loaded from any
             namespace</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true
       :doc }
  config nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- unquote-vals [args]
  (walk/walk
   (fn [item]
     (cond (and (seq? item) (= `unquote (first item))) (second item)
           ;; needed if we want fn literals to be usable by eval-in-project
           (and (seq? item) (= 'fn (first item))) (list 'quote item)
           (symbol? item) (list 'quote item)
           :else (unquote-vals item)))
   identity
   args))</pre></td></tr><tr><td class="docs"><p>Top level macro for the pallet config.clj file.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defpallet
  [&amp; {:keys [provider identity credential providers admin-user]
      :as config-options}]
  `(let [m# (zipmap
             ~(cons 'list (keys config-options))
             ~(cons 'list (unquote-vals (vals config-options))))]
    (alter-var-root #'config (fn [_#] m#))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- read-config
  [file]
  (try
    (use '[pallet.configure :only [defpallet]])
    (load-file file)
    config
    (catch java.io.FileNotFoundException _)))</pre></td></tr><tr><td class="docs"><p>Returns full path to Pallet home dir ($PALLET_HOME or $HOME/.pallet)</p>
</td><td class="codes"><pre class="brush: clojure">(defn- home-dir
  []
  (.getAbsolutePath
   (doto (if-let [pallet-home (System/getenv &quot;PALLET_HOME&quot;)]
           (java.io.File. pallet-home)
           (java.io.File. (System/getProperty &quot;user.home&quot;) &quot;.pallet&quot;))
     .mkdirs)))</pre></td></tr><tr><td class="docs"><p>Returns a java.io.File for the user's config.clj file</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^java.io.File config-file-path
  []
  (java-io/file (home-dir) &quot;config.clj&quot;))</pre></td></tr><tr><td class="docs"><p>Read all service definitions in ${PALLET_HOME:~/.pallet}/services.</p>
</td><td class="codes"><pre class="brush: clojure">(defn service-files
  []
  (for [file (filter
               #(and (.isFile ^java.io.File %)
                     (.endsWith (.getName ^java.io.File %) &quot;.clj&quot;))
               (file-seq (java-io/file (home-dir) &quot;services&quot;)))]
     (read-string (slurp file))))</pre></td></tr><tr><td class="docs"><p>Read all service definitions in pallet_services/ resources.</p>
</td><td class="codes"><pre class="brush: clojure">(defn service-resources
  []
  (for [path (data-plugins &quot;pallet_services/&quot; #&quot;\.DS_Store&quot;)]
    (read-string (slurp (resource path)))))</pre></td></tr><tr><td class="docs"><p>Read pallet configuration from config.clj and services/*.clj files. The
   files are taken from ~/.pallet or $PALLET_HOME if set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pallet-config
  []
  (reduce
   (fn [config service]
     (try
       (assoc-in config [:services (key (first service))] (val (first service)))
       (catch Exception e
         (logging/errorf
          e &quot;Incorrect service definition %s&quot;
          (pr-str service))
         (throw
          (ex-info
           &quot;Incorrect service definition&quot;
           {:reason :invalid-service-definition
            :path (.getAbsolutePath (config-file-path))
            :service (pr-str service)})))))
   (if (.exists (config-file-path))
     (try
       (read-config (.getAbsolutePath (config-file-path)))
       (catch Exception e
         (logging/errorf
          e &quot;Failed to read %s&quot; (.getAbsolutePath (config-file-path)))
         (throw
          (ex-info
           (str &quot;Failed to read &quot; (.getAbsolutePath (config-file-path)))
           {:reason :failed-to-read-pallet-config
            :path (.getAbsolutePath (config-file-path))}
           e))))
     {})
   (concat (service-resources) (service-files))))</pre></td></tr><tr><td class="docs"><p>Provide deprecation warnings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- check-deprecations
  [config]
  (when (:providers config)
    (deprecate/warn
     (str
      &quot;Use of :providers key in ~/.pallet/config.clj is &quot;
      &quot;deprecated. Please change to use :services.&quot;))))</pre></td></tr><tr><td class="docs"><p>Returns the default compute service</p>

<p>Compute service</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-compute-service
  [config]
  (or (:default-service config)         ; explicit default
      (and            ; default service specified by top level keys in defpallet
       (-&gt;&gt; [:provider :identity :credential]
            (map (or config {}))
            (every? identity))
       ::default)
      (first (keys (:services config))))) ; the &quot;first&quot; specified</pre></td></tr><tr><td class="docs"><p>Helper to read compute service properties. Given a config file return the
   selected service definition as a map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-properties
  [config service]
  (when config
    (let [default-service (map config [:provider :identity :credential])
          services (:services config (:providers config))
          environment (when-let [env (:environment config)]
                        (environment/eval-environment env))]
      (logging/debugf
       &quot;compute-service-properties service: %s available: %s&quot;
       service (keys services))
      (cond
        (= service ::default) (-&gt;
                               (select-keys
                                config
                                [:provider :identity :credential
                                 :blobstore :endpoint
                                 :environment])
                               (utils/maybe-update-in
                                [:environment]
                                (fn [env] environment)))
        ;; pick from specified services
        (map? services) (-&gt;
                         ;; ensure that if services is specified as a
                         ;; vector of keyword value vectors, that
                         ;; it is converted into a map first.
                         (let [services (into {} services)]
                           (or
                            (services (keyword service))
                            (services service)))
                         ;; merge any top level environment with the service
                         ;; specific environment
                         (utils/maybe-update-in
                          [:environment]
                          #(environment/merge-environments
                            environment
                            (environment/eval-environment %))))
        :else nil))))</pre></td></tr><tr><td class="docs"><p>Create a compute service from a credentials map.
   Uses the :provider, :identity, :credential, :extensions and :node-list keys.
   The :extensions and :node-list keys will be read with read-string if they
   are strings.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-from-map
  [credentials]
  (let [options (-&gt;
                 credentials
                 (update-in [:extensions]
                            #(if (string? %)
                               (map read-string (string/split % #&quot; &quot;))
                               %))
                 (update-in [:node-list] #(if (string? %) (read-string %) %))
                 (update-in [:environment] #(environment/eval-environment %)))]
    (when-let [provider (:provider options)]
      (apply
       instantiate-provider
       provider
       (apply concat (filter second (dissoc options :provider)))))))</pre></td></tr><tr><td class="docs"><p>Compute service from a defpallet configuration map and a service keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-from-config
  [config service provider-options]
  (check-deprecations config)
  (compute-service-from-map
   (merge
    (compute-service-properties
     config (or service (default-compute-service config)))
    provider-options)))</pre></td></tr><tr><td class="docs"><p>Checks to see if pallet.config/service is a var, and if so returns its
  value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-from-config-var
  []
  (utils/find-var-with-require 'pallet.config 'service))</pre></td></tr><tr><td class="docs"><p>If the pallet.config.service property is defined, and refers to a var, then
   return its value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-from-property
  []
  (when-let [property (System/getProperty &quot;pallet.config.service&quot;)]
    (when-let [sym-names (and (re-find #&quot;/&quot; property)
                              (string/split property #&quot;/&quot;))]
      (utils/find-var-with-require
       (symbol (first sym-names)) (symbol (second sym-names))))))</pre></td></tr><tr><td class="docs"><p>Return a compute service from the configuration in <code>~/.pallet/config.clj</code> and
<code>~/.pallet/service/*.clj</code>.</p>

<p><code>service</code> is a keyword used to find an entry in the :services map.</p>

<p><code>provider-options</code> is a map of provider options to be merged
with the service configuration in the configuration file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-from-config-file
  ([service provider-options]
     (compute-service-from-config (pallet-config) service provider-options))
  ([]
     (let [config (pallet-config)]
       (compute-service-from-config
        config (default-compute-service config) {}))))</pre></td></tr><tr><td class="docs"><p>Instantiate a compute service.</p>

<p>   If passed no arguments, then the compute service is looked up in the
   following order:
   - from a var referenced by the pallet.config.service system property
   - from pallet.config/service if defined
   - the first service in config.clj
   - the service from the first active profile in settings.xml</p>

<p>   If passed a service name, it is looked up in external
   configuration (~/.pallet/config.clj or ~/.m2/settings.xml). A service name is
   one of the keys in the :services map in config.clj, or a profile id in
   settings.xml.</p>

<p>   When passed a provider name and credentials, the service is instantiated
   based on the credentials.  The provider name should be a recognised provider
   name (see <code>pallet.compute/supported-providers</code> to obtain a list of these).</p>

<p>   The other arguments are keyword value pairs.
   - :identity     username or key
   - :credential   password or secret
   - :extensions   extension modules for jclouds
   - :node-list    a list of nodes for the "node-list" provider.
   - :environment  an environment map with service specific values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service
  ([]
     (or
      (compute-service-from-property)
      (compute-service-from-config-var)
      (compute-service-from-config-file)))
  ([service-name &amp; {:as options}]
     (or
      (compute-service-from-config-file service-name options)
      (throw
       (ex-info
        (str &quot;Could not find a configuration for service: &quot; service-name)
        {:service-name service-name})))))</pre></td></tr><tr><td class="docs"><p>Blobstore</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Translate compute provider to associated blobstore provider</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  blobstore-lookup
  {&quot;cloudservers&quot; &quot;cloudfiles&quot;
   &quot;cloudservers-us&quot; &quot;cloudfiles-us&quot;
   &quot;cloudservers-eu&quot; &quot;cloudfiles-eu&quot;
   &quot;ec2&quot; &quot;s3&quot;
   &quot;aws-ec2&quot; &quot;aws-s3&quot;})</pre></td></tr><tr><td class="docs"><p>Create a blobstore service from a credentials map.
   Uses :provider, :identity, :credential and
   :blobstore-provider, :blobstore-identity and :blobstore-credential.
   Blobstore keys fall back to the compute keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-from-map
  [credentials]
  (when-let [provider (or (:blobstore-provider credentials)
                          (blobstore-lookup (:provider credentials)))]
    (blobstore/service
     provider
     :identity (or (:blobstore-identity credentials)
                   (:identity credentials))
     :credential (or (:blobstore-credential credentials)
                     (:credential credentials)))))</pre></td></tr><tr><td class="docs"><p>Create a blobstore service form a configuration map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-from-config
  [config service options]
  (let [config (merge (compute-service-properties config service) options)
        {:keys [provider identity credential]} (merge
                                                (update-in
                                                 config [:provider]
                                                 (fn [p]
                                                   (blobstore-lookup p)))
                                                (:blobstore config))]
    (when provider
      (blobstore/service provider :identity identity :credential credential))))</pre></td></tr><tr><td class="docs"><p>Checks to see if pallet.config/service is a var, and if so returns its
  value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-service-from-config-var
  []
  (utils/find-var-with-require 'pallet.config 'blobstore-service))</pre></td></tr><tr><td class="docs"><p>If the pallet.config.service property is defined, and refers to a var, then
   return its value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-service-from-property
  []
  (when-let [property (System/getProperty &quot;pallet.config.blobstore-service&quot;)]
    (when-let [sym-names (and (re-find #&quot;/&quot; property)
                              (string/split property #&quot;/&quot;))]
      (utils/find-var-with-require
       (symbol (first sym-names)) (symbol (second sym-names))))))</pre></td></tr><tr><td class="docs"><p>Create a blobstore service form a configuration map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-service-from-config-file
  ([service options]
     (blobstore-from-config (pallet-config) service options))
  ([]
     (let [config (pallet-config)]
       (blobstore-from-config
        config (default-compute-service config) {}))))</pre></td></tr><tr><td class="docs"><p>Instantiate a blobstore service.</p>

<p>   If passed no arguments, then the blobstore service is looked up in the
   following order:
   - from a var referenced by pallet.config.blobstore-service system property
   - from pallet.config/blobstore-service if defined
   - the first service in config.clj
   - the service from the first active profile in settings.xml</p>

<p>   If passed a service name, it is looked up in external
   configuration (~/.pallet/config.clj or ~/.m2/settings.xml). A service name is
   one of the keys in the :services map in config.clj, or a profile id in
   settings.xml.</p>

<p>   When passed a provider name and credentials, the service is instantiated
   based on the credentials.  The provider name should be a recognised provider
   name (see <code>pallet.blobstore/supported-providers</code> to obtain a list of these).</p>

<p>   The other arguments are keyword value pairs.
   - :identity     username or key
   - :credential   password or secret
   - :extensions   extension modules for jclouds
   - :node-list    a list of nodes for the "node-list" provider.
   - :environment  an environment map with service specific values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-service
  ([]
     (or
      (blobstore-service-from-property)
      (blobstore-service-from-config-var)
      (blobstore-service-from-config-file)))
  ([service-name &amp; {:as options}]
     (blobstore-service-from-config-file service-name options)))</pre></td></tr><tr><td class="docs"><p>Admin user</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>If the pallet.config.admin-user property is defined, and refers to a var
   then return its value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user-from-property
  []
  (when-let [property (System/getProperty &quot;pallet.config.admin-user&quot;)]
    (when-let [sym-names (and (re-find #&quot;/&quot; property)
                              (string/split property #&quot;/&quot;))]
      (utils/find-var-with-require
       (symbol (first sym-names)) (symbol (second sym-names))))))</pre></td></tr><tr><td class="docs"><p>Set the admin user based on pallet.config setup.</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user-from-config-var
  []
  (utils/find-var-with-require 'pallet.config 'admin-user))</pre></td></tr><tr><td class="docs"><p>Set the admin user based on a config map</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user-from-config
  [config]
  (when-let [admin-user (:admin-user config)]
    (make-user (:username admin-user) admin-user)))</pre></td></tr><tr><td class="docs"><p>Create an admin user form a configuration map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user-from-config-file
  []
  (admin-user-from-config (pallet-config)))</pre></td></tr><tr><td class="docs"><p>Instantiate an admin-user.</p>

<p>   If passed no arguments, then the blobstore service is looked up in the
   following order:
   - from a var referenced by pallet.config.admin-user system property
   - from pallet.config/admin-user if defined
   - the :admin-user top level key in config.clj</p>

<p>   Service specific admin-user values should be specified through a :user
   key on the :environment for the service.</p>

<p>   The other arguments are keyword value pairs.
   - :identity     username or key
   - :credential   password or secret
   - :extensions   extension modules for jclouds
   - :node-list    a list of nodes for the "node-list" provider.
   - :environment  an environment map with service specific values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user
  ([]
     (or
      (admin-user-from-property)
      (admin-user-from-config-var)
      (admin-user-from-config-file))))</pre></td></tr><tr><td class="docs"><p>Service map</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Instantiate service objects. The service objects are returned in a map
   with keys as expected by <code>configure</code> or <code>lift</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn service-map
  ([]
     {:compute (compute-service)
      :blobstore (blobstore-service)
      :user (admin-user)})
  ([service-name]
     {:compute (compute-service service-name)
      :blobstore (blobstore-service service-name)
      :user (admin-user)}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.context" name="pallet.context"><h1 class="project-name">pallet.context</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides contexts for exceptions, logging, etc</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.context
  (:require
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.common.context :as context]
   [pallet.common.logging.logutils :as logutils]
   [pallet.event :as event]))</pre></td></tr><tr><td class="docs"><p>Return the :kw context entries for a context</p>
</td><td class="codes"><pre class="brush: clojure">(defn kw-context-entries
  ([context]
     (mapcat
      (fn kw-context-for-key [key]
        (map :kw (get context key)))
      (::key-stack context)))
  ([] (kw-context-entries context/*current-context*)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn possibly-formatted-msg
  [msg]
  (if (vector? msg)
    `(apply format ~msg)
    msg))</pre></td></tr><tr><td class="docs"><p>Specifies a context for pallet implementation code.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [event/publish #'logutils/with-context]}
  with-context
  {:indent 1}
  [context &amp; body]
  (let [line (-&gt; &amp;form meta :line)]
    `(let [c# (merge
               {:ns ~(list 'quote (ns-name *ns*)) :line ~line :log-level :trace}
               ~context)]
       (context/with-context
         c#
         {:scope :pallet/pallet
          :on-enter (context/context-history {})
          :format :msg}
         (event/publish c#)
         (logutils/with-context
           [~@(mapcat identity (dissoc context :kw :msg))]
           ~@body)))))</pre></td></tr><tr><td class="docs"><p>Returns all pallet contexts</p>
</td><td class="codes"><pre class="brush: clojure">(defn contexts
  []
  (when (bound? #'pallet.common.context/*current-context*)
    (context/scope-formatted-context-entries :pallet/pallet)))</pre></td></tr><tr><td class="docs"><p>Returns all phase contexts</p>

<p>Phase contexts</p>
</td><td class="codes"><pre class="brush: clojure">(defn phase-contexts
  []
  (when (bound? #'pallet.common.context/*current-context*)
    (seq (context/scope-formatted-context-entries :pallet/phase))))</pre></td></tr><tr><td class="docs"><p>Specifies a context inside a phase function</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'context/with-context event/publish]}
  with-phase-context
  [context &amp; body]
  (let [line (-&gt; &amp;form meta :line)]
    `(let [c# (merge
               {:ns ~(list 'quote (ns-name *ns*)) :line ~line :log-level :trace}
               ~context)]
       (context/with-context
         c#
         {:scope :pallet/phase
          :on-enter (context/context-history {})
          :format :msg}
         (event/publish c#)
         ~@body))))</pre></td></tr><tr><td class="docs"><p>Specifies a context in a threaded phase function</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro phase-context
  [session context-kw context-msg &amp; body]
  `(let [session# ~session]
     (with-phase-context ~context-kw ~context-msg
       (-&gt; session# ~@body))))</pre></td></tr><tr><td class="docs"><p>Returns all phase contexts</p>
</td><td class="codes"><pre class="brush: clojure">(defn phase-context-scope
  []
  (when (bound? #'pallet.common.context/*current-context*)
    (context/scope-context-entries :pallet/phase)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro in-phase-context-scope
  {:indent 1}
  [context &amp; body]
  `(if (bound? #'pallet.common.context/*current-context*)
     (context/in-context
       ~context
       {:scope :pallet/phase
        :on-enter (context/context-history {})
        :format :msg}
       ~@body)
     (do ~@body)))</pre></td></tr><tr><td class="docs"><p>exceptions</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro invalid-argument
  [message problem-message value]
  `(let [m# ~message
         p# ~problem-message
         v# ~value]
     (context/throw-map
      (str m#  &quot;: &quot; v# &quot; &quot; p#)
      {:type :pallet/invalid-argument
       :argument v#
       :problem p#})))</pre></td></tr><tr><td class="docs"><p>logging</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'logging/info string/join]} infof
  [fmt &amp; fmtargs]
  `(logging/infof
    (str (string/join &quot;, &quot; (context/formatted-context-entries)) &quot;: &quot; ~fmt)
    ~@fmtargs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro warnf
  [fmt &amp; fmtargs]
  `(logging/warnf
    (str (string/join &quot;, &quot; (context/formatted-context-entries)) &quot;: &quot; ~fmt)
    ~@fmtargs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro debugf
  [fmt &amp; fmtargs]
  `(logging/debugf
    (str (string/join &quot;, &quot; (context/formatted-context-entries)) &quot;: &quot; ~fmt)
    ~@fmtargs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro tracef
  [fmt &amp; fmtargs]
  `(logging/tracef
    (str (string/join &quot;, &quot; (context/formatted-context-entries)) &quot;: &quot; ~fmt)
    ~@fmtargs))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.contracts" name="pallet.contracts"><h1 class="project-name">pallet.contracts</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contracts that can be enforced in pallet code.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.contracts
  (:require
   [clj-schema.schema
    :refer [constraints
            def-map-schema
            map-schema
            optional-path
            seq-schema
            sequence-of
            set-of
            wild]]
   [clj-schema.validation :refer [validation-errors]]
   [clojure.string :as string]
   [clojure.string :refer [join]]
   [clojure.tools.logging :refer [tracef errorf]]
   [pallet.blobstore :refer [blobstore?]]
   [pallet.compute :refer [compute-service?]])
  (:import clojure.lang.IFn
           clojure.lang.Keyword))</pre></td></tr><tr><td class="docs"><p>We put all the contract code here to hide the implementation of the contract
checks.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Basic types</h2>
</td><td class="codes"><pre class="brush: clojure">(def any-value (constantly true))
(def bytes? #(= (class (byte-array [])) (class %)))</pre></td></tr><tr><td class="docs"><h2>Schema types</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>node-spec contains loose schema, as these vary by, and should be enforced by
the providers.</p>
</td><td class="codes"><pre class="brush: clojure">(def-map-schema :loose image-spec-schema
  [(optional-path [:image-id]) [:or String Keyword]
   (optional-path [:image-description-matches]) String
   (optional-path [:image-name-matches]) String
   (optional-path [:image-version-matches]) String
   (optional-path [:os-family]) Keyword
   (optional-path [:os-64-bit]) any-value
   (optional-path [:os-arch-matches]) String
   (optional-path [:os-description-matches]) String
   (optional-path [:os-name-matches]) String
   (optional-path [:os-version-matches]) String
   (optional-path [:hypervisor-matches]) String
   (optional-path [:override-login-user]) String])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema :loose location-spec-schema
  [(optional-path [:location-id]) String])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema :loose hardware-spec-schema
  [(optional-path [:hardware-id]) String
   (optional-path [:min-ram]) Number
   (optional-path [:min-cores]) Number
   (optional-path [:min-disk]) Number])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema inbound-port-spec-schema
  [[:start-port] Number
   (optional-path [:end-port]) Number
   (optional-path [:protocol]) String])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def inbound-port-schema
  [:or inbound-port-spec-schema Number])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema :loose network-spec-schema
  [(optional-path [:inbound-ports]) (sequence-of inbound-port-schema)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema :loose qos-spec-schema
  [(optional-path [:spot-price]) Number
   (optional-path [:enable-monitoring]) any-value])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema node-spec-schema
  [(optional-path [:image]) image-spec-schema
   (optional-path [:location]) location-spec-schema
   (optional-path [:hardware]) hardware-spec-schema
   (optional-path [:network]) network-spec-schema
   (optional-path [:qos]) qos-spec-schema
   (optional-path [:provider]) (map-schema :loose [])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema phases-schema
  [[(wild Keyword)] IFn])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema phase-meta-schema
  [(optional-path [:phase-execution-f]) IFn
   (optional-path [:execution-settings-f]) IFn
   (optional-path [:post-phase-f]) IFn
   (optional-path [:post-phase-fsm]) IFn])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema phases-meta-schema
  [[(wild Keyword)] phase-meta-schema])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema server-spec-schema
  node-spec-schema
  [(optional-path [:phases]) phases-schema
   (optional-path [:roles]) (set-of Keyword)
   (optional-path [:packager]) Keyword
   (optional-path [:phases-meta]) phases-meta-schema
   (optional-path [:default-phases]) (sequence-of Keyword)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema group-spec-schema
  node-spec-schema
  server-spec-schema
  [[:group-name] Keyword
   (optional-path [:node-filter]) IFn
   (optional-path [:count]) Number])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema user-schema
  (constraints
   (fn [{:keys [password private-key-path private-key]}]
     (or password private-key private-key-path)))
  [[:username] String
   (optional-path [:password]) [:or String nil]
   (optional-path [:sudo-password]) [:or String nil]
   (optional-path [:no-sudo]) any-value
   (optional-path [:sudo-user]) [:or String nil]
   (optional-path [:temp-key]) any-value
   (optional-path [:private-key-path]) [:or String nil]
   (optional-path [:public-key-path]) [:or String nil]
   (optional-path [:private-key]) [:or String bytes? nil]
   (optional-path [:public-key]) [:or String bytes? nil]
   (optional-path [:passphrase]) [:or String bytes? nil]
   (optional-path [:state-root]) [:or String nil]
   (optional-path [:state-group]) [:or String nil]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema environment-strict-schema
  [(optional-path [:algorithms]) (map-schema :loose [])
   (optional-path [:user]) user-schema
   (optional-path [:executor]) IFn
   (optional-path [:compute]) [:or compute-service? nil]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def phase-with-args-schema
  (seq-schema
   :all
   (constraints (fn [s] (keyword? (first s))))
   any-value))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def phase-schema
  [:or Keyword IFn phase-with-args-schema])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema lift-options-schema
  environment-strict-schema
  [(optional-path [:compute]) [:or compute-service? nil]
   (optional-path [:blobstore]) [:or nil blobstore?]
   (optional-path [:phase]) [:or phase-schema (sequence-of phase-schema)]
   (optional-path [:environment]) (map-schema :loose environment-strict-schema)
   (optional-path [:user]) user-schema
   (optional-path [:consider-groups]) (sequence-of group-spec-schema)
   (optional-path [:phase-execution-f]) IFn
   (optional-path [:execution-settings-f]) IFn
   (optional-path [:partition-f]) IFn
   (optional-path [:post-phase-f]) IFn
   (optional-path [:post-phase-fsm]) IFn
   (optional-path [:async]) any-value
   (optional-path [:timeout-ms]) Number
   (optional-path [:timeout-val]) any-value
   (optional-path [:debug :script-comments]) any-value
   (optional-path [:debug :script-trace]) any-value
   (optional-path [:os-detect]) any-value
   (optional-path [:all-node-set]) set?])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema converge-options-schema
  lift-options-schema
  [[:compute] compute-service?])</pre></td></tr><tr><td class="docs"><p>We use macros so the stack trace reflects the calling location.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *verify-contracts* true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn check-spec* [m spec spec-name line file]
  {:pre [spec]}
  (tracef &quot;check-spec* %s&quot; spec)
  (when *verify-contracts*
    (if-let [errs (seq (validation-errors spec m))]
      (do
        (errorf (str &quot;Invalid &quot; spec-name &quot;:&quot;))
        (doseq [err errs]
          (errorf (str &quot;  &quot; spec-name &quot; error: %s&quot;) err))
        (throw
         (ex-info
          (format (str &quot;Invalid &quot; spec-name &quot;: %s&quot;) (join &quot; &quot; errs))
          {:type :pallet/schema-validation
           :errors errs
           :m m
           :spec spec
           :spec-name spec-name
           :line line
           :file file}))))
    m))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:requires [validation-errors #'errorf join]} check-spec
  [m spec &amp;form]
  (let [spec-name (string/replace (name spec) &quot;-schema&quot; )]
    `(check-spec* ~m ~spec ~spec-name ~(:line (meta &amp;form)) ~*file*)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-node-spec
  [m]
  (check-spec m `node-spec-schema &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-server-spec
  [m]
  (check-spec m `server-spec-schema &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-group-spec
  [m]
  (check-spec m `group-spec-schema &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-user
  [m]
  (check-spec m `user-schema &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-lift-options
  [m]
  (check-spec m `lift-options-schema &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro check-converge-options
  [m]
  (check-spec m `converge-options-schema &amp;form))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn check-keys*
  [m keys spec msg &amp;form]
  `(when *verify-contracts*
     (let [m# (select-keys ~m ~keys)
           spec# ~spec
           msg# ~msg]
       (if-let [errs# (seq (validation-errors spec# m#))]
         (do
           (errorf (str &quot;Invalid &quot; msg#  &quot;:&quot;))
           (doseq [err# errs#]
             (errorf (str &quot;  &quot; msg# &quot; error: %s&quot;) err#))
           (throw
            (ex-info
             (format (str &quot;Invalid &quot; msg# &quot;: %s&quot;) (join &quot; &quot; errs#))
             {:errors errs#
              :line ~(:line (meta &amp;form))
              :file ~*file*}))))
       m#)))</pre></td></tr><tr><td class="docs"><p>Check keys in m</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro check-keys
  [m keys spec msg]
  (check-keys* m keys spec msg &amp;form))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core" name="pallet.core"><h1 class="project-name">pallet.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Namespace for compatibility with pallet 0.7.x and earlier</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core
  (:require
   [flatland.useful.ns :refer [alias-ns]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alias-ns 'pallet.api)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.api" name="pallet.core.api"><h1 class="project-name">pallet.core.api</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Base level API for pallet</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.api
  (:require
   [clojure.algo.monads :refer [domonad m-map state-m with-monad]]
   [clojure.java.io :as io]
   [clojure.string :as string]
   [clojure.string :refer [blank?]]
   [clojure.tools.logging :refer [debugf tracef]]
   [pallet.action :refer [action-options-key get-action-options]]
   [pallet.action-plan :refer [execute stop-execution-on-error translate]]
   [pallet.common.logging.logutils :as logutils]
   [pallet.compute :refer [destroy-node destroy-nodes-in-group nodes run-nodes]]
   [pallet.core.api-impl :refer :all]
   [pallet.core.session :refer [session with-session]]
   [pallet.core.user :refer [obfuscated-passwords]]
   [pallet.executors :refer [default-executor]]
   [pallet.node :refer [id image-user primary-ip tag tag! taggable?]]
   [pallet.session.action-plan
    :refer [assoc-action-plan get-session-action-plan]]
   [pallet.session.verify :refer [add-session-verification-key check-session]]
   [pallet.ssh.file-upload.sftp-upload :refer [sftp-upload]]
   [pallet.stevedore :refer [with-source-line-comments]]
   [pallet.utils :refer [maybe-update-in]]))</pre></td></tr><tr><td class="docs"><p>Returns the pallet version.</p>
</td><td class="codes"><pre class="brush: clojure">(let [v (atom nil)]
  (defn version
    []
    (or
     @v
     (reset! v (System/getProperty &quot;pallet.version&quot;))
     (reset! v (if-let [version (slurp (io/resource &quot;pallet-version&quot;))]
                       (string/trim version))))))</pre></td></tr><tr><td class="docs"><p>Query the available nodes in a <code>compute-service</code>, filtering for nodes in the
  specified <code>groups</code>. Returns a sequence that contains a node-map for each
  matching node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn service-state
  [compute-service groups]
  (let [nodes (remove pallet.node/terminated? (nodes compute-service))]
    (tracef &quot;service-state %s&quot; (vec nodes))
    (filter identity (map (node-&gt;node-map groups) nodes))))</pre></td></tr><tr><td class="docs"><p>Build the action plan for the specified <code>plan-fn</code> on the given <code>node</code>, within
  the context of the <code>service-state</code>. The <code>plan-state</code> contains all the
  settings, etc, for all groups. <code>target-map</code> is a map for the session
  describing the target.</p>

<h2>Action Plan Building</h2>
</td><td class="codes"><pre class="brush: clojure">(defn action-plan
  [service-state environment plan-fn args target-map]
  {:pre [(not (map? plan-fn)) (fn? plan-fn)
         (map? target-map)
         (or (nil? environment) (map? environment))]}
  (fn action-plan [plan-state]
    (tracef &quot;action-plan plan-state %s&quot; plan-state)
    (let [s (with-session
                (add-session-verification-key
                 (merge
                  {:user (:user environment)}
                  target-map
                  {:service-state service-state
                   :plan-state (maybe-update-in
                                plan-state
                                [action-options-key]
                                #(merge (:action-options environment) %))
                   :environment environment}))
              (apply plan-fn args)
              (check-session (session) '(plan-fn))
              (session))]
      (let [[action-plan session] (get-session-action-plan s)
            [action-plan session] (translate action-plan session)]
        [action-plan (:plan-state session)]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn phase-args [phase]
  (if (keyword? phase)
    nil
    (rest phase)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- phase-kw [phase]
  (if (keyword? phase)
    phase
    (first phase)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn target-phase [target phase]
  (-&gt; target :phases (get (phase-kw phase))))</pre></td></tr><tr><td class="docs"><p>Build action plans for the specified <code>phase</code> on all nodes or groups in the
  given <code>target</code>, within the context of the <code>service-state</code>. The <code>plan-state</code>
  contains all the settings, etc, for all groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti target-action-plan
  (fn [service-state plan-state environment phase target]
    (tracef &quot;target-action-plan %s&quot; (:target-type target :node))
    (:target-type target :node)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod target-action-plan :node
  [service-state plan-state environment phase target]
  {:pre [target (:node target)]}
  (fn [plan-state]
    (logutils/with-context [:target (-&gt; target :node primary-ip)]
      (with-script-for-node target plan-state
        ((action-plan
          service-state environment
          (target-phase target phase) (phase-args phase)
          {:server target})
         plan-state)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod target-action-plan :group
  [service-state plan-state environment phase group]
  {:pre [group]}
  (fn [plan-state]
    (logutils/with-context [:target (-&gt; group :group-name)]
      ((action-plan
        service-state environment
        (target-phase group phase) (phase-args phase)
        {:group group})
       plan-state))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn action-plans
  [service-state plan-state environment phase targets]
  (let [targets-with-phase (filter #(target-phase % phase) targets)]
    (tracef
     &quot;action-plans: phase %s targets %s targets-with-phase %s&quot;
     phase (vec targets) (vec targets-with-phase))
    (with-monad state-m
      (domonad
       [action-plans
        (m-map
         #(target-action-plan service-state plan-state environment phase %)
         targets-with-phase)]
       (map
        #(hash-map :target %1 :phase (phase-kw phase) :action-plan %2)
        targets-with-phase action-plans)))))</pre></td></tr><tr><td class="docs"><p>Returns execution settings based purely on the environment</p>

<h2>Action Plan Execution</h2>
</td><td class="codes"><pre class="brush: clojure">(defn environment-execution-settings
  []
  (fn [environment _]
    (debugf &quot;environment-execution-settings %s&quot; environment)
    (debugf &quot;Env user %s&quot; (obfuscated-passwords (:user environment)))
    {:user (:user environment)
     :executor (get-in environment [:algorithms :executor] default-executor)
     :executor-status-fn (get-in environment [:algorithms :execute-status-fn]
                                 #'stop-execution-on-error)}))</pre></td></tr><tr><td class="docs"><p>Returns execution settings based on the environment and the image user.</p>
</td><td class="codes"><pre class="brush: clojure">(defn environment-image-execution-settings
  []
  (fn [environment node]
    (let [user (into {} (filter val (image-user (:node node))))
          user (if (or (:private-key-path user) (:private-key user))
                 (assoc user :temp-key true)
                 user)
          user (if (some user [:private-key-path :private-key :password])
                 user
                 ;; use credentials from the admin user if no
                 ;; credentials are supplied by the image (but allow
                 ;; image to specify the username)
                 (merge
                  (select-keys (:user environment)
                               [:private-key :public-key
                                :public-key-path :private-key-path
                                :password])
                  user))]
      (debugf &quot;Image-user is %s&quot; (pr-str (obfuscated-passwords user)))
      {:user user
       :executor (get-in environment [:algorithms :executor] default-executor)
       :executor-status-fn (get-in environment [:algorithms :execute-status-fn]
                                   #'stop-execution-on-error)})))</pre></td></tr><tr><td class="docs"><p>Execute the <code>action-plan</code> on the <code>target</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-action-plan*
  [session executor execute-status-fn
   {:keys [action-plan phase target-type target]}]
  (tracef &quot;execute-action-plan*&quot;)
  (with-session session
    (let [[result session] (execute
                            action-plan session executor execute-status-fn)]
      {:target target
       :target-type target-type
       :plan-state (:plan-state session)
       :result result
       :phase (phase-kw phase)})))</pre></td></tr><tr><td class="docs"><p>Execute the <code>action-plan</code> on the <code>target</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti execute-action-plan
  (fn [service-state plan-state environment user executor execute-status-fn
       {:keys [action-plan phase target]}]
    (:target-type target :node)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod execute-action-plan :node
  [service-state plan-state environment user executor execute-status-fn
   {:keys [action-plan phase target-type target] :as action-plan-map}]
  (tracef &quot;execute-action-plan :node&quot;)
  (logutils/with-context [:target (-&gt; target :node primary-ip)]
    (with-script-for-node target plan-state
      (execute-action-plan*
       {:server target
        :service-state service-state
        :plan-state plan-state
        :user user
        :environment environment}
       executor execute-status-fn action-plan-map))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod execute-action-plan :group
  [service-state plan-state environment user executor execute-status-fn
   {:keys [action-plan phase target-type target] :as action-plan-map}]
  (tracef &quot;execute-action-plan :group&quot;)
  (logutils/with-context [:target (-&gt; target :group-name)]
    (execute-action-plan*
     {:group target
      :service-state service-state
      :plan-state plan-state
      :user user
      :environment environment}
     executor execute-status-fn action-plan-map)))</pre></td></tr><tr><td class="docs"><p>Calculate actual and required counts for a group</p>

<h2>Calculation of node count adjustments</h2>
</td><td class="codes"><pre class="brush: clojure">(defn group-delta
  [targets group]
  (let [existing-count (count targets)
        target-count (:count group ::not-specified)]
    (when (= target-count ::not-specified)
      (throw
       (ex-info
        (format &quot;Node :count not specified for group: %s&quot; group)
        {:reason :target-count-not-specified
         :group group}) (:group-name group)))
    {:actual existing-count :target target-count
     :delta (- target-count existing-count)}))</pre></td></tr><tr><td class="docs"><p>Calculate actual and required counts for a sequence of groups. Returns a map
  from group to a map with :actual and :target counts.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-deltas
  [targets groups]
  (into
   {}
   (map
    (juxt
     identity
     (fn [group]
       (group-delta (filter #(node-in-group? (:node %) group) targets) group)))
    groups)))</pre></td></tr><tr><td class="docs"><p>Return a sequence of groups that currently have no nodes, but will have nodes
  added.</p>
</td><td class="codes"><pre class="brush: clojure">(defn groups-to-create
  [group-deltas]
  (letfn [(new-group? [{:keys [actual target]}]
            (and (zero? actual) (pos? target)))]
    (-&gt;&gt;
     group-deltas
     (filter #(new-group? (val %)))
     (map key)
     (map (fn [group-spec] (assoc group-spec :target-type :group))))))</pre></td></tr><tr><td class="docs"><p>Return a sequence of groups that have nodes, but will have all nodes
  removed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn groups-to-remove
  [group-deltas]
  (letfn [(remove-group? [{:keys [actual target]}]
            (and (zero? target) (pos? actual)))]
    (-&gt;&gt;
     group-deltas
     (filter #(remove-group? (second %)))
     (map #(assoc (first %) :target-type :group)))))</pre></td></tr><tr><td class="docs"><p>Finds the specified number of nodes to be removed from the given groups.
  Nodes are selected at random. Returns a map from group to a map with
  :servers and :all, where :servers is a sequence of severs to remove, and :all
  is a boolean that is true if all nodes are being removed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nodes-to-remove
  [targets group-deltas]
  (letfn [(pick-servers [[group {:keys [delta target]}]]
            (vector
             group
             {:nodes (take (- delta)
                           (filter #(node-in-group? (:node %) group) targets))
              :all (zero? target)}))]
    (into {}
          (-&gt;&gt;
           group-deltas
           (filter #(when (neg? (:delta (val %))) %))
           (map pick-servers)))))</pre></td></tr><tr><td class="docs"><p>Finds the specified number of nodes to be added to the given groups.
  Returns a map from group to a count of servers to add</p>
</td><td class="codes"><pre class="brush: clojure">(defn nodes-to-add
  [group-deltas]
  (into {}
        (-&gt;&gt;
         group-deltas
         (filter #(when (pos? (:delta (val %))) [(key %) (:delta (val %))])))))</pre></td></tr><tr><td class="docs"><p>Create <code>count</code> nodes for a <code>group</code>.</p>

<h2>Node creation and removal</h2>
</td><td class="codes"><pre class="brush: clojure">(defn create-nodes
  [compute-service environment group count]
  (map
   (fn [node] (assoc group :node node))
   (run-nodes
    compute-service group count
    (:user environment)
    nil
    (:provider-options environment nil))))</pre></td></tr><tr><td class="docs"><p>Removes <code>nodes</code> from <code>group</code>. If <code>all</code> is true, then all nodes for the group
  are being removed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-nodes
  [compute-service group {:keys [nodes all]}]
  (debugf &quot;remove-nodes&quot;)
  (if all
    (destroy-nodes-in-group compute-service (name (:group-name group)))
    (doseq [node nodes] (destroy-node compute-service (:node node)))))</pre></td></tr><tr><td class="docs"><h1>Node state tagging</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def state-tag-name &quot;pallet/state&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn read-or-empty-map
  [s]
  (if (blank? s)
    {}
    (read-string s)))</pre></td></tr><tr><td class="docs"><p>Sets the boolean <code>state-name</code> flag on <code>node</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-state-for-node
  [state-name node]
  (debugf &quot;set-state-for-node %s&quot; state-name)
  (when (taggable? (:node node))
    (debugf &quot;set-state-for-node taggable&quot;)
    (let [current (read-or-empty-map (tag (:node node) state-tag-name))
          val (assoc current (keyword (name state-name)) true)]
      (debugf &quot;set-state-for-node %s %s&quot; state-tag-name (pr-str val))
      (tag! (:node node) state-tag-name (pr-str val)))))</pre></td></tr><tr><td class="docs"><p>Return a predicate to test for a state-flag having been set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn has-state-flag?
  [state-name]
  (fn [node]
    (debugf &quot;has-state-flag %s %s&quot; state-name (id (:node node)))
    (let [v (get
             (read-or-empty-map (tag (:node node) state-tag-name))
             (keyword (name state-name)))]
      (tracef &quot;has-state-flag %s&quot; v)
      v)))</pre></td></tr><tr><td class="docs"><p>Return a sequence of phase errors for an operation.
   Each element in the sequence represents a failed action, and is a map,
   with :target, :error, :context and all the return value keys for the return
   value of the failed action.</p>

<h1>Exception reporting</h1>
</td><td class="codes"><pre class="brush: clojure">(defn phase-errors
  [result]
  (-&gt;&gt;
   (:results result)
   (map #(update-in % [:result] (fn [r] (filter :error r))))
   (mapcat #(map (fn [r] (merge (dissoc % :result) r)) (:result %)))
   seq))</pre></td></tr><tr><td class="docs"><p>Return a sequence of exceptions from phase errors for an operation. </p>
</td><td class="codes"><pre class="brush: clojure">(defn phase-error-exceptions
  [result]
  (-&gt;&gt;  (phase-errors result)
        (map (comp :cause :error))
        (filter identity)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn throw-phase-errors
  [result]
  (when-let [e (phase-errors result)]
    (throw
     (ex-info
      (str &quot;Phase errors: &quot; (string/join &quot; &quot; (map (comp :message :error) e)))
      {:errors e}
      (or (-&gt; (first e) :message :exception)
          (-&gt; (first (remove nil? (map (comp :cause :error) e)))))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.api-impl" name="pallet.core.api-impl"><h1 class="project-name">pallet.core.api-impl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation functions for the core api.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.api-impl
  (:require
   [clojure.tools.logging :refer [debugf warnf]]
   [pallet.compute :refer [packager-for-os]]
   [pallet.core.plan-state :refer [get-settings]]
   [pallet.map-merge :refer [merge-keys]]
   [pallet.node :as node]
   [pallet.script :refer [with-script-context]]
   [pallet.stevedore :refer [with-script-language]]
   [pallet.utils :refer [maybe-assoc]]))</pre></td></tr><tr><td class="docs"><p>Map from key to merge algorithm. Specifies how specs are merged.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  merge-spec-algorithm
  {:phases :merge-phases
   :roles :union
   :group-names :union
   :default-phases :total-ordering})</pre></td></tr><tr><td class="docs"><p>Merge specs using the specified algorithms.</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-specs
  [algorithms a b]
  (merge-keys algorithms a b))</pre></td></tr><tr><td class="docs"><p>Returns a predicate to check if a node has the specified group name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-has-group-name?
  {:internal true}
  [group-name]
  (fn has-group-name? [node]
    (when-let [node-group (node/group-name node)]
      (= group-name (keyword (name node-group))))))</pre></td></tr><tr><td class="docs"><p>Check if a node satisfies a group's node-filter.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-in-group?
  {:internal true}
  [node group]
  {:pre [(:group-name group)]}
  ((:node-filter group (node-has-group-name? (:group-name group)))
   node))</pre></td></tr><tr><td class="docs"><p>Build a map entry from a node and a list of groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-&gt;node-map
  {:internal true}
  [groups]
  (fn [node]
    (when-let [groups (seq (-&gt;&gt;
                            groups
                            (filter (partial node-in-group? node))
                            (map #(assoc-in % [:group-names]
                                            (set [(:group-name %)])))))]
      (reduce
       (partial merge-specs merge-spec-algorithm)
       {:node node}
       groups))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn target-os-details
  [target plan-state]
  (let [node (:node target)
        node-id (node/id node)
        node-map (-&gt; {}
                     (maybe-assoc :os-family (node/os-family node))
                     (maybe-assoc :os-version (node/os-version node))
                     (maybe-assoc :packager (node/packager node)))
        detected (select-keys (get-settings plan-state node-id :pallet/os {})
                              [:os-family :os-version])
        warn-diff (fn [key from-node detected]
                    (let [n (key from-node)
                          d (key detected)]
                      (when (and n d (not= n d))
                        (warnf &quot;%s mismatch: node returned %s, but %s detected&quot;
                               (name key) n d))))
        _ (debugf &quot;target-os-details node %s detected %s&quot; node-map detected)
        {:keys [os-family os-version] :as combined} (merge node-map
                                                           detected
                                                           (select-keys
                                                            target [:packager]))
        combined (update-in combined [:packager]
                            #(or %
                                 (when os-family
                                   (packager-for-os os-family os-version))))]
    (warn-diff :os-family node-map detected)
    (warn-diff :os-version node-map detected)
    combined))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn script-template-for-node
  [target plan-state]
  {:pre [target (:node target)]}
  (let [{:keys [os-family os-version packager]} (target-os-details
                                                 target plan-state)
        context (seq (filter
                      identity
                      [os-family
                       packager
                       (when os-version
                         (keyword
                          (format &quot;%s-%s&quot; (name os-family) os-version)))]))]
    (debugf &quot;Script context: %s&quot; (vec context))
    (when-not context
      (debugf &quot;No script context available: %s %s&quot; target plan-state))
    context))</pre></td></tr><tr><td class="docs"><p>Set up the script context for a server</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'with-script-context #'with-script-language]}
  with-script-for-node
  [target plan-state &amp; body]
  `(with-script-context (script-template-for-node ~target ~plan-state)
     (with-script-language :pallet.stevedore.bash/bash
       ~@body)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.data-api" name="pallet.core.data-api"><h1 class="project-name">pallet.core.data-api</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.data-api
  (:require
   [pallet.api :refer [group-spec lift plan-fn]]
   [pallet.compute :refer [service-properties]]
   [pallet.compute.node-list :refer [node-list-service]]
   [pallet.executors :refer [action-plan-data]]
   [pallet.node :as node :refer [node-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn service-map-from-compute [compute]
  (service-properties compute))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nodes [compute]
  (for [node (pallet.compute/nodes compute)]
   (node-map node)))</pre></td></tr><tr><td class="docs"><p>Creates mock provider with a mock node, and a mock group, and then lifts
 the plan function <code>pfn</code> on such group. </p>
</td><td class="codes"><pre class="brush: clojure">(defn- mock-exec-plan
  [executor pfn node &amp; {:keys [settings-phase ]}]
  (let [compute (node-list-service [node])
        group-name (second node)
        os-family (nth node 3)]
    (let [group (merge (group-spec group-name :image {:os-family os-family})
                       (when settings-phase
                         {:phases {:settings (plan-fn (settings-phase))}}))]
      (lift [group]
            :phase pfn
            :environment
            {:algorithms
             {:executor executor}}
            :compute compute))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn explain-plan [pfn node &amp; {:keys [settings-phase]}]
  ;; build a node list with a node with the characteristics above
  (let [op (mock-exec-plan action-plan-data pfn node
                           :settings-phase settings-phase)]
    (mapcat :result (:results op))))</pre></td></tr><tr><td class="docs"><p>-------- SESSION -------------</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>remove duplicates in the list preserving the order in which they first appeared</p>
</td><td class="codes"><pre class="brush: clojure">(defn- sorted-distinct
  [coll]
  (reduce (fn [acc v] (if (some #{v} acc) acc (conj acc v))) [] coll))</pre></td></tr><tr><td class="docs"><p>Returns a sequence of the phases as they were invoked.</p>
</td><td class="codes"><pre class="brush: clojure">(defn phase-seq
  [session-data]
  (seq (sorted-distinct (map :phase (:runs session-data)))))</pre></td></tr><tr><td class="docs"><p>For a session-data structure, it generates the list of groups affected</p>
</td><td class="codes"><pre class="brush: clojure">(defn groups
  [session-data]
  (seq (distinct (map :group-name (:runs session-data) ))))</pre></td></tr><tr><td class="docs"><p>returns a summary of a run of a phase on a group (from the :results
  key in the session)</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-summary
  [r]
  (let [target (:target r)
        node (node-map (:node target))]
    (merge
     {:phase (:phase r)
      :group-name (:group-name target)
      :action-results (:result r)
      :node (assoc node :image (:image target))})))</pre></td></tr><tr><td class="docs"><p>Given a session data structure, returns a serializable data
  structure with the results of the session</p>
</td><td class="codes"><pre class="brush: clojure">(defn session-data
  [{:keys [results new-nodes old-nodes] :as session}]
  (let [runs (map run-summary results)]
    {:destroyed-nodes (seq (map #(node-map (:node %)) old-nodes))
     :created-nodes (seq (map #(node-map (:node %)) new-nodes))
     :runs runs}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.file-upload" name="pallet.core.file-upload"><h1 class="project-name">pallet.core.file-upload</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.file-upload
  (:require
   [pallet.core.file-upload.protocols :as impl]))</pre></td></tr><tr><td class="docs"><p>Return the path to which upload-file would upload a file for
    target-path</p>
</td><td class="codes"><pre class="brush: clojure">(defn upload-file-path
  [uploader session target-path action-options]
  (impl/upload-file-path uploader session target-path action-options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user-file-path
  [uploader session target-path action-options username]
  (impl/user-file-path uploader session target-path action-options username))</pre></td></tr><tr><td class="docs"><p>Upload a file to the target-path, and return any script needed to
    be run on the node to get the file into place.</p>

<pre><code>file-options is a map of options as passed to remote-file, for file
ownership, permissions, etc.

action-options can contain a :sudo-user, specify the user to install
the file as.
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn upload-file
  [uploader session local-path target-path action-options]
  (impl/upload-file
   uploader session local-path target-path action-options))</pre></td></tr><tr><td class="docs"><p>Instantiate a file-upload provider based on keyword and option map.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti file-uploader
  (fn [kw options] kw))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.file-upload.protocols" name="pallet.core.file-upload.protocols"><h1 class="project-name">pallet.core.file-upload.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Protocols for file upload</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.file-upload.protocols)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol FileUpload
  (upload-file-path [_ session target-path action-options]
    &quot;Return the path to which upload-file would upload a file for
    target-path&quot;)
  (user-file-path [_ session target-path action-options username]
    &quot;Return the path to which intermediate files should be written for the
    specified username.&quot;)
  (upload-file [_ session local-path target-path action-options]
    &quot;Upload a file to the target-path, and return any script needed to
    be run on the node to get the file into place.
    file-options is a map of options as passed to remote-file, for file
    ownership, permissions, etc.
    action-options can contain a :sudo-user, specify the user to install
    the file as.&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.file-upload.rsync-upload" name="pallet.core.file-upload.rsync-upload"><h1 class="project-name">pallet.core.file-upload.rsync-upload</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of file upload using rsync.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.file-upload.rsync-upload
  (:require
   [clojure.tools.logging :refer [debugf]]
   [pallet.actions.direct.rsync
    :refer [default-options rsync-command rsync-sudo-user]]
   [pallet.local.execute :refer [local-checked-script]]
   [pallet.core.session
    :refer [admin-user effective-username target-ip target-node]]
   [pallet.core.file-upload :refer [file-uploader]]
   [pallet.core.file-upload.protocols :refer [FileUpload]]
   [pallet.node :refer [ssh-port]]
   [pallet.ssh.file-upload.sftp-upload :refer [target]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rsync-user [session]
  (or (rsync-sudo-user session)
      (:username (admin-user session))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn rsync-upload-file
  [local-path target-path address port username options]
  (debugf &quot;rsync-upload-file %s:%s:%s from %s&quot;
          address port target-path local-path)
  (local-checked-script
   &quot;rsync file to target&quot;
   ~(rsync-command
     local-path target-path
     username
     address port
     options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord RsyncUpload [upload-root]
  FileUpload
  (upload-file-path [_ session target-path action-options]
    (target upload-root (rsync-user session) target-path))
  (user-file-path [_ session target-path action-options username]
    (target upload-root username target-path))
  (upload-file
    [_ session local-path target-path action-options]
    (rsync-upload-file
     local-path
     (target upload-root (rsync-user session) target-path)
     (target-ip session)
     (ssh-port (target-node session))
     (:username (admin-user session))
     (merge (-&gt; (default-options session)
                (select-keys [:rsync-path]))
            {:chmod &quot;go-w,go-r&quot;}))))</pre></td></tr><tr><td class="docs"><p>Create an instance of the rsync upload strategy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn rsync-upload
  [{:keys [upload-root] :as options}]
  (map-&gt;RsyncUpload (merge {:upload-root &quot;/tmp&quot;} options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod file-uploader :rsync
  [_ options]
  (rsync-upload options))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.operations" name="pallet.core.operations"><h1 class="project-name">pallet.core.operations</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Built in operations</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.operations
  (:require
   [clojure.tools.logging :as logging]
   [pallet.algo.fsmop :refer [delay-for dofsm reduce* result succeed]]
   [pallet.core.api :as api]
   [pallet.core.primitives :as primitives]
   [pallet.node :refer [node-map]])
  (:refer-clojure :exclude [delay]))</pre></td></tr><tr><td class="docs"><p>Adjusts node counts. Groups are expected to have node counts on them.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-count-adjuster
  [compute-service groups service-state plan-state environment targets
   execution-settings-f]
  {:pre [compute-service]}
  (dofsm node-count-adjuster
    [group-deltas         (result (api/group-deltas targets groups))
     nodes-to-remove      (result (api/nodes-to-remove targets group-deltas))
     nodes-to-add         (result (api/nodes-to-add group-deltas))
     old-nodes            (result (-&gt;&gt;
                                   (vals nodes-to-remove)
                                   (mapcat :nodes)
                                   (map (comp node-map :node))))
     [results1 plan-state] (primitives/build-and-execute-phase
                            targets plan-state environment
                            :destroy-server
                            (mapcat :nodes (vals nodes-to-remove))
                            execution-settings-f)
     _ (primitives/remove-group-nodes compute-service nodes-to-remove)
     [results2 plan-state] (primitives/build-and-execute-phase
                            targets plan-state environment
                            :destroy-group
                            (api/groups-to-remove group-deltas)
                            execution-settings-f)
     [results3 plan-state] (primitives/build-and-execute-phase
                            targets plan-state environment
                            :create-group
                            (api/groups-to-create group-deltas)
                            execution-settings-f)
     new-nodes (primitives/create-group-nodes
                compute-service environment nodes-to-add)]
    {:new-nodes new-nodes
     :old-nodes old-nodes
     :targets (-&gt;&gt; targets
                   (concat new-nodes)
                   (remove (set (mapcat :nodes (vals nodes-to-remove)))))
     :plan-state plan-state
     :service-state (-&gt;&gt; service-state
                         (concat new-nodes)
                         (remove (set (mapcat :nodes (vals nodes-to-remove)))))
     :results (concat results1 results2 results3)}))</pre></td></tr><tr><td class="docs"><h2>Top level operations</h2>
</td><td class="codes"><pre class="brush: clojure">(defn group-nodes
  [compute groups]
  (dofsm group-nodes
    [service-state (primitives/service-state compute groups)]
    service-state))</pre></td></tr><tr><td class="docs"><p>A sequence of keywords, listing the lift-options</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  lift-options
  [:targets :phase-execution-f :execution-settings-f
   :post-phase-f :post-phase-fsm :partition-f])</pre></td></tr><tr><td class="docs"><p>Lift nodes (<code>targets</code> which defaults to <code>service-state</code>), given a
<code>plan-state</code>, <code>environment</code> and the <code>phases</code> to apply.</p>

<h2>Options</h2>

<p><code>:targets</code>
: used to restrict the nodes on which the phases are run to a subset of
  <code>service-state</code>.  Defaults to <code>service-state</code>.</p>

<p><code>:phase-execution-f</code>
: specifies the function used to execute a phase on the targets.  Defaults
  to <code>pallet.core.primitives/build-and-execute-phase</code>.</p>

<p><code>:post-phase-f</code>
: specifies an optional function that is run after a phase is applied.  It is
  passed <code>targets</code>, <code>phase</code> and <code>results</code> arguments, and is called before any
  error checking is done.  The return value is ignored, so this is for side
  affect only.</p>

<p><code>:post-phase-fsm</code>
: specifies an optional fsm returning function that is run after a phase is
  applied.  It is passed <code>targets</code>, <code>phase</code> and <code>results</code> arguments, and is
  called before any error checking is done.  The return value is ignored, so
  this is for side affect only.</p>

<p><code>:execution-settings-f</code>
: specifies a function that will be called with a node argument, and which
  should return a map with <code>:user</code>, <code>:executor</code> and <code>:executor-status-fn</code> keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lift
  [service-state plan-state environment phases
   {:keys [targets execution-settings-f phase-execution-f
           post-phase-f post-phase-fsm]
    :or {targets service-state
         phase-execution-f #'primitives/build-and-execute-phase
         execution-settings-f (api/environment-execution-settings)}}]
  {:pre [(:user environment)]}
  (logging/debugf
   &quot;lift :phases %s :targets %s&quot; (vec phases) (vec (map :group-name targets)))
  (logging/tracef &quot;lift environment %s&quot; environment)
  (letfn [(phase-meta [phase target]
            (-&gt; (api/target-phase target phase) meta))]
    (dofsm lift
      [[results plan-state] (reduce*
                             (fn reducer [[results plan-state] phase]
                               (dofsm reduce-phases
                                 [meta (result
                                        (phase-meta phase (first targets)))
                                  f (result (or (:phase-execution-f meta)
                                                phase-execution-f))
                                  _ (result (logging/tracef
                                             &quot;phase-execution-f %s&quot; f))
                                  [r ps] (f
                                          service-state plan-state environment
                                          phase targets
                                          (or
                                           (:execution-settings-f meta)
                                           execution-settings-f))
                                  results1 (result
                                            (concat
                                             results
                                             (-&gt;&gt;
                                              r
                                              (map
                                               (fn [x]
                                                 (update-in x
                                                  [:plan-state]
                                                  dissoc
                                                  :node-values))))))
                                  _ (result
                                     (when post-phase-f
                                       (post-phase-f targets phase r)))
                                  _ (result
                                     (doseq [f (-&gt;&gt;
                                                targets
                                                (map
                                                 (comp
                                                  :post-phase-f
                                                  #(phase-meta phase %)))
                                                (remove nil?)
                                                distinct)]
                                       (f targets phase r)))
                                  _ (if post-phase-fsm
                                      (post-phase-fsm targets phase r)
                                      (result nil))
                                  _ (reduce* (fn post-reducer [_ f]
                                               (f targets phase r))
                                             nil
                                             (-&gt;&gt;
                                              targets
                                              (map
                                               (comp :post-phase-fsm
                                                     #(phase-meta phase %)))
                                              (remove nil?)
                                              distinct))
                                  _ (succeed
                                     (not (some :error (mapcat :result r)))
                                     :phase-errors)]
                                 [results1 ps]))
                             [[] plan-state]
                             phases)]
      (do
        (logging/tracef &quot;lift (count results) %s&quot; (count results))
        {:results results
         :targets targets
         :plan-state plan-state}))))</pre></td></tr><tr><td class="docs"><p>Returns a delay fsm.</p>

<h2>Options</h2>

<p><code>:units</code>
: the units for the delay. A keyword from, :ns, :us, :ms, :s, :mins, :hours</p>
</td><td class="codes"><pre class="brush: clojure">(defn delay
  ([delay units]
     (delay-for delay units))
  ([delay]
     (delay-for delay :ms)))</pre></td></tr><tr><td class="docs"><p>Partition targets using the, possibly nil, default partitioning function f.</p>

<p>There are three sources of partitioning applied.  The default passed to the
function, a partioning based on the partitioning and post-phase functions in
the target's metadata, and the target's partitioning function from the metadata.</p>

<p>The partitioning by metadata is applied so that post-phase functions are applied
to the correct targets in lift.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:internal partition-targets
  [targets phase f]
  (let [fns (comp
             (juxt :partition-f :post-phase-f :post-phase-fsm)
             meta #(api/target-phase % phase))]
    (-&gt;&gt;
     targets
     (clojure.core/partition-by fns)
     (mapcat
      #(let [[pf &amp; _] (fns (first %))
             pf       (or f pf)]
         (if pf
           (pf %)
           [%]))))))</pre></td></tr><tr><td class="docs"><p>Lift targets by phase, applying partitions for each phase.</p>

<p>To apply phases at finer than a group granularity (so for example, a
<code>:post-phase-f</code> function is applied to nodes rather than a whole group), we can
use partitioning.</p>

<p>The partitioning function takes a sequence of targets, and returns a sequence of
sequences of targets.  The function can filter targets as required.</p>

<p>For example, this can be used to implement a rolling restart, or a blue/green
deploy.</p>

<h2>Options</h2>

<p>Options are as for <code>lift</code>, with the addition of:</p>

<p><code>:partition-f</code>
: a function that takes a sequence of targets, and returns a sequence of
  sequences of targets.  Used to partition or filter the targets.  Defaults to
  any :partition metadata on the phase, or no partitioning otherwise.</p>

<p>Other options as taken by <code>lift</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lift-partitions
  [service-state plan-state environment phases
   {:keys [targets partition-f]
    :or {targets service-state}
    :as options}]
  {:pre [(:user environment)]}
  (logging/debugf
   &quot;lift-partitions :phases %s :targets %s&quot;
   (vec phases) (vec (map :group-name targets)))
  (dofsm lift-phases
    [[outer-results plan-state]
     (reduce*
      (fn phase-reducer [[acc-results plan-state] phase]
        (dofsm lift-partitions
          [[lift-results plan-state]
           (reduce*
            (fn target-reducer [[r plan-state] targets]
              (dofsm reduce-phases
                [{:keys [results plan-state]}
                 (lift
                  service-state plan-state environment [phase]
                  (assoc options :targets targets))]
                (do
                  (logging/tracef &quot;back from lift&quot;)
                  (logging/tracef
                   &quot;lift-partitions (count r) %s (count results) %s&quot;
                   (count r) (count results))
                  [(concat r results) plan-state])))
            [acc-results plan-state]
            (partition-targets targets phase partition-f))]
          (do
            (logging/tracef &quot;back from phase loop&quot;)
            (logging/tracef &quot;(count lift-results) %s&quot; (count lift-results))
            [lift-results plan-state])))
      [[] plan-state]
      phases)]
    (do
      (logging/tracef &quot;back from partitions&quot;)
      (logging/tracef &quot;(count outer-results) %s&quot; (count outer-results))
      {:results outer-results
       :targets targets
       :plan-state plan-state})))</pre></td></tr><tr><td class="docs"><p>Converge the <code>groups</code>, using the specified service-state to provide the
existing nodes.  The <code>:bootstrap</code> phase is run on new nodes.  When tagging is
supported the <code>:bootstrap</code> phase is run on those nodes without a :bootstrapped
flag.</p>

<h2>Options</h2>

<p><code>:targets</code>
: used to restrict the nodes on which the phases are run to a subset of
  <code>service-state</code>.  Defaults to <code>service-state</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn converge
  [compute groups service-state plan-state environment phases
   {:keys [targets execution-settings-f]
    :or {targets service-state
         execution-settings-f (api/environment-execution-settings)}
    :as options}]
  {:pre [(:user environment)]}
  (logging/debugf
   &quot;converge :phase %s :groups %s :settings-groups %s&quot;
   (vec phases)
   (vec (map :group-name groups))
   (vec (map :group-name targets)))
  (dofsm converge
    [{:keys [new-nodes old-nodes targets service-state plan-state results]
      :as result}
     (node-count-adjuster
      compute groups service-state plan-state environment targets
      execution-settings-f)]
    result))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.plan-state" name="pallet.core.plan-state"><h1 class="project-name">pallet.core.plan-state</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions to manipulate the plan-state map. The plan-state represents all the
  cumulative settings information on the nodes in an operation.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.plan-state)</pre></td></tr><tr><td class="docs"><p>Retrieve the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility. If passed a nil
   <code>instance-id</code>, then <code>:default</code> is used</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-settings
  [plan-state node-id facility {:keys [instance-id default]}]
  (get-in plan-state [:host node-id facility instance-id] default))</pre></td></tr><tr><td class="docs"><p>Set the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default).</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc-settings
  [plan-state node-id facility kw-values {:keys [instance-id]}]
  (update-in plan-state [:host node-id facility instance-id] merge kw-values))</pre></td></tr><tr><td class="docs"><p>Update the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default).</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-settings
  [plan-state node-id facility f args {:keys [instance-id]}]
  {:pre [f]}
  (apply update-in plan-state [:host node-id facility instance-id] f args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.primitives" name="pallet.core.primitives"><h1 class="project-name">pallet.core.primitives</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Base operation primitives for pallet.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.primitives
  (:require
   [clojure.tools.logging :as logging]
   [pallet.algo.fsm.fsm-dsl
    :refer [event-handler
            event-machine-config
            fsm-name
            on-enter
            state
            valid-transitions]]
   [pallet.algo.fsmop
    :refer [dofsm execute fail-reason map* result update-state wait-for]]
   [pallet.core.api :as api]
   [pallet.map-merge :refer [merge-keys]]
   [pallet.node :refer [id]]))</pre></td></tr><tr><td class="docs"><h2>Wrap non-FSM functions in simple FSM</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Returns a FSM specification for running the specified function in a future.
  Assumes failures in the underlying function cause an exception to be thrown,
  and that the function takes no arguments.</p>

<p>TODO: Provide support for controlling retry count, standoff, etc, although
this might be better added externally.</p>
</td><td class="codes"><pre class="brush: clojure">(defn async-fsm
  [f]
  (let [async-f (atom nil)]
    (letfn [(running [state event event-data]
              (case event
                :success (update-state
                          state :completed assoc :result event-data)
                :fail (update-state
                       state :failed assoc :fail-reason event-data)
                :abort (do
                         (when-let [async-f @async-f]
                           (future-cancel async-f))
                         (update-state
                          state :aborted assoc :fail-reason event-data))))
            (run-async [{:keys [em state-data] :as state}]
              (let [event (:event em)
                    f-runner (fn async-fsm []
                               (try
                                 (event :success (f))
                                 (catch Throwable e
                                   (logging/warn e &quot;async-fsm failed&quot;)
                                   (event :fail {:exception e}))))]
                (reset! async-f (execute f-runner))))]
      (event-machine-config
        (fsm-name (str f))
        (state :running
          (valid-transitions :completed :failed :aborted)
          (on-enter run-async)
          (event-handler running))))))</pre></td></tr><tr><td class="docs"><p>Sets the boolean <code>state-name</code> flag on <code>node</code>.</p>

<h2>Node state</h2>
</td><td class="codes"><pre class="brush: clojure">(defn set-state-for-node
  [state-name node]
  (logging/debugf &quot;set-state-for-node %s %s&quot; state-name (:id (:node node)))
  (async-fsm (partial api/set-state-for-node state-name node)))</pre></td></tr><tr><td class="docs"><p>Sets the boolean <code>state-name</code> flag on <code>nodes</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-state-for-nodes
  [state-name nodes]
  (logging/debugf &quot;set-state-for-nodes %s %s&quot;
                  state-name (mapv (comp id :node) nodes))
  (map* (map (partial set-state-for-node state-name) nodes)))</pre></td></tr><tr><td class="docs"><p>Define an operation that builds a representation of the available nodes.</p>

<h2>Compute service state</h2>
</td><td class="codes"><pre class="brush: clojure">(defn service-state
  [compute groups]
  (async-fsm (partial api/service-state compute groups)))</pre></td></tr><tr><td class="docs"><p>Executes an action-plan on the specified node.</p>

<h2>Action plan execution</h2>
</td><td class="codes"><pre class="brush: clojure">(defn execute-action-plan
  [service-state plan-state environment execution-settings-f
   {:keys [action-plan phase target-type target] :as action-plan-map}]
  {:pre [action-plan-map action-plan target]}
  (let [{:keys [user executor executor-status-fn]} (execution-settings-f
                                                    environment target)]
    (async-fsm
     (partial
      api/execute-action-plan
      service-state
      plan-state environment user
      executor executor-status-fn action-plan-map))))</pre></td></tr><tr><td class="docs"><p>Execute <code>action-plans</code>, a sequence of action-plan maps.
   <code>execution-settings-f</code> is a function of target, that returns a map with
   :user, :executor and :executor-status-fn keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-action-plans
  [service-state plan-state environment execution-settings-f action-plans]
  (dofsm execute-action-plans
    [results (map*
              (map
               (partial
                execute-action-plan service-state plan-state
                environment execution-settings-f)
               action-plans))]
    [results
     (reduce (partial merge-keys {}) plan-state (map :plan-state results))]))</pre></td></tr><tr><td class="docs"><p>Build and execute the specified phase.</p>

<p>  <code>target-type</code>
  : specifies the type of target to run the phase on, :group, :group-nodes,
  or :group-node-list.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-and-execute-phase
  [service-state plan-state environment phase targets execution-settings-f]
  {:pre [phase]}
  (logging/debugf
   &quot;build-and-execute-phase %s on %s target(s)&quot; phase (count targets))
  (logging/tracef &quot;build-and-execute-phase plan-state %s&quot; plan-state)
  (logging/tracef &quot;build-and-execute-phase environment %s&quot; environment)
  (let [[action-plans plan-state]
        ((api/action-plans service-state plan-state environment phase targets)
         plan-state)]
    (logging/tracef
     &quot;build-and-execute-phase execute %s actions %s&quot;
     (vec (map (comp count :action-plan) action-plans)) plan-state)
    (logging/tracef &quot;build-and-execute-phase plan-state %s&quot; plan-state)
    (execute-action-plans
     service-state plan-state environment execution-settings-f action-plans)))</pre></td></tr><tr><td class="docs"><p>Return a phase execution function, that will execute a phase on nodes that
  don't have the specified state flag set. On successful completion the nodes
  have the state flag set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-and-flag
  ([state-flag execute-f]
     (logging/tracef &quot;execute-and-flag state-flag %s&quot; state-flag)
     (fn execute-and-flag
       [service-state plan-state environment phase targets execution-settings-f]
       (dofsm execute-and-flag
         [results (result (logging/tracef &quot;execute-and-flag %s&quot; state-flag))
          [results plan-state] (execute-f
                                service-state plan-state environment phase
                                (filter
                                 (complement (api/has-state-flag? state-flag))
                                 targets)
                                execution-settings-f)
          _ (result (logging/tracef
                     &quot;execute-and-flag %s setting flag&quot; state-flag))
          _ (set-state-for-nodes
             state-flag
             (-&gt;&gt; results
                  (remove #(some :error (:result %)))
                  (map :target)))
          _ (result (logging/tracef &quot;execute-and-flag %s done&quot; state-flag))]
         [results plan-state])))
  ([state-flag]
     (execute-and-flag state-flag build-and-execute-phase)))</pre></td></tr><tr><td class="docs"><p>Return a phase execution function, that will execute a phase on nodes that
  have the specified state flag set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-on-filtered
  [filter-f execute-f]
  (logging/tracef &quot;execute-on-filtered&quot;)
  (fn execute-on-filtered
    [service-state plan-state environment phase targets execution-settings-f]
    (dofsm execute-on-filtered
      [results (result (logging/tracef &quot;execute-on-filtered %s&quot; execute-f))
       [results plan-state] (execute-f
                             service-state plan-state environment phase
                             (filter-f targets)
                             execution-settings-f)
       _ (result(logging/tracef &quot;execute-on-filtered ran&quot;))]
      [results plan-state])))</pre></td></tr><tr><td class="docs"><p>Return a phase execution function, that will execute a phase on nodes that
  have the specified state flag set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-on-flagged
  ([state-flag execute-f]
     (logging/tracef &quot;execute-on-flagged state-flag %s&quot; state-flag)
     (execute-on-filtered
      #(filter (api/has-state-flag? state-flag) %)
      execute-f))
  ([state-flag]
     (execute-on-flagged state-flag build-and-execute-phase)))</pre></td></tr><tr><td class="docs"><p>Return a phase execution function, that will execute a phase on nodes that
  have the specified state flag set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn execute-on-unflagged
  ([state-flag execute-f]
     (logging/tracef &quot;execute-on-flagged state-flag %s&quot; state-flag)
     (execute-on-filtered
      #(filter (complement (api/has-state-flag? state-flag)) %)
      execute-f))
  ([state-flag]
     (execute-on-unflagged state-flag build-and-execute-phase)))</pre></td></tr><tr><td class="docs"><p>Executes on non bootstrapped nodes, with image credentials.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  unbootstrapped-meta
  {:execution-settings-f (api/environment-image-execution-settings)
   :phase-execution-f (execute-on-unflagged :bootstrapped)})</pre></td></tr><tr><td class="docs"><p>Executes on bootstrapped nodes, with admin user credentials.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  bootstrapped-meta
  {:phase-execution-f (execute-on-flagged :bootstrapped)})</pre></td></tr><tr><td class="docs"><p>The bootstrap phase is executed with the image credentials, and
only not flagged with a :bootstrapped keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  default-phase-meta
  {:bootstrap {:execution-settings-f (api/environment-image-execution-settings)
               :phase-execution-f (execute-and-flag :bootstrapped)}})</pre></td></tr><tr><td class="docs"><p>Takes a <code>phases-map</code> and applies the default phase metadata and the
  <code>phases-meta</code> to the phases in it.</p>

<p>It's not nice that this can not be in p.core.api</p>
</td><td class="codes"><pre class="brush: clojure">(defn phases-with-meta
  [phases-map phases-meta]
  (reduce-kv
   (fn [result k v]
     (let [dm (default-phase-meta k)
           pm (get phases-meta k)]
       (assoc result k (if (or dm pm)
                         ;; explicit overrides default
                         (vary-meta v #(merge dm % pm))
                         v))))
   nil
   (or phases-map {})))</pre></td></tr><tr><td class="docs"><p>Filters <code>target-results</code>, a map from target to result map, for successful
  results.</p>

<h2>Result predicates</h2>
</td><td class="codes"><pre class="brush: clojure">(defn successful-result?
  [result]
  (not (:errors result)))</pre></td></tr><tr><td class="docs"><p>Create <code>count</code> nodes for a <code>group</code>.</p>

<h2>Node count adjustment</h2>
</td><td class="codes"><pre class="brush: clojure">(defn create-nodes
  [compute-service environment group count]
  (async-fsm
   (partial api/create-nodes compute-service environment group count)))</pre></td></tr><tr><td class="docs"><p>Create nodes for groups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-group-nodes
  [compute-service environment group-counts]
  (logging/debugf
   &quot;create-group-nodes %s %s %s&quot;
   compute-service environment group-counts)
  (dofsm create-group-nodes
    [results (map*
              (map
               #(create-nodes
                 compute-service environment (key %) (:delta (val %)))
               group-counts))]
    (apply concat results)))</pre></td></tr><tr><td class="docs"><p>Removes <code>nodes</code> from <code>group</code>. If <code>all</code> is true, then all nodes for the group
  are being removed.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-nodes
  [compute-service group {:keys [nodes all] :as remove-node-map}]
  (logging/debugf &quot;remove-nodes %s&quot; remove-node-map)
  (async-fsm
   (partial api/remove-nodes compute-service group remove-node-map)))</pre></td></tr><tr><td class="docs"><p>Removes nodes from groups. <code>group-nodes</code> is a map from group to a sequence of
  nodes</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-group-nodes
  [compute-service group-nodes]
  (logging/debugf &quot;remove-group-nodes %s&quot; group-nodes)
  (map* (map #(remove-nodes compute-service (key %) (val %)) group-nodes)))</pre></td></tr><tr><td class="docs"><p>If the result has a logged exception, throw it. This will block on the
   operation being complete or failed.</p>

<h1>Exception reporting</h1>
</td><td class="codes"><pre class="brush: clojure">(defn throw-operation-exception
  [operation]
  (when-let [f (fail-reason operation)]
    (when-let [e (:exception f)]
      (throw e))))</pre></td></tr><tr><td class="docs"><p>Return the phase errors for an operation</p>
</td><td class="codes"><pre class="brush: clojure">(defn phase-errors
  [operation]
  (api/phase-errors (wait-for operation)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn throw-phase-errors
  [operation]
  (api/throw-phase-errors (wait-for operation)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.session" name="pallet.core.session"><h1 class="project-name">pallet.core.session</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for querying sessions.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.session
  (:require
   [pallet.compute :as compute :refer [packager-for-os]]
   [pallet.context :refer [with-context]]
   [pallet.core.plan-state :refer [get-settings]]
   [pallet.core.thread-local
    :refer [thread-local thread-local! with-thread-locals]]
   [pallet.node :as node]
   [pallet.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>Current session state</p>

<p>Using the session var directly is to be avoided. It is a dynamic var in
order to provide thread specific bindings. The value is expected to be an
atom to allow in-place update semantics.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:internal true :dynamic true :doc }
  *session*)</pre></td></tr><tr><td class="docs"><h1>Session map low-level API</h1>

<p>The aim here is to provide an API that could possibly be backed by something
other than a plain map.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Return the current session, which implements clojure's map interfaces.</p>
</td><td class="codes"><pre class="brush: clojure">(defn session
  []
  (assert (bound? #'*session*)
          &quot;Session not bound.  The session is only bound within a phase.&quot;)
  (thread-local *session*))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'with-thread-locals]}
  with-session
  [session &amp; body]
  `(with-thread-locals [*session* ~session]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn session!
  [session]
  (thread-local! *session* session))</pre></td></tr><tr><td class="docs"><p>Defines a session context.</p>

<h2>Session Context</h2>

<p>The session context is used in pallet core code.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'with-context]} session-context
  {:indent 2}
  [pipeline-name event &amp; args]
  (let [line (-&gt; &amp;form meta :line)]
    `(with-context
        ~(merge {:kw (list 'quote pipeline-name)
                 :msg (name pipeline-name)
                 :ns (list 'quote (ns-name *ns*))
                 :line line
                 :log-level :trace}
                event)
        ~@args)))</pre></td></tr><tr><td class="docs"><h1>Session accessors</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Computes a configuration and filesystem safe identifier corresponding to a
  potentially unsafe ID</p>
</td><td class="codes"><pre class="brush: clojure">(defn safe-id
  [#^String unsafe-id]
  (utils/base64-md5 unsafe-id))</pre></td></tr><tr><td class="docs"><p>(defn phase
  "Current phase"
  [session]
  (:phase session))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Target server.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target
  [session]
  (-&gt; session :server))</pre></td></tr><tr><td class="docs"><p>Target compute service node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-node
  [session]
  (-&gt; session :server :node))</pre></td></tr><tr><td class="docs"><p>Name of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-name
  [session]
  (node/hostname (target-node session)))</pre></td></tr><tr><td class="docs"><p>Id of the target-node (unique for provider).</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-id
  [session]
  (node/id (target-node session)))</pre></td></tr><tr><td class="docs"><p>IP of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-ip
  [session]
  (node/primary-ip (target-node session)))</pre></td></tr><tr><td class="docs"><p>Roles of the target server.Base distribution of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(comment
(defn target-roles
  [session]
  [(-&gt; session :server :roles) session])
(defn base-distribution
  [session]
  (compute/base-distribution (-&gt; session :server :image))))</pre></td></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn os-family
  [session]
  (or (node/os-family (target-node session))
      (-&gt; session :server :image :os-family)
      (-&gt; (get-settings (:plan-state session) (target-id session) :pallet/os {})
          :os-family)))</pre></td></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn os-version
  [session]
  (or (node/os-version (target-node session))
      (-&gt; session :server :image :os-version)
      (-&gt; (get-settings (:plan-state session) (target-id session) :pallet/os {})
          :os-version)))</pre></td></tr><tr><td class="docs"><p>Group name of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-name
  [session]
  (-&gt; session :server :group-name))</pre></td></tr><tr><td class="docs"><p>Safe name for target machine.
   Some providers don't allow for node names, only node ids, and there is
   no guarantee on the id format.</p>
</td><td class="codes"><pre class="brush: clojure">(comment
   (defn safe-name
     [session]
     [(format
       &quot;%s%s&quot;
       (name (group-name session)) (safe-id (name (target-id session))))
      session]))</pre></td></tr><tr><td class="docs"><p>Targets for current converge.</p>
</td><td class="codes"><pre class="brush: clojure">(defn targets
  [session]
  (:service-state session))</pre></td></tr><tr><td class="docs"><p>Target nodes for current converge.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-nodes
  [session]
  (map :node (:service-state session)))</pre></td></tr><tr><td class="docs"><p>All targets with the specified group-name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn targets-in-group
  [session group-name]
  (-&gt;&gt;
   (:service-state session)
   (filter
    #(or (= (:group-name %) group-name)
         (when-let [group-names (:group-names %)] (group-names group-name))))))</pre></td></tr><tr><td class="docs"><p>All nodes with the specified group-name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nodes-in-group
  [session group-name]
  (-&gt;&gt;
   (targets-in-group session group-name)
   (map :node)))</pre></td></tr><tr><td class="docs"><p>All target groups with the specified role.</p>
</td><td class="codes"><pre class="brush: clojure">(defn groups-with-role
  [session role]
  (-&gt;&gt;
   (:service-state session)
   (filter #((:roles %) role))
   (map #(dissoc % :node))
   distinct))</pre></td></tr><tr><td class="docs"><p>All targets with the specified role.</p>
</td><td class="codes"><pre class="brush: clojure">(defn targets-with-role
  [session role]
  (filter
   (fn [node]
     (when-let [roles (:roles node)]
       (roles role)))
   (:service-state session)))</pre></td></tr><tr><td class="docs"><p>All target nodes with the specified role.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nodes-with-role
  [session role]
  (map :node (targets-with-role session role)))</pre></td></tr><tr><td class="docs"><p>Returns a map from role to nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn role-&gt;nodes-map
  [session]
  (reduce
   (fn [m node]
     (reduce (fn [m role] (update-in m [role] conj node)) m (:roles node)))
   {}
   (:service-state session)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn packager
  [session]
  (or
   (-&gt; session :server :packager)
   (node/packager (get-in session [:server :node]))
   (packager-for-os (os-family session) (os-version session))))</pre></td></tr><tr><td class="docs"><p>User that remote commands are run under.</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user
  [session]
  {:pre [(map? session)
         (or (map? (-&gt; session :environment)))
         (-&gt; session :environment :user)]}
  ;; Note: this is not (:user session), which is set to the actual user used
  ;; for authentication when executing scripts, and may be different, e.g. when
  ;; bootstrapping.
  (-&gt; session :environment :user))</pre></td></tr><tr><td class="docs"><p>User that remote commands are run under</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-group
  [session]
  (compute/admin-group
   (node/os-family (target-node session))
   (node/os-version (target-node session))))</pre></td></tr><tr><td class="docs"><p>Return the effective username.</p>
</td><td class="codes"><pre class="brush: clojure">(defn effective-username
  [session]
  {:post [%]}
  (clojure.tools.logging/debugf &quot;effective-username %s %s&quot;
                                (:action session) (:user session))
  (or
   (-&gt; session :action :sudo-user)
   (or (-&gt; session :user :sudo-user)
       (if-not (-&gt; session :user :no-sudo) &quot;root&quot;))
   (-&gt; session :user :username)))</pre></td></tr><tr><td class="docs"><p>Predicate for a 64 bit target</p>
</td><td class="codes"><pre class="brush: clojure">(defn is-64bit?
  [session]
  (node/is-64bit? (target-node session)))</pre></td></tr><tr><td class="docs"><p>Display errors from the session results.</p>
</td><td class="codes"><pre class="brush: clojure">(comment
  (defn print-errors
    [session]
    (doseq [[target phase-results] (:results session)
            [phase results] phase-results
            result (filter
                    #(or (:error %) (and (:exit %) (not= 0 (:exit %))))
                    results)]
      (println target phase (:err result)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.thread-local" name="pallet.core.thread-local"><h1 class="project-name">pallet.core.thread-local</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides a thread local place, using a dynamic var.</p>

<p>A thread local place can be given a value using <code>with-thread-locals</code>.  It is an
error to use <code>with-thread-locals</code> if the thread local already has a value.</p>

<p>The current value of the thread local is found with <code>thread-local</code>.</p>

<p>The current value of the thread local can be set with <code>thread-local!</code>.  It is an
error to set the value on a thread other than the one used to provide the
initial value using <code>with-thread-locals</code>.</p>

<pre><code> (def ^:dynamic *tl*)

 (with-thread-locals [*t1* {}]
  (assert (= (thread-local *tl*) {}))
  (thread-local! *tl* {:a 1})
  (assert (= (thread-local *tl*) {:a 1})))
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.thread-local)</pre></td></tr><tr><td class="docs"><p>We need a dynamic var to provide a thread local place. Var's do not provide
a way to set the thread local value however, so we use an atom in a dynamic
var.  Use of an atom is overkill - we just need a mutable place.  An
alternative would be to use a deftype to provide the mutable place.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Assign an initial value to a thread local.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-thread-locals
  [bindings &amp; body]
  (assert (vector bindings) &quot;with-thread-locals bindings should be a vector&quot;)
  (let [bindings (partition 2 bindings)
        thread-id (gensym &quot;thread&quot;)]
    `(let [~@(when *assert* `[~thread-id (.getId (Thread/currentThread))])]
       (assert (every? (complement bound?)
                       ~(vec (map #(list `var (first %)) bindings))))
       (binding
           ~(vec (mapcat
                  #(list
                    (first %)
                    `(atom ~(second %)
                           ~@(when *assert* `[:meta {:thread-id ~thread-id}])))
                  bindings))
         ~@body))))</pre></td></tr><tr><td class="docs"><p>Get the value of the thread local</p>
</td><td class="codes"><pre class="brush: clojure">(defn thread-local
  [sym]
  (deref sym))</pre></td></tr><tr><td class="docs"><p>Reset the value of a thread local</p>
</td><td class="codes"><pre class="brush: clojure">(defn thread-local!
  [sym value]
  (assert (= (-&gt; sym meta :thread-id) (.getId (Thread/currentThread)))
          &quot;Attempting to set thread local from incorrect thread.&quot;)
  (reset! sym value))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.user" name="pallet.core.user"><h1 class="project-name">pallet.core.user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>User for authentication.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.user
  (:require
   [pallet.utils :refer [maybe-update-in obfuscate]]))</pre></td></tr><tr><td class="docs"><p>Return the default private key path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-private-key-path
  []
  (str (System/getProperty &quot;user.home&quot;) &quot;/.ssh/id_rsa&quot;))</pre></td></tr><tr><td class="docs"><p>Return the default public key path</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-public-key-path
  []
  (str (System/getProperty &quot;user.home&quot;) &quot;/.ssh/id_rsa.pub&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord User
    [username public-key-path private-key-path public-key private-key
     passphrase password sudo-password no-sudo sudo-user state-root
     state-group])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user? [user]
  (instance? pallet.core.user.User user))</pre></td></tr><tr><td class="docs"><p>Creates a User record with the given username and options. Generally used
   in conjunction with <em>admin-user</em> and pallet.api/with-admin-user, or passed
   to <code>lift</code> or <code>converge</code> as the named :user argument.</p>

<p>   Options:</p>

<p><code>:public-key-path</code>
: path string to public key file</p>

<p><code>:private-key-path</code>
: path string to private key file</p>

<p><code>:public-key</code>
: public key as a string or byte array</p>

<p><code>:private-key</code>
: private key as a string or byte array</p>

<p><code>:passphrase</code>
: passphrase for private key</p>

<p><code>:password</code>
: ssh user password</p>

<p><code>:sudo-password</code>
: password for sudo (defaults to :password)</p>

<p><code>:sudo-user</code>
: the user to sudo to</p>

<p><code>:no-sudo</code>
: flag to not use sudo (e.g. when the user has root privileges).</p>

<p><code>:state-root</code>
: directory on target to use for pallet state files.  Defaults to
  /var/lib/pallet.</p>

<p><code>:state-group</code>
: group shared between admin user and sudo-user.  Used when uploading
  files. Needed only if the sudo user is unprivileged, and the admin
  user can't chown/chgrp files.  </p>
</td><td class="codes"><pre class="brush: clojure">(defn make-user
  [username {:keys [public-key-path private-key-path
                    public-key private-key
                    passphrase
                    password sudo-password no-sudo sudo-user
                    state-root state-group]
             :as options}]
  (map-&gt;User (assoc options :username username)))</pre></td></tr><tr><td class="docs"><p>The admin user is used for running remote admin commands that require
   root permissions.  The default admin user is taken from the
   pallet.admin.username property.  If not specified then the user.name property
   is used. The admin user can also be specified in config.clj when running
   tasks from the command line.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  ^{:doc 
    :dynamic true}
  *admin-user*
  (make-user
   (or (. System getProperty &quot;pallet.admin.username&quot;)
       (. System getProperty &quot;user.name&quot;))
   {:private-key-path (default-private-key-path)
     :public-key-path (default-public-key-path)}))</pre></td></tr><tr><td class="docs"><p>Return a user with obfuscated passwords</p>
</td><td class="codes"><pre class="brush: clojure">(defn obfuscated-passwords
  [user]
  (-&gt; user
      (maybe-update-in [:password] obfuscate)
      (maybe-update-in [:sudo-password] obfuscate)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core.version-dispatch" name="pallet.core.version-dispatch"><h1 class="project-name">pallet.core.version-dispatch</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Version dispatch</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.core.version-dispatch
  (:require
   [pallet.versions
    :refer [as-version-vector version-matches? version-spec-less]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:internal true} match-less
  [hierarchy [i _] [j _]]
  (let [osi (:os i)
        os-versioni (:os-version i)
        versioni (:version i)
        osj (:os j)
        os-versionj (:os-version j)
        versionj (:version j)]
    (cond
      (and (isa? hierarchy osi osj) (not (isa? hierarchy osj osi))) true
      (and (isa? hierarchy osj osi) (not (isa? hierarchy osi osj))) false
      (version-spec-less os-versioni os-versionj) true
      (version-spec-less os-versionj os-versioni) false
      :else (version-spec-less versioni versionj))))</pre></td></tr><tr><td class="docs"><p>Pass nil to default-value if non required</p>

<p>A map that is looked up based on os and os version. The key should be a map
with :os and :os-version keys.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:internal true} lookup-os
  [base version hierarchy base-key version-key values default-value]
  (letfn [(matches? [[i _]]
            (and (isa? hierarchy base (base-key i))
                 (version-matches? version (version-key i))))]
    (if-let [[_ v] (first (sort
                           (comparator (partial match-less hierarchy))
                           (filter matches? values)))]
      v
      (if-let [[_ v] (:default values)]
        v
        default-value))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare version-map)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype VersionMap [^clojure.lang.IPersistentMap data
                     hierarchy
                     ^clojure.lang.Keyword base-key
                     ^clojure.lang.Keyword version-key]
  clojure.lang.ILookup
  (valAt [m key]
    (lookup-os
     (base-key key) (version-key key) hierarchy base-key version-key data nil))
  (valAt [m key default-value]
    (lookup-os
     (base-key key) (version-key key) hierarchy base-key version-key data
     default-value))
  clojure.lang.IFn
  (invoke [m key]
    (lookup-os
     (base-key key) (version-key key) hierarchy base-key version-key data nil))
  (invoke [m key default-value]
    (lookup-os
     (base-key key) (version-key key) hierarchy base-key version-key data
     default-value))
  clojure.lang.IPersistentMap
  (assoc [m key val]
    (version-map hierarchy base-key version-key (assoc data key val)))
  (assocEx [m key val]
    (version-map hierarchy base-key version-key (.assocEx data key val)))
  (without [m key]
    (version-map hierarchy base-key version-key (.without data key))))</pre></td></tr><tr><td class="docs"><p>Construct a version map. The keys should be maps with <code>base-key</code> and
<code>version-key</code> keys. The <code>base-key</code> value should be take from the
<code>hierarchy</code>. The <code>version-key</code> value should be a version vector, or a version
range vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn version-map
  ([hierarchy base-key version-key {:as os-value-pairs}]
     (VersionMap. os-value-pairs hierarchy base-key version-key))
  ([hierarchy base-key version-key]
     (VersionMap. {} hierarchy base-key version-key)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate" name="pallet.crate"><h1 class="project-name">pallet.crate</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><h1>Pallet Crate Writing API</h1>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate
  (:require
   [clojure.string :as string]
   [clojure.tools.macro :refer [name-with-attributes]]
   [pallet.action
    :refer [declare-action
            declare-aggregated-crate-action
            declare-collected-crate-action]]
   [pallet.argument :refer [delayed-fn]]
   [pallet.context :refer [with-phase-context]]
   [pallet.core.plan-state :as plan-state]
   [pallet.core.session :as session]
   [pallet.core.session :refer [session session!]]
   [pallet.execute :as execute]
   [pallet.node :as node]
   [pallet.utils :refer [apply-map compiler-exception local-env]]))</pre></td></tr><tr><td class="docs"><p>Defines a block with a context that is automatically added.</p>

<p>The phase pipeline is used in actions and crate functions. The phase
context automatically sets up the phase context, which is available
(for logging, etc) at phase execution time.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro phase-context
  {:indent 2}
  [pipeline-name event &amp; args]
  (let [line (-&gt; &amp;form meta :line)]
    `(with-phase-context
       (merge {:kw ~(list 'quote pipeline-name)
               :msg ~(if (symbol? pipeline-name)
                       (name pipeline-name)
                       pipeline-name)
               :ns ~(list 'quote (ns-name *ns*))
               :line ~line
               :log-level :trace}
              ~event)
       ~@args)))</pre></td></tr><tr><td class="docs"><p>Predicate to match the final function symbol in a form.</p>
</td><td class="codes"><pre class="brush: clojure">(defn final-fn-sym?
  [sym form]
  (loop [form form]
    (when (sequential? form)
      (let [s (first form)]
        (if (and (symbol? s) (= sym (symbol (name s))))
          true
          (recur (last form)))))))</pre></td></tr><tr><td class="docs"><p>Define a crate function.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defplan
  {:arglists '[[name doc-string? attr-map? [params*] body]]
   :indent 'defun}
  [sym &amp; body]
  (letfn [(output-body [[args &amp; body]]
            (let [no-context? (final-fn-sym? sym body)]
              `(~args
                ;; if the final function call is recursive, then don't add a
                ;; phase-context, so that just forwarding different arities only
                ;; gives one log entry/event, etc.
                ~@(if no-context?
                    body
                    [(let [locals (gensym &quot;locals&quot;)]
                       `(let [~locals (local-env)]
                          (phase-context
                              ~(symbol (str (name sym) &quot;-cfn&quot;))
                              {:msg ~(str sym)
                               :kw ~(keyword sym)
                               :locals ~locals}
                            ~@body)))]))))]
    (let [[sym rest] (name-with-attributes sym body)
          sym (vary-meta sym assoc :pallet/plan-fn true)]
      (if (vector? (first rest))
        `(defn ~sym
           ~@(output-body rest))
        `(defn ~sym
           ~@(map output-body rest))))))</pre></td></tr><tr><td class="docs"><p>Define a crate function where arguments on successive calls are conjoined,
   and passed to the function specified in the body.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro def-aggregate-plan-fn
  {:arglists '[[name doc-string? attr-map? [params*] f]]
   :indent 'defun}
  [sym &amp; args]
  (let [[sym [args f &amp; rest]] (name-with-attributes sym args)
        sym (vary-meta sym assoc :pallet/plan-fn true)
        id (gensym (name sym))]
    (when (seq rest)
      (throw (compiler-exception
              (IllegalArgumentException.
               (format
                &quot;Extra arguments passed to def-aggregate-plan-fn: %s&quot;
                (vec rest))))))
    `(let [action# (declare-aggregated-crate-action '~sym ~f)]
       (defplan ~sym
         [~@args]
         (action# ~@args)))))</pre></td></tr><tr><td class="docs"><p>Define a crate function where arguments on successive calls are conjoined,
   and passed to the function specified in the body.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro def-collect-plan-fn
  {:arglists '[[name doc-string? attr-map? [params*] f]]
   :indent 'defun}
  [sym &amp; args]
  (let [[sym [args f &amp; rest]] (name-with-attributes sym args)
        sym (vary-meta sym assoc :pallet/plan-fn true)
        id (gensym (name sym))]
    (when (seq rest)
      (throw (compiler-exception
              (IllegalArgumentException.
               (format
                &quot;Extra arguments passed to def-collect-plan-fn: %s&quot;
                (vec rest))))))
    `(let [action# (declare-collected-crate-action '~sym ~f)]
       (defplan ~sym
         [~@args]
         (action# ~@args)))))</pre></td></tr><tr><td class="docs"><p>Declare a multimethod for plan functions</p>

<p>Multi-method for plan functions</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmulti-plan
  {:arglists '([name docstring? attr-map? dispatch-fn
                &amp; {:keys [hierarchy] :as options}])}
  [name &amp; args]
  (let [[docstring args] (if (string? (first args))
                           [(first args) (rest args)]
                           [nil args])
        [attr-map args] (if (map? (first args))
                          [(first args) (rest args)]
                          [nil args])
        dispatch-fn (first args)
        {:keys [hierarchy]
         :or {hierarchy #'clojure.core/global-hierarchy}} (rest args)
        args (first (filter vector? dispatch-fn))
        name (vary-meta name assoc :pallet/plan-fn true)]
    `(let [a# (atom {})]
       (def
         ~name
         ^{:dispatch-fn (fn [~@args] ~@(rest dispatch-fn))
           :methods a#}
         (fn [~@args]
           (let [dispatch-val# ((-&gt; ~name meta :dispatch-fn) ~@args)]
             (if-let [f# (or (get @a# dispatch-val#)
                             (some
                              (fn [[k# f#]]
                                (when (isa? @~hierarchy dispatch-val# k#)
                                  f#))
                              @a#)
                             (get @a# :default))]
               (f# ~@args)
               (throw
                (ex-info
                 (format &quot;Missing defmulti-plan %s method for dispatch value %s&quot;
                         ~(clojure.core/name name) (pr-str dispatch-val#))
                 {:reason :missing-method
                  :defmulti-plan ~(clojure.core/name name)})))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn
  ^{:internal true :indent 2}
  add-plan-method-to-multi
  [multifn dispatch-val f]
  {:pre [(-&gt; multifn meta :methods)]}
  (swap! (-&gt; multifn meta :methods) assoc dispatch-val f))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro defmethod-plan
  {:indent 2}
  [multifn dispatch-val args &amp; body]
  (letfn [(sanitise [v]
            (string/replace (str v) #&quot;:&quot; ))]
    `(do
       (assert (-&gt; ~multifn meta :methods) ~(str multifn &quot; isn't a known defmulti-plan&quot;))
       (add-plan-method-to-multi ~multifn ~dispatch-val
        (fn [~@args]
          (phase-context
              ~(symbol (str (name multifn) &quot;-&quot; (sanitise dispatch-val)))
              {:msg ~(name multifn) :kw ~(keyword (name multifn))
               :dispatch-val ~dispatch-val}
            ~@body))))))</pre></td></tr><tr><td class="docs"><p>Create a state-m monadic value function that examines the session, and
  returns nil.</p>

<p> helpers</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro session-peek-fn
  {:indent 'defun}
  [[sym] &amp; body]
  `(fn session-peek-fn [~sym]
     ~@body
     [nil ~sym]))</pre></td></tr><tr><td class="docs"><p>The target-node map.</p>

<h2>Session Accessors</h2>
</td><td class="codes"><pre class="brush: clojure">(defn target
  []
  (session/target (session)))</pre></td></tr><tr><td class="docs"><p>The target-node instance (the :node in the target-node map).</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-node
  []
  (session/target-node (session)))</pre></td></tr><tr><td class="docs"><p>All targets.</p>
</td><td class="codes"><pre class="brush: clojure">(defn targets
  []
  (session/targets (session)))</pre></td></tr><tr><td class="docs"><p>All target-nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-nodes
  []
  (session/target-nodes (session)))</pre></td></tr><tr><td class="docs"><p>Id of the target-node (unique for provider).</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-id
  []
  (session/target-id (session)))</pre></td></tr><tr><td class="docs"><p>Name of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-name
  []
  (node/hostname (session/target-node (session))))</pre></td></tr><tr><td class="docs"><p>Id of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-user
  []
  (session/admin-user (session)))</pre></td></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn os-family
  []
  (session/os-family (session)))</pre></td></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn os-version
  []
  (session/os-version (session)))</pre></td></tr><tr><td class="docs"><p>Group-Name of the target-node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-name
  []
  (session/group-name (session)))</pre></td></tr><tr><td class="docs"><p>All targets in the same tag as the target-node, or with the
  specified group-name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn targets-in-group
  ([group-name]
     (session/targets-in-group (session) group-name))
  ([]
     (targets-in-group (group-name))))</pre></td></tr><tr><td class="docs"><p>All nodesin the same tag as the target-node, or with the specified
  group-name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nodes-in-group
  ([group-name]
     (session/nodes-in-group (session) group-name))
  ([]
     (nodes-in-group (group-name))))</pre></td></tr><tr><td class="docs"><p>All target groups with the specified role.</p>
</td><td class="codes"><pre class="brush: clojure">(defn groups-with-role
  [role]
  (session/groups-with-role (session) role))</pre></td></tr><tr><td class="docs"><p>All targets with the specified role.</p>
</td><td class="codes"><pre class="brush: clojure">(defn targets-with-role
  [role]
  (session/targets-with-role (session) role))</pre></td></tr><tr><td class="docs"><p>All target nodes with the specified role.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nodes-with-role
  [role]
  (session/nodes-with-role (session) role))</pre></td></tr><tr><td class="docs"><p>A map from role to nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn role-&gt;nodes-map
  []
  (session/role-&gt;nodes-map (session)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn packager
  []
  (session/packager (session)))</pre></td></tr><tr><td class="docs"><p>User that remote commands are run under</p>
</td><td class="codes"><pre class="brush: clojure">(defn admin-group
  []
  (session/admin-group (session)))</pre></td></tr><tr><td class="docs"><p>Predicate for a 64 bit target</p>
</td><td class="codes"><pre class="brush: clojure">(defn is-64bit?
  []
  (session/is-64bit? (session)))</pre></td></tr><tr><td class="docs"><p>Returns the current compute service</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service
  []
  (if-let [node (session/target-node (session))]
    (node/compute-service node)
    (-&gt; (session) :environment :compute)))</pre></td></tr><tr><td class="docs"><p>Returns the current blobstore.</p>
</td><td class="codes"><pre class="brush: clojure">(defn blobstore
  []
  (-&gt; (session) :environment :blobstore))</pre></td></tr><tr><td class="docs"><p>Returns a DelayedFunction that is a predicate for whether the flag is set</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-flag?
  {:pallet/plan-fn true}
  [flag]
  (delayed-fn #(execute/target-flag? % (keyword (name flag)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn target-flag-value
  [flag]
  (execute/target-flag-value (session) flag))</pre></td></tr><tr><td class="docs"><p>Retrieve the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility. If passed a nil
   <code>instance-id</code>, then <code>:default</code> is used</p>

<h2>Settings</h2>
</td><td class="codes"><pre class="brush: clojure">(defn get-settings
  ([facility {:keys [instance-id default] :as options}]
     (plan-state/get-settings
      (:plan-state (session)) (session/target-id (session)) facility options))
  ([facility]
     (get-settings facility {})))</pre></td></tr><tr><td class="docs"><p>Retrieve the settings for the <code>facility</code> on the <code>node</code>. The instance-id
   allows the specification of specific instance of the facility. If passed a
   nil <code>instance-id</code>, then <code>:default</code> is used</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-node-settings
  ([node facility {:keys [instance-id default] :as options}]
     (plan-state/get-settings
      (:plan-state (session)) (node/id node) facility options))
  ([node facility]
     (get-node-settings node facility {})))</pre></td></tr><tr><td class="docs"><p>Set the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default).</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc-settings
  ([facility kv-pairs {:keys [instance-id] :as options}]
     (session!
      (update-in
       (session) [:plan-state]
       plan-state/assoc-settings
       (session/target-id (session)) facility kv-pairs options)))
  ([facility kv-pairs]
     (assoc-settings facility kv-pairs {})))</pre></td></tr><tr><td class="docs"><p>Update the settings for the specified host facility. The instance-id allows
   the specification of specific instance of the facility (the default is
   :default).</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-settings
  {:arglists '[[facility f &amp; args][facility options f &amp; args]]}
  [facility f-or-opts &amp; args]
  (let [[options f args] (if (or (map? f-or-opts) (nil? f-or-opts))
                           [f-or-opts (first args) (rest args)]
                           [nil f-or-opts args])]
    (assert f &quot;nil update function&quot;)
    (session!
     (update-in
      (session) [:plan-state]
      plan-state/update-settings
      (session/target-id (session)) facility f args options))))</pre></td></tr><tr><td class="docs"><p>Return a map of service phases for the specified facility, options and
  service function.  Optionally, specify :actions with a sequence of keywords
  for the actions you wish to generate service control phases for.</p>
</td><td class="codes"><pre class="brush: clojure">(defn service-phases
  [facility options service-f
   &amp; {:keys [actions] :or {actions [:start :stop :restart :status]}}]
  (letfn [(service-phases [action]
            (let [f #(apply-map service-f :action action options)]
              [[action f]
               [(keyword (str (name action) &quot;-&quot; (name facility))) f]]))]
    (into {} (mapcat service-phases actions))))</pre></td></tr><tr><td class="docs"><p>Local Variables:
mode: clojure
eval: (define-clojure-indent (defplan 'defun) (def-aggregate-plan-fn 'defun))
eval: (define-clojure-indent (def-collect-plan-fn 'defun))
eval: (define-clojure-indent (phase-context 2)(defmethod-plan 2))
End:</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.automated-admin-user" name="pallet.crate.automated-admin-user"><h1 class="project-name">pallet.crate.automated-admin-user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.automated-admin-user
  (:require
   [pallet.actions :refer [package-manager user]]
   [pallet.api :refer [plan-fn server-spec]]
   [pallet.crate :refer [admin-user defplan]]
   [pallet.crate.ssh-key :as ssh-key]
   [pallet.crate.sudoers :as sudoers]))</pre></td></tr><tr><td class="docs"><p>Authorise a single key, specified as a path or as a byte array.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan authorize-user-key
  [username path-or-bytes]
  (if (string? path-or-bytes)
    (ssh-key/authorize-key username (slurp path-or-bytes))
    (ssh-key/authorize-key username (String. ^bytes path-or-bytes))))</pre></td></tr><tr><td class="docs"><p>Builds a user for use in remote-admin automation. The user is given
  permission to sudo without password, so that passwords don't have to appear
  in scripts, etc.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan automated-admin-user
  ([]
     (let [user (admin-user)]
       (clojure.tools.logging/debugf &quot;a-a-u for %s&quot; user)
       (automated-admin-user
        (:username user)
        (:public-key-path user))))
  ([username]
     (let [user (admin-user)]
       (automated-admin-user username (:public-key-path user))))
  ([username &amp; public-key-paths]
     (sudoers/install)
     (user username :create-home true :shell :bash)
     (doseq [kp public-key-paths]
       (authorize-user-key username kp))
     (sudoers/sudoers
      {}
      {:default {:env_keep &quot;SSH_AUTH_SOCK&quot;}}
      {username {:ALL {:run-as-user :ALL :tags :NOPASSWD}}})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def with-automated-admin-user
  (server-spec
   :phases {:bootstrap (plan-fn
                          (package-manager :update)
                          (automated-admin-user))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.crontab" name="pallet.crate.crontab"><h1 class="project-name">pallet.crate.crontab</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>crontab management</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.crontab
  (:require
   [pallet.actions :refer [content-options exec-checked-script file remote-file]]
   [pallet.api :refer [plan-fn server-spec]]
   [pallet.crate :refer [assoc-settings defplan get-settings update-settings]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [with-source-line-comments]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def system-cron-dir &quot;/etc/cron.d&quot;)</pre></td></tr><tr><td class="docs"><p>Define the crontab settings.  The settings are a map from user name to a map
   of keyword argument values for remote-file content (under :user) and a map
   from system facility name to a map of keyword argument values for remote-file
   content</p>
</td><td class="codes"><pre class="brush: clojure">(defplan settings
  [settings]
  (assoc-settings :crontab settings))</pre></td></tr><tr><td class="docs"><p>Define empty crontab settings. This can be used to ensure that settings are
   available for crontab, independently of whether any are specified elsewhere.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan empty-settings
  []
  (update-settings :crontab identity))</pre></td></tr><tr><td class="docs"><p>Define the user's crontab settings.  The settings are a map of keyword
  argument values for remote-file content.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan user-settings
  [user settings-map]
  (update-settings :crontab assoc-in [:user user] settings-map))</pre></td></tr><tr><td class="docs"><p>Define the system's crontab settings.  The settings are a map of keyword
  argument values for remote-file content.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan system-settings
  [name settings-map]
  (update-settings :crontab assoc-in [:system name] settings-map))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- in-file [user]
  &quot;Create a path for a crontab.in file for the given user&quot;
  (str (with-source-line-comments false
         (stevedore/script (~lib/user-home ~user)))
       &quot;/crontab.in&quot;))</pre></td></tr><tr><td class="docs"><p>Create user crontab for the given user.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan create-user-crontab
  [user]
  (let [in-file (in-file user)
        settings (get-settings :crontab)
        content-spec (get (:user settings) user)]
    (apply-map
     remote-file
     in-file :owner user :mode &quot;0600&quot;
     (select-keys content-spec content-options))
    (exec-checked-script
     &quot;Load crontab&quot;
     (&quot;crontab&quot; -u ~user ~in-file))))</pre></td></tr><tr><td class="docs"><p>Remove user crontab for the specified user</p>
</td><td class="codes"><pre class="brush: clojure">(defplan remove-user-crontab
  [user]
  (let [in-file (in-file user)]
    (file in-file :action :delete)
    (exec-checked-script
     &quot;Remove crontab&quot;
     (&quot;crontab&quot; -u ~user -r))))</pre></td></tr><tr><td class="docs"><p>Write all user crontab files.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan user-crontabs
  [&amp; {:keys [action] :or {action :create}}]
  (let [settings (get-settings :crontab nil)]
    (doseq [k (keys (:user settings))]
      (case action
        :create (create-user-crontab k)
        :remove (remove-user-crontab k)))))</pre></td></tr><tr><td class="docs"><p>Path to system cron file for <code>name</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn- system-cron-file
  [name]
  (str system-cron-dir &quot;/&quot; name))</pre></td></tr><tr><td class="docs"><p>Create system crontab for the given name.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan create-system-crontab
  [system]
  (let [path (system-cron-file system)
        settings (get-settings :crontab)]
    (apply-map
     remote-file
     path :owner &quot;root&quot; :group &quot;root&quot; :mode &quot;0644&quot;
     (select-keys
      (get (:system settings) system) content-options))))</pre></td></tr><tr><td class="docs"><p>Remove system crontab for the given name</p>
</td><td class="codes"><pre class="brush: clojure">(defplan remove-system-crontab
  [system]
  (let [path (system-cron-file system)
        settings (get-settings :crontab)]
    (file path :action :delete)))</pre></td></tr><tr><td class="docs"><p>Write all system crontab files.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan system-crontabs
  [&amp; {:keys [action] :or {action :create}}]
  (let [settings (get-settings :crontab)]
    (doseq [k (keys (:system settings))]
     (case action
       :create (create-system-crontab k)
       :remove (remove-system-crontab k)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def with-crontab
  (server-spec
   :phases {:settings (plan-fn
                        (empty-settings))
            :configure (plan-fn
                         (system-crontabs :action :create)
                         (user-crontabs :action :create))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.environment" name="pallet.crate.environment"><h1 class="project-name">pallet.crate.environment</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Set up the system environment.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.environment
  (:require
   [clojure.string :as string]
   [pallet.action :refer [with-action-options]]
   [pallet.actions :refer [exec-script* plan-when plan-when-not remote-file]]
   [pallet.argument :refer [delayed]]
   [pallet.crate :refer [defplan os-family]]
   [pallet.action-plan :as action-plan]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn system-environment-file
  [env-name {:keys [path shared] :or {shared ::not-set} :as options}]
  (let [os-family (os-family)
        shared (if (= shared ::not-set)
                 (not (#{:rhel :centos :fedora} os-family))
                 shared)
        path (or path (stevedore/fragment (~lib/system-environment)))
        path (if shared path (str path &quot;/&quot; env-name &quot;.sh&quot;))]
    [path shared]))</pre></td></tr><tr><td class="docs"><p>Define system wide default environment.
   On redhat based systems, this is set in /etc/profile.d, so is only
   valid within a login shell. On debian based systems, /etc/environment
   is used.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan system-environment
  [env-name key-value-pairs &amp; {:keys [path shared literal] :as options}]
  (let [[path shared] (system-environment-file env-name options)
        quote (if literal &quot;'&quot; &quot;\&quot;&quot;)]
    (plan-when shared
      (with-action-options {:new-login-after-action true}
        (exec-script*
         (delayed [_]
           (action-plan/checked-commands*
            (format &quot;Add %s environment to %s&quot; env-name path)
            (conj
             (for [[k v] key-value-pairs]
               (stevedore/script
                (var vv (str ~quote ~v ~quote)) ; v can contain multi-line
                                        ; expressions
                (&quot;pallet_set_env&quot;
                 (quoted ~k)
                 (quoted @vv)
                 (quoted (str ~(name k) &quot;=\\\&quot;&quot; @vv &quot;\\\&quot;&quot;)))))
             (stevedore/script
              (if-not (file-exists? ~path)
                (lib/heredoc ~path &quot;# environment file created by pallet\n&quot; {}))
              (defn pallet_set_env [k v s]
                (if-not (&quot;grep&quot; (quoted @s) ~path &quot;2&gt;&amp;-&quot;)
                  (chain-or
                   (chain-and
                    (&quot;sed&quot; -i (~lib/sed-ext)
                     -e (quoted &quot;/$${k}=/ d&quot;) ~path)
                    (&quot;sed&quot; -i (~lib/sed-ext)
                     -e (quoted &quot;$ a \\\\\n${s}&quot;) ~path))
                   (&quot;exit&quot; 1)))))))))))
    (plan-when-not shared
      (with-action-options {:new-login-after-action true}
        (remote-file
         path
         :owner &quot;root&quot;
         :group &quot;root&quot;
         :mode 644
         :content (string/join
                   \newline
                   (for [[k v] key-value-pairs]
                     (str (name k) &quot;=&quot; (pr-str v))))
         :literal literal)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.etc-default" name="pallet.crate.etc-default"><h1 class="project-name">pallet.crate.etc-default</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Generation and installation of /etc/default-style files.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.etc-default
  (:require
   [clojure.string :as string]
   [pallet.actions :refer [remote-file]]
   [pallet.crate :refer [defplan]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [with-source-line-comments]]))</pre></td></tr><tr><td class="docs"><p>Writes a KEY=value file to /etc/default/~{filename}, or ~{filename} if
   filename starts with a /.  Note that all values are quoted, and quotes in
   values are escaped, but otherwise, values are written literally.</p>

<p>   e.g. (write "tomcat6"
          :JAVA_OPTS "-Xmx1024m"
          "JSP_COMPILER" "javac")</p>
</td><td class="codes"><pre class="brush: clojure">(defplan write
  [filename &amp; key-value-pairs]
  (let [file (if (= \/ (first filename))
               filename
               (str (with-source-line-comments false
                      (stevedore/script (~lib/etc-default)))
                    &quot;/&quot; filename))]
    (remote-file
     file
     :owner &quot;root&quot;
     :group &quot;root&quot;
     :mode 644
     :content (string/join
               \newline
               (for [[k v] (partition 2 key-value-pairs)]
                 (str (name k) &quot;=&quot; (pr-str v)))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.etc-hosts" name="pallet.crate.etc-hosts"><h1 class="project-name">pallet.crate.etc-hosts</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>/etc/hosts file.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.etc-hosts
  (:require
   [clojure.string :as string]
   [clojure.string :refer [blank?]]
   [clojure.tools.logging :refer [debugf]]
   [pallet.actions
    :refer [as-action exec-checked-script plan-when-not remote-file sed]]
   [pallet.compute :refer [os-hierarchy]]
   [pallet.crate
    :refer [defmethod-plan
            defmulti-plan
            defplan
            get-settings
            os-family
            target-name
            target-node
            target-node
            update-settings]]
   [pallet.node :as node]
   [pallet.node :refer [primary-ip private-ip]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore :refer [with-source-line-comments]]
   [pallet.utils :as utils]))</pre></td></tr><tr><td class="docs"><h2>Add entries to the host file settings</h2>
</td><td class="codes"><pre class="brush: clojure">(defn merge-hosts [&amp; ms]
  (apply merge-with (comp distinct concat) ms))</pre></td></tr><tr><td class="docs"><p>Declare a host entry. Names should be a sequence of names.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-host
  [ip-address names]
  (update-settings :hosts merge-hosts
                   {ip-address (if (string? names) [names] names)}))</pre></td></tr><tr><td class="docs"><p>Add a map of ip address to a sequence of hostname/aliases, to the host file
  settings.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-hosts
  [hosts-map]
  {:pre [(every? (complement string?) (vals hosts-map))]}
  (update-settings :hosts merge-hosts hosts-map))</pre></td></tr><tr><td class="docs"><p>Get the hostname as reported on the node.</p>

<h2>Query Hostname and DNS</h2>
</td><td class="codes"><pre class="brush: clojure">(defplan hostname
  [{:keys [fqdn]}]
  (let [r (exec-checked-script
           &quot;hostname&quot;
           (hostname ~(if fqdn &quot;-f&quot; &quot;&quot;)))]
    (as-action (:out @r))))</pre></td></tr><tr><td class="docs"><p>Get the hostname reported for the specified ip.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan reverse-dns
  [ip]
  (let [r (exec-checked-script
           (str &quot;reverse DNS for &quot; ip)
           (pipe (&quot;host&quot; ~ip) (&quot;awk&quot; &quot;'{print $NF}'&quot;)))]
    (as-action (:out @r))))</pre></td></tr><tr><td class="docs"><p>Get the ip for a hostname.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan resolve-dns
  [hostname]
  (let [r (exec-checked-script
           (str &quot;Resolve DNS for &quot; hostname)
           (pipe (&quot;host&quot; ~hostname) (&quot;awk&quot; &quot;'{print $NF}'&quot;)))]
    (as-action (:out @r))))</pre></td></tr><tr><td class="docs"><p>Get a host entry for the current node. Options all default to true
  and hostname takes priority over target-name, and private-ip over
  primary-ip.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan host-entry
  [{:keys [use-hostname use-private-ip]
    :or {use-hostname true use-private-ip true}}]
  (let [h (when use-hostname (hostname {:fqdn true}))
        n (target-node)]
    (as-action
     {(or (and use-private-ip (private-ip n))
          (primary-ip n))
      (vec
       (filter identity
               [(if (and use-hostname (not (blank? (:out @h))))
                  (:out @h)
                  (target-name))]))})))</pre></td></tr><tr><td class="docs"><h2>Localhost and other Aliases</h2>
</td><td class="codes"><pre class="brush: clojure">(def localhost
  {&quot;127.0.0.1&quot; [&quot;localhost&quot; &quot;localhost.localdomain &quot;]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn localhost-hostname
  [&amp; node-names]
  {&quot;127.0.1.1&quot; node-names})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ipv6-aliases
  {&quot;::1&quot; [&quot;ip6-localhost&quot; &quot;ip6-loopback&quot;]
   &quot;fe00::0&quot; [&quot;ip6-localnet&quot;]
   &quot;ff00::0&quot; [&quot;ip6-mcastprefix&quot;]
   &quot;ff02::1&quot; [&quot;ip6-allnodes&quot;]
   &quot;ff02::2&quot; [&quot;ip6-allrouters&quot;]
   &quot;ff02::3&quot; [&quot;ip6-allhosts&quot;]})</pre></td></tr><tr><td class="docs"><h2>Host File Generation</h2>
</td><td class="codes"><pre class="brush: clojure">(defn- format-entry
  [entry]
  (format &quot;%s %s&quot;  (key entry) (string/join &quot; &quot; (map name (val entry)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-hosts*
  [entries]
  (string/join &quot;\n&quot; (map format-entry (sort-by key entries))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defplan format-hosts
  []
  (let [settings (get-settings :hosts)]
    (format-hosts* settings)))</pre></td></tr><tr><td class="docs"><p>Writes the hosts files</p>
</td><td class="codes"><pre class="brush: clojure">(defplan hosts
  []
  (let [content (format-hosts)]
    (remote-file (stevedore/fragment (~lib/etc-hosts))
     :owner &quot;root&quot;
     :group &quot;root&quot;
     :mode 644
     :content content)))</pre></td></tr><tr><td class="docs"><h2>Set hostname</h2>
</td><td class="codes"><pre class="brush: clojure">(defmulti-plan set-hostname*
  (fn [hostname]
    (assert hostname &quot;Must specify a valid hostname&quot;)
    (debugf &quot;hostname dispatch %s&quot; hostname)
    (let [os (os-family)]
      (debugf &quot;hostname for os %s&quot; os)
      os))
  :hierarchy #'os-hierarchy)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan set-hostname* :linux [hostname]
  ;; change the hostname now
  (exec-checked-script
   &quot;Set hostname&quot;
   (&quot;hostname &quot; ~hostname))
  ;; make sure this change will survive reboots
  (remote-file
   &quot;/etc/hostname&quot;
   :owner &quot;root&quot; :group &quot;root&quot; :mode &quot;0644&quot;
   :content hostname))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan set-hostname* :rh-base [hostname]
  ;; change the hostname now
  (exec-checked-script &quot;Set hostname&quot; (&quot;hostname &quot; ~hostname))
  ;; make sure this change will survive reboots
  (sed &quot;/etc/sysconfig/network&quot;
       {&quot;HOSTNAME=.*&quot; (str &quot;HOSTNAME=&quot; hostname)}))</pre></td></tr><tr><td class="docs"><p>Set the hostname on a node. Note that sudo may stop working if the
hostname is not in /etc/hosts.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan set-hostname
  [&amp; {:keys [update-etc-hosts] :or {update-etc-hosts true}}]
  (let [node-name (target-name)]
    (when update-etc-hosts
      (plan-when-not (stevedore/script (&quot;grep&quot; ~node-name (lib/etc-hosts)))
        (exec-checked-script
         &quot;Add self hostname&quot;
         (println &quot;&gt;&gt;&quot; (lib/etc-hosts))
         ((println ~(node/primary-ip (target-node)) &quot; &quot; ~node-name)
          &quot;&gt;&gt;&quot; (lib/etc-hosts)))))
    (set-hostname* node-name)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.filesystem" name="pallet.crate.filesystem"><h1 class="project-name">pallet.crate.filesystem</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Filesystem crate.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.filesystem
  (:require
   [clojure.string :as string]
   [pallet.actions :refer [directory exec-checked-script]]
   [pallet.crate :refer [defplan]]))</pre></td></tr><tr><td class="docs"><p>Format a device as an XFS filesystem.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan make-xfs-filesytem
  [device]
  (exec-checked-script
   (format &quot;Format %s as XFS&quot; device)
   (&quot;mkfs.xfs&quot; -f ~device)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti format-mount-option
  (fn [[key value]] (class value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod format-mount-option :default
  [[key value]]
  (format &quot;%s=%s&quot; (name key) value))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod format-mount-option java.lang.Boolean
  [[key value]]
  (when value
    (format &quot;%s&quot; (name key))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- mount-cmd-options [options]
  (let [option-string (string/join &quot;,&quot;
                       (filter identity (map format-mount-option options)))]
    (if (string/blank? option-string)
      (str &quot;-o &quot; option-string))))</pre></td></tr><tr><td class="docs"><p>Mount a device.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan mount
  [device mount-point
   &amp; {:keys [fs-type device-type automount no-automount dump-frequency
             boot-check-pass]
      :or {dump-frequency 0 boot-check-pass 0}
      :as options}]
  (directory mount-point)
  (exec-checked-script
   (format &quot;Mount %s at %s&quot; device mount-point)
   (if-not @(&quot;mountpoint&quot; -q ~mount-point)
     (&quot;mount&quot; ~(if fs-type (str &quot;-t &quot; fs-type) &quot;&quot;)
      ~(mount-cmd-options
        (dissoc options :device-type :dump-frequency :boot-check-pass
                :fs-type))
      ~device (quoted ~mount-point)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.initd" name="pallet.crate.initd"><h1 class="project-name">pallet.crate.initd</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides service supervision via initd</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.initd
  (:require
   [clojure.tools.logging :refer [debugf]]
   [pallet.actions :refer [exec-checked-script plan-when remote-file]]
   [pallet.actions.direct.service :refer [service-impl]]
   [pallet.api :as api]
   [pallet.api :refer [plan-fn]]
   [pallet.core.session :refer [session]]
   [pallet.crate :refer [get-settings target-flag? update-settings]]
   [pallet.crate.service
    :refer [service-supervisor
            service-supervisor-available?
            service-supervisor-config]]
   [pallet.script.lib :refer [etc-init file]]
   [pallet.stevedore :refer [fragment]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs"><p>Return the init script path for the given service name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn init-script-path
  [service-name]
  (fragment (file (etc-init) ~service-name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor-available? :initd
  [_]
  true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn write-service
  [service-name {:keys [init-file] :as service-options} options]
  (when init-file                       ; enable use of pre-installed init files
    (apply-map
     remote-file
     (init-script-path service-name)
     :owner &quot;root&quot; :group &quot;root&quot; :mode &quot;0755&quot;
     :literal true
     init-file)))</pre></td></tr><tr><td class="docs"><p>Write out job definitions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn jobs
  [{:keys [instance-id] :as options}]
  (let [{:keys [jobs]} (get-settings :initd {:instance-id instance-id})]
    (debugf &quot;Writing service files for %s jobs&quot; (count jobs))
    (doseq [[job {:keys [run-file] :as service-options}] jobs
            :let [service-name (name job)]]
      (write-service service-name service-options options))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor-config :initd
  [_
   {:keys [service-name init-file] :as service-options}
   {:keys [instance-id] :as options}]
  (debugf &quot;Adding service settings for %s&quot; service-name)
  (update-settings
   :initd options assoc-in [:jobs (keyword service-name)] service-options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor :initd
  [_
   {:keys [service-name]}
   {:keys [action if-flag if-stopped instance-id]
    :or {action :start}
    :as options}]
  (if if-flag
    (plan-when (target-flag? if-flag)
      (exec-checked-script
       (str &quot;Initd &quot; (name action) &quot; &quot; service-name)
       ~(apply-map service-impl (session) service-name
                   (assoc options :service-impl :initd))))
    (exec-checked-script
       (str &quot;Initd &quot; (name action) &quot; &quot; service-name)
       ~(apply-map service-impl (session) service-name
                   (assoc options :service-impl :initd)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn server-spec [settings &amp; {:keys [instance-id] :as options}]
  (api/server-spec
   :phases {:configure (plan-fn (jobs options))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.limits-conf" name="pallet.crate.limits-conf"><h1 class="project-name">pallet.crate.limits-conf</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Configure the /etc/security/limits.conf file.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.limits-conf
  (:require
   [clojure.string :as string]
   [pallet.actions :refer [exec-checked-script file remote-file]]
   [pallet.api :refer [plan-fn] :as api]
   [pallet.crate :refer [assoc-settings get-settings update-settings]]
   [pallet.script :refer [defscript defimpl]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.utils :as utils]))</pre></td></tr><tr><td class="docs"><h1>Settings</h1>
</td><td class="codes"><pre class="brush: clojure">(defn default-settings
  []
  {:config-file &quot;/etc/security/limits.conf&quot;
   :owner &quot;root&quot;
   :group &quot;root&quot;})</pre></td></tr><tr><td class="docs"><p>Normalise an entry into map form, which is how the entries are kept in
  the settings map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- normalise-entry
  [entry]
  {:pre [(or (vector? entry) (map? entry))]}
  (if (map? entry)
    entry
    (zipmap [:domain :type :item :value] entry)))</pre></td></tr><tr><td class="docs"><p>Configure limits.conf settings.
  The :entries value is a sequence of maps and vectors.  Each map must
  specify :domain, :type, :item and :value fields.  Each vectors specifies
  strings for the fields (in domain, type, item, value order).  The type and
  item values may optionally be keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(defn settings
  [{:keys [entries config-file instance-id] :as settings}]
  (let [settings (merge (default-settings) settings)
        settings (update-in settings [:entries] #(mapv normalise-entry %))]
    (assoc-settings
     :limits-conf settings (select-keys settings [:instance-id]))))</pre></td></tr><tr><td class="docs"><p>Declare a host entry.  This may be called multiple times to build limits
  incrementally.</p>

<p>  A host entry can be either a map with :domain, :type, :item and :value keys,
  or a vector specifying strings for the fields (in domain, type, item, value
  order).  The type and item values may optionally be keywords.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ulimit
  [entry &amp; {:keys [instance-id] :as options}]
  {:pre [(or (vector? entry) (map? entry))]}
  (update-settings :limits-conf options
                   update-in [:entries] conj (normalise-entry entry)))</pre></td></tr><tr><td class="docs"><h1>Config file</h1>
</td><td class="codes"><pre class="brush: clojure">(defn- format-entry
  [{:keys [domain type item value] :or {type &quot;-&quot;}}]
  (format &quot;%s %s %s %s&quot; domain (name type) (name item) value))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- format-host-limits
  [entries]
  (string/join &quot;\n&quot; (map format-entry entries)))</pre></td></tr><tr><td class="docs"><p>Writes the limit.conf file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn configure
  [{:keys [instance-id] :as options}]
  (let [{:keys [config-file entries group owner]}
        (get-settings :limits-conf options)]
    (remote-file
     config-file
     :owner owner
     :group group
     :mode 644
     :content (format-host-limits entries))))</pre></td></tr><tr><td class="docs"><p>Return a server spec for limits.conf configuration.  See the <code>settings</code>
function for options to the settings map</p>

<h1>Server spec</h1>
</td><td class="codes"><pre class="brush: clojure">(defn server-spec
  [{:keys [entries config-file] :as settings}
   &amp; {:keys [instance-id] :as options}]
  (api/server-spec
   :phases {:settings (plan-fn
                        (pallet.crate.limits-conf/settings
                         (merge settings options)))
            :configure (plan-fn
                         (configure options))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.network-service" name="pallet.crate.network-service"><h1 class="project-name">pallet.crate.network-service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Crate for working with network services</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.network-service
  (:require
   [pallet.actions :refer [exec-checked-script]]
   [pallet.crate :refer [defplan]]
   [pallet.script.lib :as lib]))</pre></td></tr><tr><td class="docs"><p>Wait for the network port <code>port</code> to be in a listening state.</p>

<p>   Options:
   - :standoff      time between checking port state (seconds)
   - :max-retries   number of times to test port state before erroring
   - :service-name  name of service to use in messages (defaults to port)
   - :protocol      name of the network protocol family (:raw, :tcp, :udp or :udplite, defaults to :tcp)</p>
</td><td class="codes"><pre class="brush: clojure">(defplan wait-for-port-listen
  [port &amp; {:keys [max-retries standoff service-name protocol]
           :or {max-retries 5 standoff 2 protocol :tcp
                service-name (str &quot;port &quot; port)}}]
  (exec-checked-script
   (format &quot;Wait for %s to be in a listen state&quot; service-name)
   (group (chain-or (let x 0) true))
   (while
       (pipe (&quot;netstat&quot; ~(format &quot;-ln%s&quot; (case protocol
                                           :raw &quot;w&quot;
                                           :tcp &quot;t&quot;
                                           :udp &quot;u&quot;
                                           :udplite &quot;U&quot;)))
             (&quot;awk&quot; ~(format &quot;'$4 ~ /:%s$/ {exit 1}'&quot; port)))
     (let x (+ x 1))
     (if (= ~max-retries @x)
       (do
         (println
          ~(format &quot;Timed out waiting for listen state for %s&quot; service-name)
          &gt;&amp;2)
         (~lib/exit 1)))
     (println ~(format &quot;Waiting for %s to be in a listen state&quot; service-name))
     (&quot;sleep&quot; ~standoff))
   (&quot;sleep&quot; ~standoff)))</pre></td></tr><tr><td class="docs"><p>Wait for a url to respond with the given HTTP status code.</p>

<p>   Options:
   - :standoff      time between checking HTTP status (seconds)
   - :max-retries   number of times to test HTTP status before erroring
   - :url-name      name of url to use in messages (defaults to url)</p>
</td><td class="codes"><pre class="brush: clojure">(defplan wait-for-http-status
  [url status &amp; {:keys [max-retries standoff url-name cookie insecure
                        ssl-version]
                 :or {max-retries 5 standoff 2
                      url-name url}}]
  (exec-checked-script
   (format &quot;Wait for %s to return a %s status&quot; url-name status)
   (if (~lib/has-command? wget)
     (defn httpresponse []
       (pipe
        (&quot;wget&quot; -q -S -O &quot;/dev/null&quot;
         ~(if cookie (str &quot;--header &quot; (format &quot;'Cookie: %s'&quot; cookie)) &quot;&quot;)
         ~(if insecure &quot;--no-check-certificate&quot; &quot;&quot;)
         ~(if ssl-version (str &quot;--secure-protocol=SSLv&quot; ssl-version) &quot;&quot;)
         (quoted ~url) &quot;2&gt;&amp;1&quot;)
        (&quot;grep&quot; &quot;HTTP/1.1&quot;)
        (&quot;tail&quot; -1)
        (&quot;grep&quot; -o -e (quoted &quot;[0-9][0-9][0-9]&quot;))))
     (if (~lib/has-command? curl)
       (defn httpresponse []
         (&quot;curl&quot; -sL -w (quoted &quot;%{http_code}&quot;)
          ~(if cookie (str &quot;-b '&quot; cookie &quot;'&quot;) &quot;&quot;)
          ~(if insecure &quot;--insecure&quot; &quot;&quot;)
          ~(if ssl-version (str &quot;-&quot; ssl-version) &quot;&quot;)
          (quoted ~url)
          -o &quot;/dev/null&quot;))
       (do
         (println &quot;No httpresponse utility available&quot;)
         (~lib/exit 1))))
   (group (chain-or (let x 0) true))
   (while
       (!= ~status @(&quot;httpresponse&quot;))
     (let x (+ x 1))
     (if (= ~max-retries @x)
       (do
         (println
          ~(format
            &quot;Timed out waiting for %s to return a %s status&quot; url-name status)
          &gt;&amp;2)
         (~lib/exit 1)))
     (println ~(format &quot;Waiting for %s to return a %s status&quot; url-name status))
     (&quot;sleep&quot; ~standoff))
   (&quot;sleep&quot; ~standoff)))</pre></td></tr><tr><td class="docs"><p>Wait for a port to respond to a message with a given response regex.</p>

<p>   Options:
   - :host          host to check (defaults to localhost)
   - :timeout       time to wait for a response (default 2 secs)
   - :standoff      time between checking HTTP status (seconds)
   - :max-retries   number of times to test HTTP status before erroring
   - :service-name  name of service to use in messages (defaults to port)</p>
</td><td class="codes"><pre class="brush: clojure">(defplan wait-for-port-response
  [port message response-regex
   &amp; {:keys [host timeout max-retries standoff service-name]
      :or {host &quot;localhost&quot; max-retries 5 standoff 2 timeout 2
           service-name (str &quot;port &quot; port)}}]
  (exec-checked-script
   (format
    &quot;Wait for %s to return a response %s to message %s&quot;
    service-name response-regex message)
   (group (chain-or (let x 0) true))
   (while
       (&quot;!&quot; (pipe (println (quoted ~message))
                (&quot;nc&quot; -q ~timeout ~host ~port)
                (&quot;grep&quot; -E (quoted ~response-regex))))
     (let x (+ x 1))
     (if (= ~max-retries @x)
       (do
         (println
          ~(format
            &quot;Timed out waiting for %s to return response %s&quot;
            service-name response-regex)
          &gt;&amp;2)
         (~lib/exit 1)))
     (println
      ~(format
        &quot;Waiting for %s to return response %s&quot; service-name response-regex))
     (&quot;sleep&quot; ~standoff))
   (&quot;sleep&quot; ~standoff)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.nohup" name="pallet.crate.nohup"><h1 class="project-name">pallet.crate.nohup</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides supervision via nohup.  Note that this is very limited, and not
  really recommended for production use.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.nohup
  (:require
   [clojure.tools.logging :refer [debugf warnf]]
   [pallet.action :refer [with-action-options]]
   [pallet.actions :as actions]
   [pallet.actions
    :refer [directory
            exec-checked-script
            plan-when
            plan-when-not
            remote-file]]
   [pallet.api :as api]
   [pallet.api :refer [plan-fn]]
   [pallet.crate :refer [get-settings target-flag? update-settings]]
   [pallet.crate.service
    :refer [service-supervisor
            service-supervisor-available?
            service-supervisor-config]]
   [pallet.script.lib :refer [file state-root]]
   [pallet.stevedore :refer [fragment]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nohup-path []
  (fragment (file (state-root) &quot;pallet&quot; &quot;nohup-service&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn service-script-file
  ([service-name filename]
     (fragment (file (nohup-path) ~service-name ~filename)))
  ([service-name]
     (fragment (file (nohup-path) ~service-name))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn service-script-path [service-name]
  (service-script-file service-name &quot;run&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn service-script-output-path [service-name]
  (service-script-file service-name &quot;nohup.out&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn service-script-failed-path [service-name]
  (service-script-file service-name &quot;nohup.failed&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor-available? :nohup
  [_]
  true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn write-service
  [service-name {:keys [run-file user] :as service-options} options]
  (directory (service-script-file service-name) :owner user)
  (apply-map
   remote-file
   (service-script-path service-name)
   :mode &quot;0755&quot;
   :owner user
   run-file))</pre></td></tr><tr><td class="docs"><p>Write out job definitions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn jobs
  [{:keys [instance-id] :as options}]
  (let [{:keys [jobs]} (get-settings :nohup {:instance-id instance-id})]
    (debugf &quot;Writing service files for %s jobs&quot; (count jobs))
    (doseq [[job {:keys [run-file] :as service-options}] jobs
            :let [service-name (name job)]]
      (write-service service-name service-options options))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor-config :nohup
  [_ {:keys [service-name run-file user] :as service-options} options]
  (debugf &quot;Adding service settings for %s&quot; service-name)
  (update-settings
   :nohup options assoc-in [:jobs (keyword service-name)] service-options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start-nohup-service [service-name user]
  (actions/file (service-script-failed-path service-name) :action :delete)
  (with-action-options {:sudo-user user
                        :script-dir (service-script-file service-name)}
    (exec-checked-script
     (str &quot;Start &quot; service-name &quot; via nohup&quot;)
     (&quot;(&quot;
      (chain-or
       (&quot;nohup&quot; ~(service-script-path service-name)
        &quot;&gt;&quot; (service-script-output-path ~service-name))
       (&quot;touch&quot; (service-script-failed-path ~service-name)))
      &quot;&amp;&quot; &quot;)&quot;)
     (&quot;sleep&quot; 5)
     (not (file-exists? (service-script-failed-path ~service-name))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop-nohup-service [service-name user]
  (with-action-options {:sudo-user user}
    (exec-checked-script
     (str &quot;Kill &quot; service-name &quot; via killall&quot;)
     (&quot;killall&quot; (quoted ~service-name)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor :nohup
  [_
   {:keys [service-name user process-name]}
   {:keys [action if-flag if-stopped instance-id]
    :or {action :start}
    :as options}]
  (debugf &quot;Controlling service %s, :action %s, :if-stopped %s, :if-flag&quot;
          service-name action if-stopped (pr-str if-flag))
  (let [process-name (or process-name service-name)]
    (if (#{:enable :disable :start-stop} action)
      (warnf &quot;Requested action %s on service %s not implemented via nohup&quot;
             action service-name)
      (if if-flag
        (plan-when (target-flag? if-flag)
          (exec-checked-script
           (str ~(name action) &quot; &quot; ~service-name &quot; if config changed&quot;)
           (~(service-script-path service-name) ~(name action))))
        (if if-stopped
          (case action
            :start (plan-when-not
                       (fragment (&quot;pgrep&quot; -f (quoted ~process-name)))
                     (start-nohup-service service-name user))
            :stop nil
            :restart nil)
          (case action
            :start (start-nohup-service service-name user)
            :stop (stop-nohup-service process-name user)
            :restart (do
                       (stop-nohup-service process-name user)
                       (start-nohup-service service-name user))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn server-spec [settings &amp; {:keys [instance-id] :as options}]
  (api/server-spec
   :phases {:configure (plan-fn (jobs options))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.os" name="pallet.crate.os"><h1 class="project-name">pallet.crate.os</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>OS detection for pallet to determine os and version</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.os
  (:require
   [clojure.string :as string :refer [blank? lower-case]]
   [pallet.actions :refer [assoc-settings exec-script plan-when plan-when-not
                           with-action-values]]
   [pallet.crate :refer [defplan]]
   [pallet.stevedore :refer [script]]
   [pallet.utils :refer [maybe-assoc]]))</pre></td></tr><tr><td class="docs"><p>Returns a script, that when executed, should identify the os of a unix
  target.</p>

<p>NB no script functions here</p>
</td><td class="codes"><pre class="brush: clojure">(defn os-detection
  []
  (script
   (println &quot;{&quot;)
   (println &quot;  :os&quot; (str &quot;'\&quot;'&quot; @(&quot;uname&quot; -s) &quot;'\&quot;'&quot;))
   (println &quot;  :rev&quot; (str &quot;'\&quot;'&quot; @(&quot;uname&quot; -r) &quot;'\&quot;'&quot;))
   (println &quot;  :mach&quot; (str &quot;'\&quot;'&quot; @(&quot;uname&quot; -m) &quot;'\&quot;'&quot;))
   (println &quot;}&quot;)))</pre></td></tr><tr><td class="docs"><p>Returns a script, that when executed, should identify distro of a linux
  target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn distro-detection
  []
  (script
   (when (file-exists? &quot;/etc/debconf_version&quot;)
     (set! ID @(pipe (&quot;cat&quot; &quot;/etc/redhat-release&quot;)
                     (&quot;egrep&quot; -o -e &quot;'^[A-Za-z ]+release'&quot;)
                     (&quot;sed -e 's/ release//'&quot;)))
     (set! RELEASE @(&quot;lsb_release&quot; -s -r)))
   (when (file-exists? &quot;/etc/lsb-release&quot;)
     (&quot;source&quot; &quot;/etc/lsb-release&quot;)
     (set! ID @DISTRIB_ID)
     (set! RELEASE @DISTRIB_RELEASE))
   (when (file-exists? &quot;/etc/redhat-release&quot;)
     (set! ID @(pipe (&quot;cat&quot; &quot;/etc/redhat-release&quot;)
                     (&quot;egrep&quot; -o -e &quot;'^[A-Za-z ]+release'&quot;)
                     (&quot;sed -e 's/ release//'&quot;)))
     (set! RELEASE @(pipe (&quot;cat&quot; &quot;/etc/redhat-release&quot;)
                          (&quot;sed&quot; -e &quot;'s/.*release//'&quot;)
                          (&quot;sed&quot; -e &quot;'s/[^0-9.]//g'&quot;))))
   (when (file-exists? &quot;/etc/SUSE-release&quot;)
     (set! ID @(pipe (&quot;cat&quot; &quot;/etc/SUSE-release&quot;)
                     (&quot;tr&quot; &quot;\n&quot; &quot;' '&quot;)
                     (&quot;sed&quot; -e &quot;'s/VERSION.*//'&quot;)))
     (set! RELEASE @(pipe (&quot;cat&quot; &quot;/etc/SUSE-release&quot;)
                          (&quot;tr&quot; &quot;\n&quot; &quot;' '&quot;)
                          (&quot;sed&quot; -e &quot;'s/.*= //'&quot;))))
   (when (file-exists? &quot;/etc/mandrake-release&quot;)
     (set! ID &quot;Mandrake&quot;)
     (set! RELEASE @(pipe (&quot;cat&quot; &quot;/etc/mandrake-release&quot;)
                          (&quot;sed&quot; -e &quot;'s/.*release //'&quot;)
                          (&quot;sed&quot; -e &quot;'s/ .*//'&quot;))))
   (println &quot;{&quot;)
   (println &quot;  :id&quot; (str &quot;'\&quot;'&quot; @ID:-unknown &quot;'\&quot;'&quot;))
   (println &quot;  :release&quot; (str &quot;'\&quot;'&quot; @RELEASE:-unknown &quot;'\&quot;'&quot;))
   (println &quot;}&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def pre-map-output #&quot;(?m)[^{}]*\{&quot;)</pre></td></tr><tr><td class="docs"><p>Infer the OS family and version from a node</p>
</td><td class="codes"><pre class="brush: clojure">(defplan infer-os
  []
  (let [os (exec-script (os-detection))]
    (with-action-values [os]
      (when (and (number? (:exit os)) (zero? (:exit os)))
        (let [out (string/replace-first (:out os) pre-map-output &quot;{&quot;)
              os (read-string out)]
          (-&gt; os
              (maybe-assoc :os-family
                           (when-not (blank? (:os os))
                             (keyword (lower-case (:os os)))))
              (maybe-assoc :os-version
                           (when-not (blank? (:rev os))
                             (lower-case (:rev os))))))))))</pre></td></tr><tr><td class="docs"><p>Infer the linux distribution from a node</p>
</td><td class="codes"><pre class="brush: clojure">(defplan infer-distro
  []
  (let [distro (exec-script (distro-detection))]
    (with-action-values [distro]
      (when (and (number? (:exit distro)) (zero? (:exit distro)))
        (let [out (string/replace-first (:out distro) pre-map-output &quot;{&quot;)
              distro (read-string out)]
          (-&gt; distro
              (maybe-assoc :os-family
                           (when-not (blank? (:id distro))
                             (keyword (lower-case (:id distro)))))
              (maybe-assoc :os-version
                           (when-not (blank? (:release distro))
                             (lower-case (:release distro))))))))))</pre></td></tr><tr><td class="docs"><p>Infer OS and distribution.  Puts a map into the settings' :pallet/os
  facility.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan os
  []
  (let [os (infer-os)
        distro (infer-distro)
        m (with-action-values [distro os]
            (-&gt;&gt;
             (dissoc (merge os distro) :action-symbol :context)
             (remove #(#{:unknown &quot;unknown&quot;} (val %)))
             (into {})))]
    (assoc-settings :pallet/os m)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.package.centos" name="pallet.crate.package.centos"><h1 class="project-name">pallet.crate.package.centos</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the centos repositories</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.package.centos
  (:require
   [pallet.actions :refer [package package-source repository]]
   [pallet.crate :refer [defplan is-64bit?]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} centos-repo
  &quot;http://mirror.centos.org/centos/%s/%s/%s/repodata/repomd.xml&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} centos-repo-key
  &quot;http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-%s&quot;)</pre></td></tr><tr><td class="docs"><p>Return the centos package architecture for the target node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn 
  arch []
  (if (is-64bit?) &quot;x86_64&quot; &quot;i386&quot;))</pre></td></tr><tr><td class="docs"><p>Add a centos repository. By default, ensure that it has a lower than default
  priority.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-repository
  [&amp; {:keys [version repository enabled priority]
      :or {version &quot;5.5&quot; repository &quot;os&quot; enabled 0 priority 50}}]
  (let [arch-str (arch)]
    (package &quot;yum-priorities&quot;)
    (package-source
     (format &quot;Centos %s %s %s&quot; version repository arch-str)
     :yum {:url (format centos-repo version repository arch-str)
           :gpgkey (format centos-repo-key (str (first version)))
           :priority priority
           :enabled enabled})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod repository :centos
  [args]
  (apply-map add-repository args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.package.debian-backports" name="pallet.crate.package.debian-backports"><h1 class="project-name">pallet.crate.package.debian-backports</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the debian backports repository</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.package.debian-backports
  (:require
   [pallet.actions :refer [package-source repository]]
   [pallet.crate :refer [defplan]]
   [pallet.script.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs"><p>Add debian backport package repository</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-debian-backports
  []
  (package-source
   &quot;debian-backports&quot;
   :aptitude {:url &quot;http://backports.debian.org/debian-backports&quot;
              :release (str
                        (stevedore/script (~lib/os-version-name)) &quot;-backports&quot;)
              :scopes [&quot;main&quot;]}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod repository :debian-backports
  [args]
  (apply-map add-debian-backports args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.package.epel" name="pallet.crate.package.epel"><h1 class="project-name">pallet.crate.package.epel</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the epel repository</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.package.epel
  (:require
   [pallet.action :refer [with-action-options]]
   [pallet.actions
    :refer [exec-checked-script package package-manager repository]]
   [pallet.crate :refer [defplan]]
   [pallet.stevedore :refer [fragment]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs"><p>Add the EPEL repository</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-epel
  [&amp; {:keys [version] :or {version &quot;5-4&quot;}}]
  (with-action-options {:always-before #{package-manager package}}
    (exec-checked-script
     &quot;Add EPEL package repository&quot;
     (&quot;rpm&quot;
      -U --quiet
      ~(format
        &quot;http://download.fedoraproject.org/pub/epel/%s/%s/epel-release-%s.noarch.rpm&quot;
        (first version)
        (fragment @(pipe (&quot;uname&quot; -i) (&quot;sed&quot; &quot;s/\\d86/386/&quot;)))
        version)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod repository :epel
  [args]
  (apply-map add-epel args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.package.jpackage" name="pallet.crate.package.jpackage"><h1 class="project-name">pallet.crate.package.jpackage</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the jpackage repository</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.package.jpackage
  (:require
   [pallet.action :refer [with-action-options]]
   [pallet.actions
    :refer [add-rpm
            package
            package-manager
            package-source
            plan-when
            plan-when-not
            repository]]
   [pallet.crate
    :refer [assoc-settings defplan get-settings os-family os-version]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs"><p>The source for this rpm is available here:
http://plone.lucidsolutions.co.nz/linux/centos/
  jpackage-rpm-repository-for-centos-rhel-5.x
http://plone.lucidsolutions.co.nz/linux/centos/images/
  jpackage-utils-compat-el5-0.0.1-1.noarch.rpm/at_download/file</p>
</td><td class="codes"><pre class="brush: clojure">(def jpackage-utils-compat-rpm
  (str &quot;https://github.com/downloads/pallet/pallet/&quot;
       &quot;jpackage-utils-compat-el5-0.0.1-1.noarch.rpm&quot;))</pre></td></tr><tr><td class="docs"><p>Add jpackge-utils. Due to incompatibilities on RHEL derived distributions,
   a compatability package is required.</p>

<p>   https://bugzilla.redhat.com/show_bug.cgi?id=260161
   https://bugzilla.redhat.com/show_bug.cgi?id=497213</p>
</td><td class="codes"><pre class="brush: clojure">(defplan jpackage-utils
  []
  (let [os-family (os-family)
        os-version (os-version)]
    (plan-when
        (or
         (= :fedora os-family)
         (and
          (#{:rhel :centos} os-family)
          (re-matches #&quot;5\.[0-5]&quot; os-version)))
      (with-action-options {:action-id ::install-jpackage-compat}
        (add-rpm
         &quot;jpackage-utils-compat-el5-0.0.1-1&quot;
         :url jpackage-utils-compat-rpm
         :insecure true)))) ;; github's ssl doesn't validate
  (package &quot;jpackage-utils&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def jpackage-mirror-fmt
  &quot;http://www.jpackage.org/mirrorlist.php?dist=%s&amp;type=%s&amp;release=%s&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mirrorlist
  [dist type release]
  (format jpackage-mirror-fmt dist type release))</pre></td></tr><tr><td class="docs"><p>Add the jpackage repository.  component should be one of:
     fedora
     redhat-el</p>

<p>   Installs the jpackage-utils package from the base repos at a
   priority of 25.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-jpackage
  [&amp; {:keys [version component releasever enabled]
      :or {component &quot;redhat-el&quot;
           releasever &quot;$releasever&quot;
           version &quot;5.0&quot;
           enabled 0}}]
  (let [os-family (os-family)
        os-version (os-version)
        no-updates (and                 ; missing updates for fedora 13, 14
                    (= version &quot;5.0&quot;)
                    (= :fedora os-family)
                    (try
                      (&lt; 12 (Integer/decode (str os-version)))
                      (catch NumberFormatException _)))
        jpackage-repos (vec
                        (filter
                         identity
                         [&quot;jpackage-generic&quot;
                          &quot;jpackage-generic-updates&quot;
                          &quot;jpackage-generic-non-free&quot;
                          &quot;jpackage-generic-updates-non-free&quot;
                          (format &quot;jpackage-%s&quot; component)
                          (when-not no-updates
                            (format &quot;jpackage-%s-updates&quot; component))]))]
    (package-source
     &quot;jpackage-generic&quot;
     :yum {:mirrorlist (mirrorlist &quot;generic&quot; &quot;free&quot; version)
           :failovermethod &quot;priority&quot;
           ;;gpgkey &quot;http://www.jpackage.org/jpackage.asc&quot;
           :enabled enabled})
    (package-source
     &quot;jpackage-generic-non-free&quot;
     :yum {:mirrorlist (mirrorlist &quot;generic&quot; &quot;non-free&quot; version)
           :failovermethod &quot;priority&quot;
           ;;gpgkey &quot;http://www.jpackage.org/jpackage.asc&quot;
           :enabled enabled})
    (package-source
     (format &quot;jpackage-%s&quot; component)
     :yum {:mirrorlist (mirrorlist
                        (str component &quot;-&quot; releasever) &quot;free&quot; version)
           :failovermethod &quot;priority&quot;
           ;;:gpgkey &quot;http://www.jpackage.org/jpackage.asc&quot;
           :enabled enabled})
    (package-source
     &quot;jpackage-generic-updates&quot;
     :yum {:mirrorlist (mirrorlist &quot;generic&quot; &quot;free&quot; (str version &quot;-updates&quot;))
           :failovermethod &quot;priority&quot;
           ;;:gpgkey &quot;http://www.jpackage.org/jpackage.asc&quot;
           :enabled enabled})
    (package-source
     &quot;jpackage-generic-updates-non-free&quot;
     :yum {:mirrorlist (mirrorlist
                        &quot;generic&quot; &quot;non-free&quot; (str version &quot;-updates&quot;))
           :failovermethod &quot;priority&quot;
           ;;:gpgkey &quot;http://www.jpackage.org/jpackage.asc&quot;
           :enabled enabled})
    (plan-when-not no-updates
                       (package-source
                        (format &quot;jpackage-%s-updates&quot; component)
                        :yum {:mirrorlist (mirrorlist
                                           (str component &quot;-&quot; releasever)
                                           &quot;free&quot;
                                           (str version &quot;-updates&quot;))
                              :failovermethod &quot;priority&quot;
                              ;;:gpgkey &quot;http://www.jpackage.org/jpackage.asc&quot;
                              :enabled enabled}))
    (assoc-settings :jpackage-repos {:repos jpackage-repos})))</pre></td></tr><tr><td class="docs"><p>Update the package lists for the jpackage repositories</p>
</td><td class="codes"><pre class="brush: clojure">(defplan package-manager-update-jpackage
  []
  (let [{:keys [repos]} (get-settings :jpackage-repos)]
    (package-manager
     :update
     :disable [&quot;*&quot;]
     :enable repos)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod repository :jpackage
  [args]
  (apply-map add-jpackage args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.package.rpmforge" name="pallet.crate.package.rpmforge"><h1 class="project-name">pallet.crate.package.rpmforge</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Actions for working with the rpmforge repository</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.package.rpmforge
  (:require
   [pallet.action :refer [action-fn with-action-options]]
   [pallet.actions
    :refer [exec-checked-script package package-manager repository]]
   [pallet.actions-impl :refer [remote-file-action]]
   [pallet.core.session :refer [session]]
   [pallet.crate :refer [defplan]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs"><p>TODO remove this and use plan-when</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
  remote-file* (action-fn remote-file-action :direct))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true}
  rpmforge-url-pattern
  &quot;http://packages.sw.be/rpmforge-release/rpmforge-release-%s.%s.rf.%s.rpm&quot;)</pre></td></tr><tr><td class="docs"><p>Add the rpmforge repository</p>

<p>this is an aggregate so that it can come before the aggragate package-manager</p>
</td><td class="codes"><pre class="brush: clojure">(defplan add-rpmforge
  [&amp; {:keys [version distro arch]
      :or {version &quot;0.5.2-2&quot; distro &quot;el5&quot; arch &quot;i386&quot;}}]
  (with-action-options {:always-before #{package-manager package}}
    (let [session (session)]
      (exec-checked-script
       &quot;Add rpmforge repositories&quot;
       (chain-or
        (if (= &quot;0&quot; @(pipe (&quot;rpm&quot; -qa) (&quot;grep&quot; rpmforge) (&quot;wc&quot; -l)))
          (do
            ~(first
              (remote-file*
               session
               &quot;rpmforge.rpm&quot;
               {:url (format rpmforge-url-pattern version distro arch)}))
            (&quot;rpm&quot; -U --quiet &quot;rpmforge.rpm&quot;))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod repository :rpmforge
  [args]
  (apply-map add-rpmforge args))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.package-repo" name="pallet.crate.package-repo"><h1 class="project-name">pallet.crate.package-repo</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Package repositories</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.package-repo
  (:require
   [pallet.actions :refer [exec-checked-script packages]]
   [pallet.crate :refer [defplan]]
   [pallet.script :refer [defimpl defscript]]))</pre></td></tr><tr><td class="docs"><p>https://help.ubuntu.com/community/Repositories/Personal
http://odzangba.wordpress.com/2006/10/13/how-to-build-local-apt-repositories/</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defscript rebuild-repo [path])
(defimpl rebuild-repo [#{:apt :aptitude}] [path]
  (&quot;cd&quot; ~path)
  (pipe
   (&quot;dpkg-scanpackages&quot; . &quot;/dev/null&quot;)
   (&quot;gzip&quot; &quot;-9c&quot; &gt; Packages.gz))
  (&quot;cd&quot; -))</pre></td></tr><tr><td class="docs"><p>Rebuild repository indexes for the repository at path</p>
</td><td class="codes"><pre class="brush: clojure">(defplan rebuild-repository
  [path]
  (exec-checked-script
   (str &quot;Rebuild repository &quot; path)
   (~rebuild-repo ~path)))</pre></td></tr><tr><td class="docs"><p>Install packages required for building repositories</p>
</td><td class="codes"><pre class="brush: clojure">(defplan repository-packages
  []
  (packages :aptitude [&quot;dpkg-dev&quot;]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.service" name="pallet.crate.service"><h1 class="project-name">pallet.crate.service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Run services under supervision.</p>

<p>This crate provides a framework for a process under supervision.  It can be
extended by different supervision providers, by providing methods for the
various multi-methods.  A crate can provide configuration for use with a range
of supervision providers.</p>

<p>To control a service, the <code>service</code> function is used.</p>

<p>To configure a job for a service, implement a supervisor-config-map for the
facility and supervision service you wish to use.  Ensure the <code>server-spec</code> for
the supervision implementation is extended by your group-spec.</p>

<p>To create an implementation for a new service supervision provider, implement
methods for <code>service-supervisor-available?</code>, <code>service-supervisor</code> and
<code>service-supervisor-config</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.service)</pre></td></tr><tr><td class="docs"><p>Service Supervisor SPI</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Predicate to test if a given service implementation is available.</p>

<p>New supervisors can be added by providing methods for these multimethods.
They are dispatched on a <code>supervisor</code> keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti service-supervisor-available?
  (fn [supervisor] supervisor))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod service-supervisor-available? :default
  [supervisor] false)</pre></td></tr><tr><td class="docs"><p>Provides an open dispatched supervisor implementation.</p>

<p>Implement a method dispatched on the supervisor keyword to add a
supervisor implementation.</p>

<p>In options:</p>

<p><code>:action</code>
: the action to be performed.  Should support <code>:start</code>, <code>:stop</code> and <code>:restart</code>.</p>

<p><code>:instance-id</code>
: specifies the supervisor instance-id, not the facility instance-id.</p>

<p>The :start action should not complain if the service is already running.</p>

<p>The :restart action should not complain if the service is not running.</p>

<p>The :stop action should not complain if the service is not running.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti service-supervisor
  (fn [supervisor settings options] supervisor))</pre></td></tr><tr><td class="docs"><p>Configure a service implementation based on configuration map.  The <code>config</code>
map is specific to the supervisor.  The initial enabled status of a config is
supervisor specific.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti service-supervisor-config
  (fn [supervisor config supervisor-options]
    {:pre [supervisor]}
    (when-not (service-supervisor-available? supervisor)
      (throw
       (ex-info
        (str (name supervisor)
             &quot; supervisor requested, but the&quot;
             (name supervisor) &quot; crate is not on the classpath.&quot;)
        {:type :pallet/not-on-classpath
         :resource supervisor})))
    supervisor))</pre></td></tr><tr><td class="docs"><h1>Crate Implementer API</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Control a process under supervision.</p>

<p>The settings map must provide <code>:service-name</code> and <code>:supervisor</code> keys.  The
<code>:supervisor</code> key specifies a keyword for the supervisor provider to dispatch
to.  The <code>:service-name</code> provides a service name to be used by the supervision
provider.  It is not an error to call with <code>:action :start</code> if the process is
already running.</p>

<p><code>:action</code>
One of <code>:enable</code>, <code>:disable</code>, <code>:start</code>, <code>:stop</code>, <code>:restart</code>, <code>:status</code>. Defaults
to :start.</p>

<p><code>:if-stopped</code>
Flag to only apply the action if the service is currently stopped.</p>

<p><code>:if-flag</code>
Flag to only apply the action only if the specified flag is set.</p>

<p><code>:instance-id</code>
Specifies an instance id, should there be more than one instance of the
supervisor (not the facility).</p>

<h2>Service Control</h2>

<p>This can be called by a crate to control a service</p>
</td><td class="codes"><pre class="brush: clojure">(defn service
  [{:keys [supervisor service-name] :as settings}
   {:keys [action if-flag if-stopped instance-id] :as options}]
  {:pre [supervisor service-name]}
  (service-supervisor supervisor settings options))</pre></td></tr><tr><td class="docs"><p>Return a service configuration map for the given supervisor and facility.</p>

<p>A method should be implemented in each crate for each supervisor to be
supported.</p>

<h2>Service Configuration</h2>

<p>Provide service supervision helpers for crates.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti supervisor-config-map
  (fn [facility {:keys [supervisor] :as settings} options]
    [facility supervisor]))</pre></td></tr><tr><td class="docs"><p>Provide a default method to generate a meaningful error message for the case
that the crate (facility) has not provided a supervisor configuration
for the given supervisor.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod supervisor-config-map :default
  [facility {:keys [supervisor] :as settings} _]
  (throw
   (ex-info
    (str (name supervisor)
         &quot; supervisor requested for &quot; (name facility)
         &quot;, but this has not been implemented.&quot;)
    {:type :pallet/unimplemented-supervisor
     :supervisor supervisor
     :facility facility})))</pre></td></tr><tr><td class="docs"><p>Configure service supervision for facility based on configuration map.</p>

<p>Supervisor specific options are specified under the supervisor key in the
settings map.</p>

<p>This is intended to be called at the crate level.</p>
</td><td class="codes"><pre class="brush: clojure">(defn supervisor-config
  [facility {:keys [supervisor] :as settings} options]
  (service-supervisor-config
   supervisor
   (supervisor-config-map facility settings options)
   (get settings supervisor)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.ssh-key" name="pallet.crate.ssh-key"><h1 class="project-name">pallet.crate.ssh-key</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Crate functions for manipulating SSH-keys</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.ssh-key
  (:require
   [clojure.string :as string]
   [pallet.actions
    :refer [directory
            exec-checked-script
            file
            remote-file
            remote-file-content
            sed]]
   [pallet.crate :refer [admin-user defplan]]
   [pallet.script.lib :as lib]
   [pallet.script.lib :refer [user-home]]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [fragment with-source-line-comments]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user-ssh-dir [user]
  (str
   (with-source-line-comments false
     (stevedore/script (~lib/user-home ~user)))
   &quot;/.ssh/&quot;))</pre></td></tr><tr><td class="docs"><p>Authorize a public key on the specified user.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan authorize-key
  [user public-key-string &amp; {:keys [authorize-for-user]}]
  (let [target-user (or authorize-for-user user)
        dir (user-ssh-dir target-user)
        auth-file (str dir &quot;authorized_keys&quot;)]
    (directory dir :owner target-user :mode &quot;755&quot;)
    (file auth-file :owner target-user :mode &quot;644&quot;)
    (exec-checked-script
     (format &quot;authorize-key on user %s&quot; user)
     (var auth_file ~auth-file)
     (if-not (&quot;fgrep&quot; (quoted ~(string/trim public-key-string)) @auth_file)
       (println (quoted ~public-key-string) &quot;&gt;&gt;&quot; @auth_file)))
    (exec-checked-script
     &quot;Set selinux permissions&quot;
     (~lib/selinux-file-type ~dir &quot;user_home_t&quot;))))</pre></td></tr><tr><td class="docs"><p>Authorize a user's public key on the specified user, for ssh access to
  localhost.  The :authorize-for-user option can be used to specify the
  user to who's authorized_keys file is modified.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan authorize-key-for-localhost
  [user public-key-filename &amp; {:keys [authorize-for-user] :as options}]
  (let [target-user (or authorize-for-user user)
        key-file (str (user-ssh-dir user) public-key-filename)
        auth-file (str (user-ssh-dir target-user) &quot;authorized_keys&quot;)]
    (directory
     (user-ssh-dir target-user) :owner target-user :mode &quot;755&quot;)
    (file auth-file :owner target-user :mode &quot;644&quot;)
    (exec-checked-script
     &quot;authorize-key&quot;
     (var key_file ~key-file)
     (var auth_file ~auth-file)
     (if-not (&quot;grep&quot; (quoted @(&quot;cat&quot; @key_file)) @auth_file)
       (do
         (print (quoted &quot;from=\\\&quot;localhost\\\&quot; &quot;) &quot;&gt;&gt;&quot; @auth_file)
         (&quot;cat&quot; @key_file &quot;&gt;&gt;&quot; @auth_file))))))</pre></td></tr><tr><td class="docs"><p>Install a ssh private key.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan install-key
  [user key-name private-key-string public-key-string]
  (let [ssh-dir (user-ssh-dir user)]
    (directory ssh-dir :owner user :mode &quot;755&quot;)
    (remote-file
     (str ssh-dir key-name)
     :owner user :mode &quot;600&quot;
     :content private-key-string)
    (remote-file
     (str ssh-dir key-name &quot;.pub&quot;)
     :owner user :mode &quot;644&quot;
     :content public-key-string)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ssh-default-filenames
     {&quot;rsa1&quot; &quot;identity&quot;
      &quot;rsa&quot; &quot;id_rsa&quot;
      &quot;dsa&quot; &quot;id_dsa&quot;})</pre></td></tr><tr><td class="docs"><p>Generate an ssh key pair for the given user, unless one already
   exists. Options are:
     :filename path -- output file name (within ~user/.ssh directory)
     :type key-type -- key type selection
     :no-dir true   -- do note ensure directory exists
     :passphrase    -- new passphrase for encrypting the private key
     :comment       -- comment for new key</p>
</td><td class="codes"><pre class="brush: clojure">(defplan generate-key
  [user &amp; {:keys [type filename passphrase no-dir comment]
           :or {type &quot;rsa&quot; passphrase &quot;&quot;}
           :as  options}]
  (let [key-type type
        ^String path (stevedore/script
                      ~(str (user-ssh-dir user)
                            (or filename (ssh-default-filenames key-type))))
        ssh-dir (.getParent (java.io.File. path))]
    (when-not (or (:no-dir options))
      (directory ssh-dir :owner user :mode &quot;755&quot;))
    (exec-checked-script
     &quot;ssh-keygen&quot;
     (var key_path ~path)
     (if-not (file-exists? @key_path)
       (&quot;ssh-keygen&quot; ~(stevedore/map-to-arg-string
                       {:f (stevedore/script @key_path)
                        :t key-type
                        :N passphrase
                        :C (or (:comment options &quot;generated by pallet&quot;))}))))
    (file path :owner user :mode &quot;0600&quot;)
    (file (str path &quot;.pub&quot;) :owner user :mode &quot;0644&quot;)))</pre></td></tr><tr><td class="docs"><p>Returns the public key for the specified remote <code>user</code>. By default it returns
the user's id_rsa key from <code>~user/.ssh/id_rsa.pub</code>.</p>

<p>You can specify a different key type by passing :type. This assumes the public
key has a <code>.pub</code> extension.</p>

<p>Passing a :filename value allows direct specification of the filename.</p>

<p><code>:dir</code> allows specification of a different location.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan public-key
  [user &amp; {:keys [filename dir type] :or {type &quot;rsa&quot;} :as options}]
  (let [filename (or filename (str (ssh-default-filenames type) &quot;.pub&quot;))
        path (str (or dir (user-ssh-dir user)) filename)]
    (remote-file-content path)))</pre></td></tr><tr><td class="docs"><p>Update an ssh config file. Sets the configuration for <code>host</code> to be that given
by the key-value-map.  Optionally allows specification of the <code>user</code> whose ssh
config file is to be modified, and the full <code>config-file</code> path.</p>
</td><td class="codes"><pre class="brush: clojure">(defplan config
  [host key-value-map &amp; {:keys [user config-file]
                         :or {user (:username (admin-user))}}]
  (let [content (str &quot;Host &quot; host \newline
                     (string/join \newline
                                  (map
                                   #(str &quot;  &quot; (first %) &quot; = &quot; (second %))
                                   key-value-map)))
        config-file (or config-file
                        (fragment (lib/file (user-home ~user) &quot;.ssh&quot; config)))]
    (file config-file :owner user :mode &quot;600&quot;) ; ensure it exists
    (sed config-file (str &quot;{ /^Host &quot; host &quot;/d; /^Host / !d ;}&quot;) ;remove old
         :quote-with &quot;'&quot; :restriction (str &quot;/^Host &quot; host &quot;/,/^Host/&quot;))
    (exec-checked-script
     &quot;Append ssh config&quot;
     (println (str &quot;'&quot; ~content &quot;'&quot;) &quot;&gt;&gt;&quot; ~config-file))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate.sudoers" name="pallet.crate.sudoers"><h1 class="project-name">pallet.crate.sudoers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate.sudoers
  (:require
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.actions :refer [package]]
   [pallet.crate :refer [admin-group def-collect-plan-fn defplan phase-context]]
   [pallet.template :as template]
   [pallet.utils :as utils]))</pre></td></tr><tr><td class="docs"><p>TODO - add recogintion of +key or key+
TODO - add escaping according to man page
TODO - dsl for sudoers, eg. (alias "user1" "user2" :as :ADMINS)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defplan install
  [&amp; {:keys [package-name action]
      :or {package-name &quot;sudo&quot; action :install}}]
  (package package-name :action action))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defplan default-specs
  []
  (let [admin-group (admin-group)]
    (array-map
     &quot;root&quot; {:ALL {:run-as-user :ALL}}
     (str &quot;%&quot; admin-group)
     {:ALL {:run-as-user :ALL}})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- param-string [[key value]]
  (cond
   (instance? Boolean value) (str
                              (if-not value &quot;!&quot;) (utils/underscore (name key)))
   (instance? String value) (str (utils/underscore (name key)) \= value)
   (keyword? value) (str
                     (utils/underscore (name key))
                     \=
                     (utils/underscore (name value)))
   :else (str (utils/underscore (name key)) \= value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-defaults [type name defaults]
  (str &quot;Defaults&quot; type name &quot; &quot;
       (string/join  &quot;,&quot; (map param-string defaults))
       &quot;\n&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- defaults-for [defaults key type]
  (apply
   str
   (map
    #(write-defaults type (utils/as-string (first %)) (second %))
    (defaults key))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- defaults [defaults]
  (str
   (when-let [default (:default defaults)]
     (write-defaults   default))
   (apply str
          (map (partial defaults-for defaults)
               [:run-as-user :user :host] [ \&gt; \: \@]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-aliases [type name aliased]
  (str type &quot; &quot; (string/upper-case name) &quot; = &quot;
       (apply str (interpose &quot;,&quot; (map str aliased)))
       &quot;\n&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- aliases-for [aliases key type]
  (apply
   str
   (map #(write-aliases type (name (first %)) (second %)) (aliases key))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- aliases [aliases]
  (apply str
          (map (partial aliases-for aliases)
               [:user :run-as-user :host :cmnd]
               [&quot;User_Alias&quot; &quot;Runas_Alias&quot; &quot;Host_Alias&quot; &quot;Cmnd_Alias&quot;])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- as-tag [item]
  (str (utils/as-string item) &quot;:&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- tag-or-vector [item]
  (if (vector? item)
    (string/join &quot; &quot; (map as-tag item))
    (as-tag item)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- item-or-vector [item]
  (if (vector? item)
    (string/join &quot;,&quot; (map utils/as-string item))
    (utils/as-string item)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-cmd-spec [[cmds options]]
  (str (when (:run-as-user options)
         (str &quot;(&quot; (item-or-vector (:run-as-user options))  &quot;) &quot;))
       (when (:tags options)
         (str (tag-or-vector (:tags options)) &quot; &quot;))
       (item-or-vector cmds)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-host-spec [host-spec]
  (logging/trace (str &quot;write-host-spec&quot; host-spec))
  (str
   (item-or-vector (or (:host host-spec) :ALL)) &quot; = &quot;
   (string/join &quot;,&quot; (map write-cmd-spec (dissoc host-spec :host)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- write-spec [[user-spec host-spec]]
  (str (item-or-vector user-spec) &quot; &quot;
       (if (vector? host-spec)
         (string/join &quot; : &quot; (map write-host-spec host-spec))
         (write-host-spec host-spec))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- specs [spec-map]
  (string/join &quot;\n&quot; (map write-spec spec-map)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(template/deftemplate sudoer-templates
  [aliases-map default-map spec-map]
  {{:path &quot;/etc/sudoers&quot; :owner &quot;root&quot; :mode &quot;0440&quot;}
   (str
    (aliases aliases-map)
    (defaults default-map)
    (specs spec-map))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- merge-user-spec [m1 m2]
  (cond
   (and (map? m1) (map? m2) (and (= (:host m1) (:host m2))))
   (merge m2 m1)
   (and (vector? m1) (vector? m2))
   (apply vector (concat m1 m2))
   :else
   (throw
    (IllegalArgumentException.
     &quot;do not know how to merge mixed style user specs&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- sudoer-merge [initial args]
  (letfn [(merge-fn [m initial-keys args-keys]
                    (let [additional-keys
                          (filter
                           #(not-any? (fn [x] (= x %)) initial-keys) args-keys)]
                      (apply array-map
                       (apply
                        concat
                        (map
                         #(vector % (m %))
                         (concat initial-keys additional-keys))))))]
    (reduce (fn [v1 v2]
              (map #(merge-fn
                     (merge-with merge-user-spec %1 %2) (keys %1) (keys %2))
                   v1 v2))
            initial args)))</pre></td></tr><tr><td class="docs"><p>Sudo configuration. Generates a sudoers file.
By default, root and an admin group are already present.</p>

<p>Examples of the arguments are:</p>

<p>aliases { :user { :ADMINS [ "user1" "user2" ] }
          :host { :TRUSTED [ "host1" ] }
          :run-as-user { :OP [ "root" "sysop" ] }
          :cmnd { :KILL [ "kill" ]
                  :SHELLS [ "/usr/bin/sh" "/usr/bin/csh" "/usr/bin/ksh"]}}
default-map { :default { :fqdn true }
              :host { "host" { :lecture false } }
              :user { "user" { :lecture false } }
              :run-as-user { "sysop" { :lecture false } } }
specs [ { ["user1" "user2"]
          { :host :TRUSTED
            :KILL { :run-as-user "operator" :tags :NOPASSWORD }
            ["/usr/bin/<em>" "/usr/local/bin/</em>"]
            { :run-as-user "root" :tags [:NOEXEC :NOPASSWORD} }</p>
</td><td class="codes"><pre class="brush: clojure">(def-collect-plan-fn sudoers
  [aliases defaults specs]
  (fn [&amp; args]
    (logging/trace &quot;apply-sudoers&quot;)
    (phase-context sudoers {}
      (let [specs (default-specs)]
        (template/apply-templates
         sudoer-templates
         (sudoer-merge
          [(array-map) (array-map) specs]
          args))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.crate-install" name="pallet.crate-install"><h1 class="project-name">pallet.crate-install</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Install methods for crates</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.crate-install
  (:require
   [clj-schema.schema
    :refer [def-map-schema map-schema optional-path sequence-of]]
   [clojure.tools.logging :refer [debugf tracef]]
   [pallet.action :refer [with-action-options]]
   [pallet.actions :as actions]
   [pallet.actions
    :as actions
    :refer [add-rpm
            debconf-set-selections
            package
            package-manager
            package-source-changed-flag
            plan-when
            remote-directory
            remote-directory-arguments
            remote-file-arguments]]
   [pallet.contracts :refer [check-keys]]
   [pallet.crate
    :refer [defmethod-plan defmulti-plan get-settings target-flag?]]
   [pallet.crate.package.epel :refer [add-epel]]
   [pallet.crate.package.debian-backports :refer [add-debian-backports]]
   [pallet.crate.package-repo :refer [rebuild-repository repository-packages]]
   [pallet.utils :refer [apply-map]])
  (:import clojure.lang.IPersistentVector
           clojure.lang.Keyword))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def-map-schema crate-install-settings
  :strict
  [[:install-strategy] Keyword
   (optional-path [:packages]) (sequence-of String)
   (optional-path [:package-source]) (map-schema :loose [[:name] String])
   (optional-path [:package-options]) (map-schema :loose [])
   (optional-path [:preseeds]) (sequence-of IPersistentVector)
   (optional-path [:rpm]) (map-schema
                           :strict remote-file-arguments [[:name] String])
   (optional-path [:debs]) remote-file-arguments
   (optional-path [:install-source]) remote-file-arguments
   (optional-path [:install-dir]) remote-file-arguments])</pre></td></tr><tr><td class="docs"><p>Install based on a settings map.  The :install-strategy key determines
  the install strategy used.  Each strategy has it's own set of keywords
  used to configure the strategy.</p>

<h2>Install helpers</h2>
</td><td class="codes"><pre class="brush: clojure">(defmulti-plan install-from
  (fn [;; {:keys [install-strategy] :as settings}
       settings]
    (when-not (:install-strategy settings)
      (throw (ex-info
              (str &quot;No :install-strategy found in settings: &quot; settings)
              {:settings settings})))
    (:install-strategy settings)))</pre></td></tr><tr><td class="docs"><p>Would like this but need to preserve backward compatibility,
so make it a multimethod</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defn install
  "Install facility using the settings in the given instance-id."
  [facility instance-id]
  {:pre [(keyword? facility)]}
  (let [settings (get-settings facility {:instance-id instance-id})]
    (when-not settings
      (throw (ex-info
              (str "No settings found for facility " facility)
              {:facility facility
               :instance-id instance-id})))
    (when-not (:install-strategy settings)
      (throw (ex-info
              (str "No :install-strategy found in settings for facility "
                   facility)
              {:facility facility
               :instance-id instance-id})))
    (install-from settings)))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Install facility using the settings in the given instance-id.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti-plan install
  (fn [facility instance-id]
    ;; {:pre [(keyword? facility)]}
    (let [settings (get-settings facility {:instance-id instance-id})]
      (when-not settings
        (throw (ex-info
                (str &quot;No settings found for facility &quot; facility)
                {:facility facility
                 :instance-id instance-id})))
      (when-not (:install-strategy settings)
        (throw (ex-info
                (str &quot;No :install-strategy found in settings for facility &quot;
                     facility)
                {:facility facility
                 :instance-id instance-id})))
      (:install-strategy settings))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install :default
  [facility instance-id]
  {:pre [(keyword? facility)]}
  (let [settings (get-settings facility {:instance-id instance-id})]
    (when-not settings
      (throw (ex-info
              (str &quot;No settings found for facility &quot; facility)
              {:facility facility
               :instance-id instance-id})))
    (when-not (:install-strategy settings)
      (throw (ex-info
              (str &quot;No :install-strategy found in settings for facility &quot;
                   facility)
              {:facility facility
               :instance-id instance-id})))
    (clojure.tools.logging/errorf &quot;install %s&quot; settings)
    (install-from settings)))</pre></td></tr><tr><td class="docs"><p>install based on the setting's :packages key</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install-from :packages
  [{:keys [packages package-options preseeds] :as settings}]
  (check-keys
   settings [:packages]
   (map-schema :strict [[:packages] (sequence-of String)])
   &quot;packages install-strategy settings values&quot;)
  (doseq [p preseeds]
    (debconf-set-selections p))
  (doseq [p packages]
    (apply-map package p package-options)))</pre></td></tr><tr><td class="docs"><p>Install based on the setting's :package-source and :packages keys.
This will cause a package update if the package source definition
changes.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install-from :package-source
  [{:keys [package-source packages package-options preseeds repository]
         :as settings}]
  (debugf &quot;package source %s %s&quot; package-source repository)
  (check-keys
   settings [:package-source :packages]
   (map-schema :strict
               [(optional-path [:package-source]) (map-schema
                                                   :loose [[:name] String])
                (optional-path [:repository]) (map-schema
                                               :loose [[:repository] Keyword])
                [:packages] (sequence-of String)])
   &quot;package-source install-strategy settings values&quot;)
  (if repository
    (actions/repository repository)
    (apply-map actions/package-source (:name package-source) package-source))
  (let [modified? (target-flag? package-source-changed-flag)]
    (with-action-options {:always-before #{package}}
      (plan-when modified?
        (package-manager :update)))
    (tracef &quot;packages %s options %s&quot; (vec packages) package-options)
    (doseq [p preseeds]
      (debconf-set-selections p))
    (doseq [p packages]
      (apply-map package p package-options))))</pre></td></tr><tr><td class="docs"><p>install based on a rpm</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install-from :rpm
  [{:keys [rpm] :as settings}]
  (check-keys
   settings [:rpm]
   (map-schema
    :strict
    [[:rpm] (map-schema :strict remote-file-arguments [[:name] String])])
   &quot;packages install-strategy settings values&quot;)
  (with-action-options {:always-before `package/package}
    (apply-map add-rpm (:name rpm) (dissoc rpm :name))))</pre></td></tr><tr><td class="docs"><p>install based on a rpm that installs a package repository source</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install-from :rpm-repo
  [{:keys [rpm packages package-options] :as settings}]
  (check-keys
   settings [:rpm :packages]
   (map-schema
    :strict
    [[:rpm] (map-schema :strict remote-file-arguments [[:name] String])
     [:packages] (sequence-of String)])
   &quot;packages install-strategy settings values&quot;)
  (with-action-options {:always-before `package/package}
    (apply-map add-rpm (:name rpm) (dissoc rpm :name)))
  (doseq [p packages] (apply-map package p package-options)))</pre></td></tr><tr><td class="docs"><p>Upload a deb archive for. Options for the :debs key are as for
remote-directory (e.g. a :local-file key with a path to a local tar
file). Pallet uploads the deb files, creates a repository from them, then
installs from the repository.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install-from :deb
  [{:keys [debs package-source packages]}]
  (let [path (or (-&gt; package-source :apt :path)
                 (-&gt; package-source :aptitude :path))]
    (with-action-options
      {:action-id ::deb-install
       :always-before #{::update-package-source ::install-package-source}}
      (apply-map
       remote-directory path
       (merge
        {:mode &quot;755&quot;
         :strip-components 0}
        (dissoc debs :name)))
      (repository-packages)
      (rebuild-repository path))
    (apply-map actions/package-source (:name package-source) package-source)
    (doseq [p packages] (package p))))</pre></td></tr><tr><td class="docs"><p>Install based on an archive</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod-plan install-from :archive
  [{:keys [install-dir install-source] :as settings}]
  (check-keys
   settings [:install-dir :install-source]
   (map-schema :strict
               [[:install-dir] String
                [:install-source] remote-directory-arguments])
   &quot;archive install-strategy settings values&quot;)
  (apply-map remote-directory install-dir install-source))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.debug" name="pallet.debug"><h1 class="project-name">pallet.debug</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Helpers for debugging.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.debug
  (:require
   [clojure.tools.logging :as logging]
   [pallet.core.session :refer [session]]))</pre></td></tr><tr><td class="docs"><p>A crate function that will log the session map at the debug level, using
   the supplied format string.</p>

<pre><code>   (log-session session "The session is %s")
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn log-session
  ([] (log-session &quot;%s&quot;))
  ([format-string]
     (logging/debug (format format-string (pr-str (session))))))</pre></td></tr><tr><td class="docs"><p>A crate function that will print the session map to <em>out</em>, using the supplied
   format string.</p>

<pre><code>   (print-session "The session is %s")
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn print-session
  ([] (print-session &quot;%s&quot;))
  ([format-string]
     (println (format format-string (pr-str (session))))))</pre></td></tr><tr><td class="docs"><p>Assert a condition</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro assertf
  [expr format-string &amp; args]
  `(assert ~expr (format ~format-string ~@args)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.echo.execute" name="pallet.echo.execute"><h1 class="project-name">pallet.echo.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Action execution that just echos the action script</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.echo.execute
  (:require
   [clojure.tools.logging :as logging]))</pre></td></tr><tr><td class="docs"><p>Echo a bash action. Do not execute.</p>
</td><td class="codes"><pre class="brush: clojure">(defn echo-bash
  [session script]
  (logging/tracef &quot;echo-bash %s&quot; script)
  [script session])</pre></td></tr><tr><td class="docs"><p>Echo a clojure action (which returns nil)</p>
</td><td class="codes"><pre class="brush: clojure">(defn echo-clojure
  [session f]
  (logging/trace &quot;echo-clojure&quot;)
  (f session))</pre></td></tr><tr><td class="docs"><p>echo transfer of files</p>
</td><td class="codes"><pre class="brush: clojure">(defn echo-transfer
  [session value]
  (logging/trace &quot;Local transfer&quot;)
  (let [[from to] value]
    (logging/debugf &quot;Copying %s to %s&quot; from to))
  [value session])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.enlive" name="pallet.enlive"><h1 class="project-name">pallet.enlive</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Wrappers for enlive to enable template specialisation and use xml.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.enlive
  (:require
   [clojure.tools.logging :refer [error]]
   [net.cgrand.enlive-html :as enlive]
   [pallet.template :refer [find-template]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn elt
 ([tag] (elt tag nil))
 ([tag attrs &amp; content]
   {:tag tag
    :attrs attrs
    :content content}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro transform-nodes
  [[nodes] &amp; forms]
  `(enlive/flatmap (enlive/transformation ~@forms) ~nodes))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro deffragment
  [name args &amp; forms]
  `(defn ~name ~args
     (fn [nodes#] (enlive/at nodes# ~@forms))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def memo-xml-resource
     (memoize
      (fn [source session]
        (if-let [source (find-template source session)]
          (enlive/xml-resource source)
          (error
           (format
            &quot;No template found for %s %s&quot;
            source (-&gt; session :server :tag)))))))</pre></td></tr><tr><td class="docs"><p>A snippet returns a collection of nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defsnippet
  [name source session args &amp; forms]
  `(defn ~name ~args
    (if-let [nodes# (memo-xml-resource ~source ~session)]
      (enlive/at nodes# ~@forms))))</pre></td></tr><tr><td class="docs"><p>A template returns a seq of string:
   Overridden from enlive to defer evaluation of the source until runtime, and
   to enable specialisation on node-type</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro xml-template
  [source session args &amp; forms]
  `(comp enlive/emit*
         (fn ~args
           (if-let [nodes# (memo-xml-resource ~source ~session)]
             (enlive/flatmap (enlive/transformation ~@forms) nodes#)))))</pre></td></tr><tr><td class="docs"><p>Emit a template, adding an XML Declaration.</p>
</td><td class="codes"><pre class="brush: clojure">(defn xml-emit
  [f &amp; args]
  (str &quot;&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&quot;
       (apply str (apply f args))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro transform-if [expr transform]
  `(if ~expr ~transform identity))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro transform-if-let [binding transform]
  `(if-let ~binding ~transform identity))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.environment" name="pallet.environment"><h1 class="project-name">pallet.environment</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>The environments provide mechanisms for customising Pallet and
   Pallet crates according to externally determined criteria.</p>

<p>   An environment can be specified at the global, service, invocation and tag
   scopes.</p>

<p>   To provide a global default, specify an <code>:environment</code> key at the top level
   of <code>defpallet</code> in <code>~/.pallet/config.clj</code>.</p>

<p>   To provide a service specific default, specify an <code>:environment</code> key at the
   service level of <code>defpallet</code> in <code>~/.pallet/config.clj</code>.</p>

<p>   To provide a project specific default, define <code>pallet.config/environment</code>.</p>

<p>   To provide a specific environment when invoking <code>lift</code> or <code>converge</code>, pass an
   environment map using the <code>:environment</code> key.</p>

<p>   The merging of values between scopes is key specific, and is determined by
   <code>merge-key-algorithm</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.environment
  (:require
   [clojure.core.incubator :refer [-?&gt;]]
   [clojure.walk :as walk]
   [pallet.core.file-upload :as file-upload]
   [pallet.ssh.node-state :as node-state]
   [pallet.core.primitives :refer [phases-with-meta]]
   [pallet.core.session :refer [session]]
   [pallet.core.user :refer [make-user]]
   [pallet.environment-impl :refer [get-for]]
   [pallet.local.execute :as local]
   [pallet.map-merge :as map-merge]
   [pallet.map-merge :refer [merge-key]]
   [pallet.utils :as utils :refer [maybe-update-in total-order-merge]]))</pre></td></tr><tr><td class="docs"><p>A protocol for accessing an environment.</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol Environment
  (environment [_] &quot;Returns an environment map&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pipeline
  [a b]
  (with-meta
    (fn merged-phases [&amp; args] (apply a args) (apply b args))
    (merge (meta a) (meta b))))         ; TODO merge keys properly</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod merge-key :merge-phases
  [_ _ val-in-result val-in-latter]
  (merge-with pipeline val-in-result val-in-latter))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod merge-key :total-ordering
  [_ _ val-in-result val-in-latter]
  (total-order-merge val-in-result val-in-latter))</pre></td></tr><tr><td class="docs"><p>Map associating keys to merge algorithms. Specifies how environments are merged.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  merge-key-algorithm
  {:phases :merge-phases
   :user :merge
   :image :merge
   :compute :replace
   :blobstore :replace
   :count :merge
   :algorithms :merge
   :executor :replace
   :middleware :replace
   :groups :merge-environments
   :roles :union
   :group-names :union
   :tags :merge-environments
   :install-plugins :concat
   ;; :executors :concat
   })</pre></td></tr><tr><td class="docs"><p>node-specific environment keys</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  node-keys [:image :phases])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def standard-pallet-keys (keys merge-key-algorithm))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def user-keys-to-shell-expand [:public-key-path :private-key-path])</pre></td></tr><tr><td class="docs"><p>Returns a map that consists of the rest of the maps <code>conj</code>-ed onto
  the first.  If a key occurs in more than one map, the mapping(s)
  from the latter (left-to-right) will be combined with the mapping in
  the result by calling <code>(merge-key key val-in-result val-in-latter)</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-environments
  [&amp; maps]
  (apply map-merge/merge-keys merge-key-algorithm maps))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod map-merge/merge-key :merge-environments
  [key val-in-result val-in-latter]
  (merge-environments val-in-result val-in-latter))</pre></td></tr><tr><td class="docs"><p>Evaluate a phase definition.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- eval-phase
  [phase]
  (if (or (list? phase) (instance? clojure.lang.Cons phase))
    (eval phase)
    phase))</pre></td></tr><tr><td class="docs"><p>Evaluate a phase map.  This will attempt to require any namespaces mentioned
   and will then read each phase definition.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- eval-phases
  [phases]
  (walk/postwalk
   #(do
      (when (symbol? %)
        (when-let [n (namespace %)]
          (utils/find-var-with-require %)))
      %)
   phases)
  (zipmap (keys phases) (map eval-phase (vals phases))))</pre></td></tr><tr><td class="docs"><p>Evaluate an algorithm map.  This will attempt to require any namespaces
   mentioned and will then lookup each symbol to retrieve the specified
   var.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- eval-algorithms
  [algorithms]
  (walk/postwalk
   #(or
     (when (and (symbol? %) (namespace %))
       (utils/find-var-with-require %))
      %)
   algorithms))</pre></td></tr><tr><td class="docs"><p>Evaluate an action-option map.  This will construct action options
  from keywords, if present.
  e.g :file-uploader [:sftp {}]</p>
</td><td class="codes"><pre class="brush: clojure">(defn- eval-action-options
  [{:keys [file-backup file-checksum file-uploader] :as options}]
  (let [options (if (vector? file-uploader)
                  (assoc options
                    :file-uploader (apply file-upload/file-uploader
                                          file-uploader))
                  options)
        options (if (vector? file-checksum)
                  (assoc options
                    :file-checksum (apply node-state/file-checksum
                                          file-checksum))
                  options)
        options (if (vector? file-backup)
                  (assoc options
                    :file-backup (apply node-state/file-backup
                                          file-backup))
                  options)]
    options))</pre></td></tr><tr><td class="docs"><p>Shell-expand the values matching the specified keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn shell-expand-keys
  [user-map keys]
  (reduce
   (fn [m kwd]
     (if (kwd m)
       (update-in m [kwd] local/local-script-expand)
       m))
   user-map keys))</pre></td></tr><tr><td class="docs"><p>Evaluate an environment literal.  This is used to replace certain keys with
   objects constructed from the map of values provided.  The keys that are
   evaluated are:
   - <code>:user</code>
   - <code>:phases</code>
   - <code>:algorithms</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn eval-environment
  [env-map]
  (let [env-map (if-let [user (shell-expand-keys
                               (:user env-map) user-keys-to-shell-expand)]
                  (if-let [username (:username user)]
                    (assoc
                        env-map :user
                        (make-user username user))
                    env-map)
                  env-map)
        env-map (if-let [phases (:phases env-map)]
                  (if (every? fn? (vals phases))
                    env-map
                    (assoc env-map :phases (eval-phases phases)))
                  env-map)
        env-map (if-let [algorithms (:algorithms env-map)]
                  (if (every? fn? (vals algorithms))
                    env-map
                    (assoc env-map :algorithms (eval-algorithms algorithms)))
                  env-map)
        env-map (if-let [action-options (:action-options env-map)]
                  (assoc env-map :algorithms (eval-action-options action-options))
                  env-map)]
    env-map))</pre></td></tr><tr><td class="docs"><p>Environment accessor.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-environment
  ([keys]
     (get-for (session) keys))
  ([keys default]
     (get-for (session) keys default)))</pre></td></tr><tr><td class="docs"><p>Add the environment to a group.</p>
</td><td class="codes"><pre class="brush: clojure">(defn group-with-environment
  [environment group]
  (merge-environments
   (maybe-update-in (select-keys environment node-keys)
                    [:phases] phases-with-meta {})
   group
   (maybe-update-in (-?&gt; environment :groups group)
                    [:phases] phases-with-meta {})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.environment-impl" name="pallet.environment-impl"><h1 class="project-name">pallet.environment-impl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation namespace for the pallet environment.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.environment-impl)</pre></td></tr><tr><td class="docs"><p>Retrieve the environment value at the path specified by keys.
   When no default value is specified, then raise an <code>:environment-not-found</code> if
   no environment value is set.</p>

<pre><code>   (get-for {:p {:a {:b 1} {:d 2}}} [:p :a :d])
   ;=&gt; 2
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn get-for
  ([session keys]
     {:pre [(sequential? keys)]}
     (let [result (get-in (:environment session) keys ::not-set)]
       (when (= ::not-set result)
         (throw
          (ex-info
           (format
            &quot;Could not find keys %s in session :environment&quot;
            (if (sequential? keys) (vec keys) keys))
           {:type :environment-not-found
            :key-not-set keys
            :environment (:environment session)})))
       result))
  ([session keys default]
     (get-in (:environment session) keys default)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.event" name="pallet.event"><h1 class="project-name">pallet.event</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet events. Provides ability to hook into pallet event stream.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.event
  (:require
   [clojure.string :as string]
   [clojure.tools.logging :as logging]))</pre></td></tr><tr><td class="docs"><p>should be part of session</p>
</td><td class="codes"><pre class="brush: clojure">(defonce ^{:private true} publishers (atom {}))</pre></td></tr><tr><td class="docs"><p>Add a publisher from the list notified by each call to publish.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-publisher
  [kw publisher]
  (swap! publishers assoc kw publisher))</pre></td></tr><tr><td class="docs"><p>Remove a publisher from the list notified by each call to publish.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-publisher
  [kw]
  (swap! publishers dissoc kw))</pre></td></tr><tr><td class="docs"><p>Remove all publisher from the list notified by each call to publish.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-publishers
  []
  (reset! publishers {}))</pre></td></tr><tr><td class="docs"><p>Publish a pallet event.</p>
</td><td class="codes"><pre class="brush: clojure">(defn publish
  [m]
  (doseq [[_ publisher] @publishers]
    (publisher m)))</pre></td></tr><tr><td class="docs"><p>An event publisher that logs to locally configured logger.</p>
</td><td class="codes"><pre class="brush: clojure">(defn log-publisher
  [m]
  (logging/log
   (or (:ns m) *ns*)
   (:log-level m :debug)
   (:cause m)
   (str
    (:msg m)
    (when-let [kw-vals (seq (dissoc m :kw :msg :log-level :ns :ns :line))]
      (str
       &quot; - &quot;
       (string/join
        &quot; &quot; (map #(format &quot;%s: %s&quot; (first %) (second %)) kw-vals))))
    (when-let [ns (:ns m)] (format &quot; [%s:%s]&quot; ns (:line m))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-publisher :log #'log-publisher)</pre></td></tr><tr><td class="docs"><p>Session event publisher</p>
</td><td class="codes"><pre class="brush: clojure">(defn session-event
  [event]
  (fn session-event-fn [session]
    [(publish event) session]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.execute" name="pallet.execute"><h1 class="project-name">pallet.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Execute actions.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.execute
  (:require
   [clojure.set :refer [union]]
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.core.plan-state :refer [get-settings update-settings]]
   [pallet.core.session :refer [target-id]]))</pre></td></tr><tr><td class="docs"><p>Convert eol into platform specific value</p>
</td><td class="codes"><pre class="brush: clojure">(defn normalise-eol
  [#^String s]
  (string/replace s #&quot;[\r\n]+&quot; (str \newline)))</pre></td></tr><tr><td class="docs"><p>Elides the user's password or sudo-password from the given script output.</p>
</td><td class="codes"><pre class="brush: clojure">(defn strip-sudo-password
  [#^String s user]
  (string/replace
   s (format &quot;\&quot;%s\&quot;&quot; (or (:password user) (:sudo-password user))) &quot;XXXXXXX&quot;))</pre></td></tr><tr><td class="docs"><p>Clean passwords from logs</p>
</td><td class="codes"><pre class="brush: clojure">(defn clean-logs
  [user]
  (comp #(strip-sudo-password % user) normalise-eol))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn status-line? [^String line]
  (.startsWith line &quot;#&gt; &quot;))</pre></td></tr><tr><td class="docs"><p>Return script status lines from the given sequence of lines.</p>
</td><td class="codes"><pre class="brush: clojure">(defn status-lines
  [lines]
  (filter status-line? lines))</pre></td></tr><tr><td class="docs"><p>Return a function to log (multi-line) script output, removing passwords.</p>
</td><td class="codes"><pre class="brush: clojure">(defn log-script-output
  [server user]
  (comp
   #(doseq [^String l %]
      (cond
       (not (status-line? l)) (logging/debugf &quot;%s   &lt;== %s&quot; server l)
       (.endsWith l &quot;FAIL&quot;) (logging/errorf &quot;%s %s&quot; server l)
       :else (logging/infof &quot;%s %s&quot; server l)))
   string/split-lines
   (clean-logs user)))</pre></td></tr><tr><td class="docs"><p>Create an error map for a script execution</p>
</td><td class="codes"><pre class="brush: clojure">(defn script-error-map
  [server msg result]
  (merge
   (select-keys result [:server :err :out :exit])
   {:message (format
              &quot;%s %s%s%s&quot;
              server
              msg
              (let [out (string/join
                         &quot;, &quot;
                         (status-lines (string/split-lines (:out result))))]
                (if (string/blank? out) &quot;&quot; (str &quot; :out &quot; out)))
              (if-let [err (:err result)] (str &quot; :err &quot; err) &quot;&quot;))
    :type :pallet-script-excution-error
    :server server}))</pre></td></tr><tr><td class="docs"><p>Verify the return code of a script execution, and add an error map if
   there is a non-zero result :exit</p>
</td><td class="codes"><pre class="brush: clojure">(defn result-with-error-map
  [server msg {:keys [exit] :as result}]
  (if (zero? exit)
    result
    (assoc result :error (script-error-map server msg result))))</pre></td></tr><tr><td class="docs"><h2>Flag Parsing</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>In order to capture node state, actions emit output that matches a specific
pattern. The executors are responsible for interpreting this text, and
set the flags in the resulting node-value, and on the session under the
target :flags key.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Regex used to match SETFLAG text in action output.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :private true}
  setflag-regex #&quot;(?:SETFLAG: )([^:]+)(?: :SETFLAG)&quot;)</pre></td></tr><tr><td class="docs"><p>Regex used to match SETFLAG text in action output.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :private true}
  setvalue-regex #&quot;(?:SETVALUE: )([^ ]+) ([^:]+)(?: :SETVALUE)&quot;)</pre></td></tr><tr><td class="docs"><p>Set flags for target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-target-flags
  [session flags]
  (if (seq flags)
    (update-in
     session [:plan-state]
     update-settings (target-id session) :flags union [flags] {})
    session))</pre></td></tr><tr><td class="docs"><p>Set flag values for target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-target-flag-values
  [session flag-values]
  (if (seq flag-values)
    (update-in
     session [:plan-state]
     update-settings (target-id session) :flag-values merge flag-values {})
    session))</pre></td></tr><tr><td class="docs"><p>Set flags for target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-target-flags
  [session flags]
  (if (seq flags)
    (update-in
     session [:plan-state]
     update-settings (target-id session) :flags union [flags] {})
    session))</pre></td></tr><tr><td class="docs"><p>Clear flag for target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn clear-target-flag
  [session flag]
  (update-in
   session [:plan-state]
   update-settings (target-id session) :flags disj [flag] {}))</pre></td></tr><tr><td class="docs"><p>Predicate to test if the specified flag is set for target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-flag?
  ([session flag]
     (when-let [flags (get-settings
                       (:plan-state session) (target-id session) :flags
                       {:default #{}})]
       (logging/tracef &quot;target-flag? flag %s flags %s&quot; flag flags)
       (flags flag)))
  ([flag]
     (fn [session]
       [(target-flag? session flag) session])))</pre></td></tr><tr><td class="docs"><p>Get flag value for target.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-flag-value
  [session flag]
  (let [r (get-settings
           (:plan-state session) (target-id session) :flag-values {})]
    (logging/debugf &quot;target-flag-value %s %s&quot; (pr-str flag) (pr-str r))
    (get r flag)))</pre></td></tr><tr><td class="docs"><p>Parse flags from the output stream of an action.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-flags
  [output]
  (when output
    (let [flags-set (-&gt;&gt;
                     (re-seq setflag-regex output)
                     (map (comp keyword second))
                     set)]
      (logging/tracef &quot;flags-set %s&quot; flags-set)
      flags-set)))</pre></td></tr><tr><td class="docs"><p>Parse flags with values from the output stream of an action.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-flag-values
  [output]
  (when output
    (let [flag-values (into {} (map
                                #(vector (keyword (second %)) (nth % 2))
                                (re-seq setvalue-regex output)))]
      (logging/tracef &quot;flag-values %s&quot; flag-values)
      flag-values)))</pre></td></tr><tr><td class="docs"><p>Sets the :flags key in a shell result map for any flags set by an action.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-shell-result
  [session {:keys [out] :as result}]
  (let [flags (parse-flags out)
        values (parse-flag-values out)]
    [(assoc result :flags flags :flag-values values)
     (-&gt;
      session
      (set-target-flags flags)
      (set-target-flag-values values))]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.executor.protocols" name="pallet.executor.protocols"><h1 class="project-name">pallet.executor.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Protocols for upload and execution of script</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.executor.protocols)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.executors" name="pallet.executors"><h1 class="project-name">pallet.executors</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Action executors for pallet.</p>

<p>   An action has a :action-type. Known types include :script
   and :fn/clojure.</p>

<p>   An action has a :location, :origin for execution on the node running
   pallet, and :target for the target node.</p>

<p>   The action-type determines how the action should be handled:</p>

<p>   :script - action produces script for execution on remote machine
   :fn/clojure  - action is a function for local execution
   :transfer/to-local - action is a function specifying remote source
                        and local destination.
   :transfer/from-local - action is a function specifying local source
                          and remote destination.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.executors
  (:require
   [clojure.tools.logging :as logging]
   [pallet.action :refer [implementation with-action-options]]
   [pallet.action-plan :refer [execute-if map-action-f session-exec-action]]
   [pallet.echo.execute :as echo]
   [pallet.local.execute :as local]
   [pallet.node :refer [primary-ip]]
   [pallet.ssh.execute :as ssh]
   [pallet.stevedore :refer [with-source-line-comments]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require 'pallet.actions.direct)</pre></td></tr><tr><td class="docs"><p>Execute the direct action implementation, which returns script or other
  argument data, and metadata.</p>
</td><td class="codes"><pre class="brush: clojure">(defn direct-script
  [session {:keys [args script-dir] :as action}]
  (with-action-options action           ; allow actions to interrogate options
    (let [{:keys [metadata f]} (implementation action :direct)
          {:keys [action-type location]} metadata
          [script session] (apply
                            f (assoc session :script-dir script-dir) args)]
      (logging/tracef &quot;direct-script %s %s&quot; f (vec args))
      (logging/tracef &quot;direct-script %s&quot; script)
      [script action-type location session])))</pre></td></tr><tr><td class="docs"><p>The standard direct executor for pallet. Target actions for localhost
   are executed via shell, rather than via ssh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-executor
  [session action]
  (logging/debugf &quot;default-executor&quot;)
  (let [[script action-type location session] (direct-script session action)
        localhost? (fn [session]
                     (let [ip (-&gt; session :server :node primary-ip)]
                       (#{&quot;127.0.0.1&quot;} ip)))]
    (logging/tracef &quot;default-executor %s %s&quot; action-type location)
    (logging/debugf &quot;default-executor script %s&quot; script)
    (case [action-type location]
      [:script :origin] (local/script-on-origin
                         session action action-type script)
      [:script :target] (if (localhost? session)
                          (local/script-on-origin
                           session action action-type script)
                          (ssh/ssh-script-on-target
                           session action action-type script))
      [:fn/clojure :origin] (local/clojure-on-origin session action script)
      [:flow/if :origin] (execute-if session action script)
      [:transfer/from-local :origin] [((last script)) session]
      [:transfer/to-local :origin] (ssh/ssh-to-local session script)
      (throw
       (ex-info
        &quot;No suitable executor found&quot;
        {:type :pallet/no-executor-for-action
         :action action
         :executor 'DefaultExector})))))</pre></td></tr><tr><td class="docs"><p>Direct executor where target actions are always over ssh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn force-target-via-ssh-executor
  [session action]
  (let [[script action-type location session] (direct-script session action)]
    (logging/tracef &quot;force-target-via-ssh-executor %s %s&quot; action-type location)
    (logging/tracef &quot;force-target-via-ssh-executor script %s&quot; script)
    (case [action-type location]
      [:script :origin] (local/script-on-origin
                         session action action-type script)
      [:script :target] (ssh/ssh-script-on-target
                         session action action-type script)
      [:fn/clojure :origin] (local/clojure-on-origin session action script)
      [:flow/if :origin] (execute-if session action script)
      [:transfer/from-local :origin] (ssh/ssh-from-local session script)
      [:transfer/to-local :origin] (ssh/ssh-to-local session script)
      (throw
       (ex-info
        &quot;No suitable executor found&quot;
        {:type :pallet/no-executor-for-action
         :action action
         :executor 'DefaultExector})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bootstrap-executor
  [session action]
  (let [[script action-type location session] (direct-script session action)]
    (case [action-type location]
      [:script :target] (echo/echo-bash session script)
      (throw
       (ex-info
        (str &quot;No suitable bootstrap executor found &quot;
             &quot;(local actions are not allowed)&quot;)
        {:type :pallet/no-executor-for-action
         :action action
         :executor 'BootstrapExector})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn echo-executor
  [session action]
  (let [[script action-type location session] (direct-script session action)]
    (logging/tracef
     &quot;echo-executor %s %s %s&quot; (:name action) action-type location)
    (case [action-type location]
      [:script :target] (echo/echo-bash session script)
      [:script :origin] (echo/echo-bash session script)
      [:fn/clojure :origin] (echo/echo-clojure session script)
      [:flow/if :origin] (execute-if session action script)
      [:transfer/from-local :origin] (echo/echo-transfer session script)
      [:transfer/to-local :origin] (echo/echo-transfer session script)
      (throw
       (ex-info
        (format &quot;No suitable echo executor found for %s (%s, %s)&quot;
                (:name action) action-type location)
        {:type :pallet/no-executor-for-action
         :action action
         :executor 'EchoExecutor})))))</pre></td></tr><tr><td class="docs"><p>Return an action's data.</p>
</td><td class="codes"><pre class="brush: clojure">(defn action-plan-data
  [session {:keys [action args blocks] :as action-m}]
  (let [action-symbol (:action-symbol action)
        [script action-type location session] (direct-script session action-m)
        exec-action (session-exec-action session)
        self-fn (fn [b session]
                  (first (map-action-f exec-action b session)))
        blocks (when (= 'pallet.actions-impl/if-action action-symbol)
                 [(self-fn (first blocks) session)
                  (self-fn (second blocks) session)])]
    [(merge
      (-&gt; action-m
          (dissoc :node-value-path)
          (update-in [:action] dissoc :impls))
      {:form `(~action-symbol ~@args
               ~@(when blocks
                   (map #(map :form %) blocks)))
       :script (if (and (sequential? script) (map? (first script)))
                 (update-in script [0] dissoc :summary)
                 script)
       :summary (when (and (sequential? script) (map? (first script)))
                  (:summary (first script)))
       :action-type action-type
       :location location}
      (when blocks
        {:blocks blocks}))
     session]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.feature" name="pallet.feature"><h1 class="project-name">pallet.feature</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet feature recognition.</p>

<p>   A feature is implemented as a function within the pallet.feature namespace</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.feature)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn has-feature?*
  [feature]
  (when-let [f (ns-resolve 'pallet.feature feature)]
    (f)))</pre></td></tr><tr><td class="docs"><p>Predicate to test for feature availability</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro has-feature?
  [feature]
  (has-feature?* feature))</pre></td></tr><tr><td class="docs"><p>Predicate to test for feature availability</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro when-feature
  [feature &amp; body]
  (when (has-feature?* feature)
    `(do ~@body)))</pre></td></tr><tr><td class="docs"><p>Predicate to test for feature availability</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro when-not-feature
  [feature &amp; body]
  (when-not (has-feature?* feature)
    `(do ~@body)))</pre></td></tr><tr><td class="docs"><p>Predicate to test for feature availability</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro if-feature
  {:indent 1}
  [feature true-expr false-expr]
  (if (has-feature?* feature)
    true-expr
    false-expr))</pre></td></tr><tr><td class="docs"><p>Feature for multi-language script execution.</p>
</td><td class="codes"><pre class="brush: clojure">(defn multilang-script
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for creating nodes without bootstrapping them.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-nodes-without-bootstrap
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for tagging nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn taggable-nodes
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for pallet.core.user.</p>
</td><td class="codes"><pre class="brush: clojure">(defn core-user
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for pallet.node/NodePackager.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-packager
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for pallet.node/NodeImage.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-image
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for pallet.node/NodeHardware.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-hardware
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for pallet.node/NodeProxy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-proxy
  [] true)</pre></td></tr><tr><td class="docs"><p>Feature for pallet.compute/ComputeServiceProperties.</p>
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-properties
  [] true)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.futures" name="pallet.futures"><h1 class="project-name">pallet.futures</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Keep track of operations started by pallet</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.futures
  (:require
   [clojure.stacktrace :as stacktrace]
   [clojure.tools.logging :as logging])
  (:import
   (java.util.concurrent CancellationException ExecutionException Future)))</pre></td></tr><tr><td class="docs"><p>Keep track of pending operations, so they can be cancelled.</p>
</td><td class="codes"><pre class="brush: clojure">(def
  ^{:doc 
    :private true}
  pending-futures (atom (list)))</pre></td></tr><tr><td class="docs"><p>Remove all completed futures</p>
</td><td class="codes"><pre class="brush: clojure">(defn- remove-done
  [futures]
  (remove #(.isDone ^Future %1) futures))</pre></td></tr><tr><td class="docs"><p>Add a sequence of futures to the list of pending operations. Returns
   its argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add
  [futures]
  (swap! pending-futures #(concat (remove-done %1) %2) futures)
  futures)</pre></td></tr><tr><td class="docs"><p>Remove completed futures.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-completed
  []
  (swap! pending-futures remove-done))</pre></td></tr><tr><td class="docs"><p>Cancel all pending parallel operations</p>
</td><td class="codes"><pre class="brush: clojure">(defn cancel-all
  []
  (swap! pending-futures #(do (doseq [^Future f %] (.cancel f true)) '()))
  nil)</pre></td></tr><tr><td class="docs"><p>Deref a future with logging, returning nil if exception thrown.
   <code>operation-label</code> appears in each log message generated.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deref-with-logging
  [f operation-label]
  (try
    @f
    (catch CancellationException e
      (logging/warnf &quot;%s cancelled : %s&quot; operation-label (.getMessage e)))
    (catch InterruptedException e
      (logging/warnf &quot;%s interrupted&quot; operation-label))
    (catch ExecutionException e
      (let [^Exception cause (stacktrace/root-cause e)]
        (logging/errorf
         cause &quot;%s exception: %s&quot; operation-label (.getMessage cause)))
      (logging/debugf (.getCause e) &quot;%s exception&quot; operation-label))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.local.execute" name="pallet.local.execute"><h1 class="project-name">pallet.local.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Local execution of pallet actions</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.local.execute
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.compute.jvm :as jvm]
   [pallet.execute :as execute
    :refer [log-script-output result-with-error-map status-lines]]
   [pallet.script :as script]
   [pallet.script-builder :as script-builder]
   [pallet.stevedore :as stevedore]
   [pallet.transport :as transport]
   [pallet.transport.local]
   [pallet.utils :refer [log-multiline]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def local-connection
  (transport/open (transport/factory :local {}) nil nil nil))</pre></td></tr><tr><td class="docs"><p>Verify the return code of a sh execution</p>
</td><td class="codes"><pre class="brush: clojure">(defn verify-sh-return
  [msg cmd result]
  (if (zero? (:exit result))
    result
    (assoc result
      :error {:message (format
                        &quot;localhost Error executing script %s :out %s :err %s&quot;
                        msg
                        (string/join &quot;, &quot; (status-lines (:out result)))
                        (:err result))
              :type :pallet-script-excution-error
              :script-exit (:exit result)
              :script-out  (:out result)
              :script-err (:err result)
              :server &quot;localhost&quot;})))</pre></td></tr><tr><td class="docs"><p>Build the code with defaults for local execution.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-code
  [session action ^java.io.File tmpfile]
  (script-builder/build-code
   session
   (assoc action :default-script-prefix :no-sudo)
   (.getPath tmpfile)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- local-script-dir [{:keys [script-dir]}]
  (if script-dir
    (if (.startsWith &quot;/&quot; script-dir)
      script-dir
      (str (System/getProperty &quot;user.home&quot;) &quot;/&quot; script-dir))
    (System/getProperty &quot;user.home&quot;)))</pre></td></tr><tr><td class="docs"><p>Execute a script action on the origin</p>
</td><td class="codes"><pre class="brush: clojure">(defn script-on-origin
  [session action action-type [options value]]
  (logging/trace &quot;script-on-origin&quot;)
  (let [action (merge {:script-dir (local-script-dir action)} action)
        script (script-builder/build-script options value action)
        tmpfile (java.io.File/createTempFile &quot;pallet&quot; &quot;script&quot;)]
    (try
      (log-multiline :debug &quot; localhost ==&gt; %s&quot;
                     (str &quot; -----------------------------------------\n&quot;
                          script
                          &quot;\n------------------------------------------&quot;))
      (spit tmpfile script)
      (let [result (transport/exec
                    local-connection
                    {:execv [&quot;/bin/chmod&quot; &quot;+x&quot; (.getPath tmpfile)]}
                    nil)]
        (when-not (zero? (:exit result))
          (logging/warnf
           &quot;script-on-origin: Could not chmod script file: %s&quot;
           (:out result))))
      (logging/debugf &quot;localhost &lt;== ----------------------------------------&quot;)
      (let [cmd (build-code session action tmpfile)
            _ (logging/debugf &quot;localhost %s&quot; cmd)
            result (transport/exec
                    local-connection cmd
                    {:output-f (log-script-output &quot;localhost&quot; nil)})
            [result session] (execute/parse-shell-result session result)
            result (assoc result :script script)]
        (when-let [e (:err result)]
          (when-not (string/blank? e)
            (doseq [^String l (string/split-lines e)
                    :when (not (.startsWith l &quot;#&gt; &quot;))] ; logged elsewhere
              (logging/warnf &quot;localhost %s&quot; l))))
        (logging/debugf
         &quot;localhost &lt;== ----------------------------------------&quot;)
        [(result-with-error-map &quot;localhost&quot; &quot;Error executing script&quot; result)
         session])
      (finally (.delete tmpfile)))))</pre></td></tr><tr><td class="docs"><p>Execute a clojure function on the origin</p>
</td><td class="codes"><pre class="brush: clojure">(defn clojure-on-origin
  [session {:keys [script-dir] :as action} f]
  (logging/debugf &quot;clojure-on-origin %s&quot; f)
  (f (assoc session :script-dir script-dir)))</pre></td></tr><tr><td class="docs"><p>Run a script on the local machine, setting up stevedore to produce the
   correct target specific code</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro local-script-context
  [&amp; body]
  `(script/with-script-context [(jvm/os-family)]
     (stevedore/with-script-language :pallet.stevedore.bash/bash
       ~@body)))</pre></td></tr><tr><td class="docs"><p>Run a script on the local machine, setting up stevedore to produce the
   correct target specific code</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro local-script
  [&amp; body]
  `(local-script-context
    (logging/debugf &quot;local-script %s&quot; (stevedore/script ~@body))
    (transport/exec local-connection {:in (stevedore/script ~@body)} nil)))</pre></td></tr><tr><td class="docs"><p>Run a script on the local machine, setting up stevedore to produce the
   correct target specific code.  The return code is checked.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro local-checked-script
  [msg &amp; body]
  `(local-script-context
    (let [cmd# (stevedore/checked-script ~msg ~@body)]
      (result-with-error-map &quot;localhost&quot; ~msg
        (transport/exec local-connection {:in cmd#} nil)))))</pre></td></tr><tr><td class="docs"><p>Expand a script expression.</p>
</td><td class="codes"><pre class="brush: clojure">(defn local-script-expand
  [expr]
  (string/trim (:out (local-script (println ~expr)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.main" name="pallet.main"><h1 class="project-name">pallet.main</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.main
  (:require
   [clojure.stacktrace :refer [print-cause-trace]]
   [clojure.tools.cli :refer [cli]]
   [clojure.tools.logging :as logging]
   [pallet.task :refer [abort report-error] :as task])
  (:gen-class))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn read-targets
  ([dir]
     (try
      (doseq [^java.io.File file (file-seq dir)]
        (load (.getPath file)))
      (catch java.io.FileNotFoundException _
        (abort &quot;No pallet directory found in the current directory.&quot;))))
  ([] (read-targets &quot;pallet&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def aliases {&quot;--help&quot; &quot;help&quot; &quot;-h&quot; &quot;help&quot; &quot;-?&quot; &quot;help&quot; &quot;-v&quot; &quot;version&quot;
              &quot;--version&quot; &quot;version&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn resolve-task [task]
  (let [task-ns (symbol (str &quot;pallet.task.&quot; task))
        task (symbol task)
        error-fn (with-meta
                   (fn [&amp; _]
                     (abort
                      (format
                       &quot;%s is not a task. Use \&quot;help\&quot; to list all tasks.&quot;
                       task)))
                   {:no-service-required true})]
    (try
      (when-not (find-ns task-ns)
        (require task-ns))
      (or (ns-resolve task-ns task)
          error-fn)
      (catch java.io.FileNotFoundException e
        error-fn))))</pre></td></tr><tr><td class="docs"><p>Check the exception to see if it is the <code>exit-task-exception</code>, and if it is
   not, then report the exception.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- report-unexpected-exception
  [^Throwable e]
  (logging/errorf e &quot;Exception&quot;)
  (binding [*out* *err*]
    (print-cause-trace e)))</pre></td></tr><tr><td class="docs"><p>Bind to false to suppress process termination.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *exit-process?*
   true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn exit [exit-code]
  (if *exit-process?*
    (do
      (shutdown-agents)
      (System/exit exit-code))
    (throw (ex-info &quot;suppressed exit&quot; {:exit-code exit-code}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def pallet-switches
  [[&quot;-P&quot; &quot;--service&quot; &quot;Service key to use (use add-service to create a service&quot;]
   [&quot;-p&quot; &quot;--provider&quot; &quot;Cloud provider name.&quot;]
   [&quot;-i&quot; &quot;--identity&quot; &quot;Cloud user name or key.&quot;]
   [&quot;-c&quot; &quot;--credential&quot; &quot;Cloud password or secret.&quot;]
   [&quot;-B&quot; &quot;--blobstore-provider&quot; &quot;Blobstore provider name.&quot;]
   [&quot;-I&quot; &quot;--blobstore-identity&quot; &quot;Blobstore user name or key.&quot;]
   [&quot;-C&quot; &quot;--blobstore-credential&quot; &quot;Blobstore password or secret.&quot;]
   [&quot;-O&quot; &quot;--project-options&quot; &quot;Project options (usually picked up from project.clj).&quot;]
   [&quot;-D&quot; &quot;--defaults&quot; &quot;Default options (usually picked up from config.clj).&quot;]])</pre></td></tr><tr><td class="docs"><p>Process command line arguments. Returns an option map, a vector of arguments
  and a help string.  Optionally accepts a sequence of switch descriptions.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pallet-args
  ([args switches]
     (apply cli args switches))
  ([args]
     (pallet-args args pallet-switches)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def help
  (str &quot;A command line for pallet.&quot;
       \newline \newline
       (last (pallet-args nil))))</pre></td></tr><tr><td class="docs"><p>We use cli in the tasks to process switches, so we need to allow arbitray
switches to pass to the tasks.  We do this by recursively add switches
that fail, and returning these as extra switches, for propagation to the
task.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^:private pallet-option-names
  (map (comp :name #'clojure.tools.cli/generate-spec) pallet-switches))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn process-arg-attempt [args extra-switches]
  (try
    (let [[options args] (pallet-args
                          args (concat pallet-switches extra-switches))]
      {:options (select-keys options pallet-option-names)
       :extra (apply dissoc options pallet-option-names)
       :args args
       :extra-switches extra-switches})
    (catch Exception e
      (if-let [[_ switch] (re-matches
                           #&quot;'(.*)' is not a valid argument&quot;
                           (.getMessage e))]
        {:add-switch switch
         :extra-switches extra-switches}
        (throw e)))))</pre></td></tr><tr><td class="docs"><p>Process arguments, returning options, arguments and unrecognised options.</p>
</td><td class="codes"><pre class="brush: clojure">(defn process-args
  [all-args]
  (loop [{:keys [options extra args extra-switches add-switch] :as parsed}
         (process-arg-attempt all-args nil)]
    (if add-switch
      (recur (process-arg-attempt all-args (conj extra-switches [add-switch])))
      [options args extra])))</pre></td></tr><tr><td class="docs"><p>Add extra switches back into an argument vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn args-with-extras
  [args extras]
  (letfn [(option-to-args [[switch value]]
            (let [k (if (= 1 (count (name switch)))
                      (str &quot;-&quot; (name switch))
                      (str &quot;--&quot; (name switch)))]
              (if (or (= false value) (= true value) (nil? value))
                [k]
                [k value])))]
    (concat (mapcat option-to-args extras) args)))</pre></td></tr><tr><td class="docs"><p>help</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:doc help} pallet-task
  [args &amp; {:keys [environment]}]
  (let [[{:keys [provider identity credential blobstore-provider
                 blobstore-identity blobstore-credential service
                 project-options defaults] :as options}
         args
         extras]
        (process-args args)]
    (logging/debugf &quot;pallet-task options %s&quot; options)
    (try
      (let [[task-name &amp; args] args
            task-name (or (aliases task-name) task-name )
            project-options (when project-options
                              (read-string project-options))
            defaults (when defaults
                       (read-string defaults))
            task (resolve-task task-name)
            return-value (if (:no-service-required (meta task))
                           (let [_ (require 'pallet.main-invoker)
                                 invoker (find-var
                                          'pallet.main-invoker/invoke-no-service)]
                             (invoker
                              {:project project-options
                               :defaults defaults
                               :environment environment}
                              task
                              task-name
                              (args-with-extras args extras)))
                           (let [_ (require 'pallet.main-invoker)
                                 invoker (find-var
                                          'pallet.main-invoker/invoke)]
                             (invoker
                              {:provider provider
                               :identity identity
                               :credential credential
                               :blobstore-provider blobstore-provider
                               :blobstore-identity blobstore-identity
                               :blobstore-credential blobstore-credential
                               :service service
                               :project project-options
                               :defaults defaults
                               :environment environment}
                              task
                              (args-with-extras args extras))))]
        (flush)
        nil)
      (catch Exception e
        ;; suppress exception traces for errors with :exit-code
        (if-let [exit-code (:exit-code (ex-data e))]
          (do (report-error (.getMessage e))
              (exit exit-code))
          (throw e))))))</pre></td></tr><tr><td class="docs"><p>Command line runner.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main
  ([&amp; args]
     (try
       (pallet-task args)
       (catch Exception e
         (when-let [exit-code (:exit-code (ex-data e))]
           (exit exit-code))
         (report-unexpected-exception e)
         (exit 1)))
     (exit 0))
  ([] (apply -main *command-line-args*)))</pre></td></tr><tr><td class="docs"><p>Allow the task to define pallet services</p>
</td><td class="codes"><pre class="brush: clojure">(def transient-services (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-service [name-kw properties]
  (swap! transient-services assoc-in [:services name-kw] properties)
  (when-not (:default-service @transient-services)
    (swap! transient-services assoc :default-service name-kw)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.main-invoker" name="pallet.main-invoker"><h1 class="project-name">pallet.main-invoker</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Invoke tasks requiring a compute service.  This decouples main from anything
   pallet, jclouds or maven specific, and ensures compiling main doesn't compile
   the world.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.main-invoker
  (:require
   [bultitude.core :refer [classpath-files]]
   [clojure.tools.logging :as logging]
   [pallet.api :refer [version]]
   [pallet.blobstore :as blobstore]
   [pallet.compute :as compute]
   [pallet.configure :as configure]
   [pallet.configure :refer [default-compute-service]]
   [pallet.core.user :refer [*admin-user*]]
   [pallet.environment :as environment]
   [pallet.main :as main]
   [pallet.main :refer [transient-services]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn log-info
  [admin-user]
  (logging/debugf &quot;Pallet version: %s&quot; (version))
  (logging/debugf &quot;OS              %s %s&quot;
                   (System/getProperty &quot;os.name&quot;)
                   (System/getProperty &quot;os.version&quot;))
  (logging/debugf &quot;Arch            %s&quot; (System/getProperty &quot;os.arch&quot;))
  (logging/debugf &quot;Admin user      %s&quot; (:username admin-user))
  (let [^String private-key-path (:private-key-path admin-user)
        ^String public-key-path (:public-key-path admin-user)]
    (logging/debugf
     &quot;private-key-path %s %s&quot;
     private-key-path (if private-key-path (.canRead (java.io.File. private-key-path)) ))
    (logging/debugf
     &quot;public-key-path %s %s&quot;
     public-key-path (if public-key-path (.canRead (java.io.File. public-key-path)) ))
    (doseq [^java.io.File f (classpath-files)]
      (logging/debugf &quot;classpath: %s&quot; (.getPath f)))
    (doseq [[k v] (System/getProperties)]
      (logging/debugf &quot;property: %s %s&quot; k v))))</pre></td></tr><tr><td class="docs"><p>Return the admin user</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-admin-user
  [defaults project profile]
  (or
   (configure/admin-user-from-config (:pallet project))
   (configure/admin-user-from-config defaults)
   (configure/admin-user-from-config-var)
   *admin-user*))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn compute-service-from-config-files
  [defaults project profile]
  (or
   (configure/compute-service-from-config (:pallet project) profile {})
   (configure/compute-service-from-config defaults profile {})))</pre></td></tr><tr><td class="docs"><p>Look for a compute service in the following sequence:
     Check pallet.config.service property
     check maven settings
     check pallet.config/service var.
   This sequence allows you to specify an overridable default in
   pallet.config/service.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-compute-service
  [options defaults project profile]
  (or
   (configure/compute-service-from-map options)
   (when profile
     (compute-service-from-config-files defaults project profile))
   (configure/compute-service-from-property)
   (configure/compute-service-from-config-var)
   (compute-service-from-config-files
    defaults project (default-compute-service defaults))
   (compute-service-from-config-files
    @transient-services project
    (default-compute-service @transient-services))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn blobstore-service-from-config-files
  [defaults project profile]
  (or
   (configure/blobstore-from-config (:pallet project) profile {})
   (configure/blobstore-from-config defaults profile {})))</pre></td></tr><tr><td class="docs"><p>Look for a compute service in the following sequence:
     Check pallet.config.service property
     check maven settings
     check pallet.config/service var.
   This sequence allows you to specify an overridable default in
   pallet.config/service.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-blobstore
  [options defaults project profile]
  (or
   (configure/blobstore-from-map options)
   (when profile
     (blobstore-service-from-config-files defaults project profile))
   (configure/blobstore-service-from-property)
   (configure/blobstore-service-from-config-var)
   (blobstore-service-from-config-files
    defaults project (default-compute-service defaults))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn invoke
  [options task params]
  (let [default-config (or (:defaults options) (configure/pallet-config))
        admin-user (find-admin-user
                    default-config (:project options) (:service options))
        compute (try
                  (find-compute-service
                   options default-config
                   (:project options) (:service options))
                  (catch IllegalArgumentException e
                    (let [msg (.getMessage e)]
                      (if (and
                           msg
                           (re-find #&quot;provider .* not configured&quot; msg))
                        (binding [*out* *err*]
                          (println msg)
                          (throw (ex-info msg {:exit-code 1})))
                        (throw e)))))]
    (if compute
      (try
        (let [blobstore (find-blobstore
                         options default-config
                         (:project options) (:service options))]
          (try
            (log-info admin-user)
            (apply task
                   {:compute compute
                    :blobstore blobstore
                    :project (:project options)
                    :config default-config
                    :user admin-user
                    :environment
                    (pallet.environment/merge-environments
                     (:environment options)
                     (environment/environment compute))}
                   params)
            (finally ;; make sure we don't hang on exceptions
             (when blobstore
               (blobstore/close blobstore)))))
        (finally ;; make sure we don't hang on exceptions
         (compute/close compute)))
      (do
        (println &quot;Error: no credentials supplied\n\n&quot;)
        ((main/resolve-task &quot;help&quot;) {})
        (throw (ex-info &quot;Error: no credentials supplied&quot; {:exit-code 1}))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn invoke-no-service
  [options task task-name params]
  (try
    (apply task options params)
    (catch clojure.lang.ArityException e
      (println (.getMessage e))
      (println &quot;Actual arguments&quot; &quot;_options_&quot; (pr-str params))
      (require 'pallet.task.help)
      (let [help (ns-resolve 'pallet.task.help 'help)]
        (help nil task-name)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.md5crypt" name="pallet.md5crypt"><h1 class="project-name">pallet.md5crypt</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.md5crypt (:import
                     (java.security MessageDigest)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce salt-chars
  &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce itoa64
  &quot;./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce md5-magic &quot;$1$&quot;)
(defonce apache-magic &quot;$apr1$&quot;)</pre></td></tr><tr><td class="docs"><p>Return value encoded as n base64 chars</p>
</td><td class="codes"><pre class="brush: clojure">(defn to64
  [#^Integer value #^Integer n]
  (if (pos? n)
    (str (.charAt itoa64 (int (bit-and value 0x3f)))
         (to64 (bit-shift-right value 6) (dec n)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn salt
  []
  (apply str (take 8 (repeatedly #(rand-nth itoa64)))))</pre></td></tr><tr><td class="docs"><p>Clean up a passed salt value</p>
</td><td class="codes"><pre class="brush: clojure">(defn #^String clean-salt
  [#^String salt #^String magic]
  (let [salt (if (.startsWith salt magic)
                (.substring salt (.length magic))
                salt)
        salt (if (.contains salt &quot;$&quot;)
               (.substring salt 0 (.indexOf salt &quot;$&quot;))
               salt)
        salt (if (&gt; (.length salt) 8)
               (.substring salt 0 8)
               salt)]
    salt))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-array [#^bytes array #^Byte value]
  (dotimes [i (alength array)]
    (aset array i value))
  array)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn #^Integer byte-as-unsigned
  [b]
  (int (bit-and (int (byte b)) 0xff)))</pre></td></tr><tr><td class="docs"><p>LINUX/BSD MD5Crypt function</p>
</td><td class="codes"><pre class="brush: clojure">(defn crypt
  ([password]
     (crypt password (salt) md5-magic))
  ([password salt]
     (crypt password salt md5-magic))
  ([#^String password #^String salt #^String magic]
     (let [salt (clean-salt salt magic)
           ctx (doto (MessageDigest/getInstance &quot;md5&quot;)
                 (.update (.getBytes password))
                 (.update (.getBytes magic))
                 (.update (.getBytes salt)))
           ctx1 (doto (MessageDigest/getInstance &quot;md5&quot;)
                  (.update (.getBytes password))
                  (.update (.getBytes salt))
                  (.update (.getBytes password)))
           final-state (.digest ctx1)]
       (loop [l (.length password)]
         (.update ctx final-state 0 (min l 16))
         (if (&gt; l 16)
           (recur (int (- l 16)))))
       (set-array final-state (byte 0))
       (loop [i (.length password)]
         (when (pos? i)
           (if (pos? (bit-and i 1))
             (.update ctx final-state 0 1)
             (.update ctx (.getBytes password) 0 1))
           (recur (bit-shift-right i 1))))
       (let [#^bytes final-state (loop [final-state (.digest ctx)
                                i 0]
                           (if (&lt; i 1000)
                             (let [ctx1 (MessageDigest/getInstance &quot;md5&quot;)]
                               (if (pos? (bit-and i 1))
                                 (.update ctx1 (.getBytes password))
                                 (.update ctx1 final-state 0 16))
                               (if (pos? (mod i 3))
                                 (.update ctx1 (.getBytes salt)))
                               (if (pos? (mod i 7))
                                 (.update ctx1 (.getBytes password)))
                               (if (pos? (bit-and i 1))
                                 (.update ctx1 final-state 0 16)
                                 (.update ctx1 (.getBytes password)))
                               (recur (.digest ctx1) (inc i)))
                             final-state))]
         (str
          magic
          salt
          &quot;$&quot;
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 0)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 6)) 8))
                 (byte-as-unsigned (aget final-state 12)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 1)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 7)) 8))
                 (byte-as-unsigned (aget final-state 13)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 2)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 8)) 8))
                 (byte-as-unsigned (aget final-state 14)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 3)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 9)) 8))
                 (byte-as-unsigned (aget final-state 15)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 4)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 10)) 8))
                 (byte-as-unsigned (aget final-state 5)))
                4)
          (to64 (byte-as-unsigned (aget final-state 11)) 2))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.node" name="pallet.node"><h1 class="project-name">pallet.node</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>API for nodes in pallet</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.node
  (:require
   [clojure.stacktrace :refer [print-cause-trace]]
   [clojure.tools.logging :refer [trace]]
   [pallet.compute :refer [node-tag node-taggable? node-tags tag-node!]])
  (:refer-clojure :exclude [proxy]))</pre></td></tr><tr><td class="docs"><p>Nodes</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol Node
  (ssh-port [node] &quot;Extract the port from the node's userMetadata&quot;)
  (primary-ip [node] &quot;Returns the first public IP for the node.&quot;)
  (private-ip [node] &quot;Returns the first private IP for the node.&quot;)
  (is-64bit? [node] &quot;64 Bit OS predicate&quot;)
  (group-name [node] &quot;Returns the group name for the node.&quot;)
  (hostname [node] &quot;TODO make this work on ec2&quot;)
  (os-family [node] &quot;Return a node's os-family, or nil if not available.&quot;)
  (os-version [node] &quot;Return a node's os-version, or nil if not available.&quot;)
  (running? [node] &quot;Predicate to test if node is running.&quot;)
  (terminated? [node] &quot;Predicate to test if node is terminated.&quot;)
  (id [node])
  (compute-service [node]
    &quot;Return the service provider the node was provided by.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodePackager
  (packager [node] &quot;The packager to use on the node&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodeImage
  (image-user [node] &quot;Return the user that is defined by the image.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodeHardware
  (hardware [node]
    &quot;Return a map with `:cpus`, `:ram`, and `:disks` information. The ram is
     reported in Mb. The `:cpus` is a sequence of maps, one for each cpu,
     containing the number of `:cores` on each. The `:disks` is a sequence
     of maps, containing a :size key for each drive, in Gb. Other keys
     may be present.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodeProxy
  (proxy [node] &quot;A map with SSH proxy connection details.&quot;))</pre></td></tr><tr><td class="docs"><p>Predicate to test whether an object implements the Node protocol</p>
</td><td class="codes"><pre class="brush: clojure">(defn node?
  [obj]
  (instance? pallet.node.Node obj))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn node-in-group? [grp-name node]
  (= (name grp-name) (group-name node)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn node-address
  [node]
  (cond
    (string? node) node
    (primary-ip node) (primary-ip node)
    :else (private-ip node)))</pre></td></tr><tr><td class="docs"><p>Return the specified tag.</p>
</td><td class="codes"><pre class="brush: clojure">(defn tag
  ([node tag-name]
     (node-tag (compute-service node) node tag-name))
  ([node tag-name default-value]
     (node-tag (compute-service node) node tag-name default-value)))</pre></td></tr><tr><td class="docs"><p>Return the tags.</p>
</td><td class="codes"><pre class="brush: clojure">(defn tags
  [node]
  (node-tags (compute-service node) node))</pre></td></tr><tr><td class="docs"><p>Set a value on the given tag-name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn tag!
  [node tag-name value]
  (tag-node! (compute-service node) node tag-name value))</pre></td></tr><tr><td class="docs"><p>Predicate to test the availability of tags.</p>
</td><td class="codes"><pre class="brush: clojure">(defn taggable?
  [node]
  (node-taggable? (compute-service node) node))</pre></td></tr><tr><td class="docs"><p>Convert a node into a map representing the node.</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-map
  [node]
  (try
    {:proxy (proxy node)
     :ssh-port (ssh-port node)
     :primary-ip (primary-ip node)
     :private-ip (private-ip node)
     :is-64bit? (is-64bit? node)
     :group-name (name (group-name node))
     :hostname (hostname node)
     :os-family (os-family node)
     :os-version (os-version node)
     :running? (running? node)
     :terminated? (terminated? node)
     :id (id node)}
    (catch Exception e
      (trace e (with-out-str (print-cause-trace e)))
      {:primary-ip &quot;N/A&quot; :host-name &quot;N/A&quot;})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.node-value" name="pallet.node-value"><h1 class="project-name">pallet.node-value</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A node value is a value that is retrieved from a node and can only be deref'd
   when after the value as been provided by an action.</p>

<p>   The action may not be executed on the same pallet machine as the phase, so
   the actual value is in the session map, and the node-value contains a key
   into the session map's :node-values key.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.node-value
  (:require
   [pallet.argument :refer [*session* DelayedArgument]]
   [pallet.common.context :refer [throw-map]]
   [pallet.core.session :refer [session session!]]))</pre></td></tr><tr><td class="docs"><p>(defprotocol SetableNodeValue
  "A protocol used to set node-values"
  (node-value! [_ value]))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A protocol used to read node-values</p>
</td><td class="codes"><pre class="brush: clojure">(defprotocol NodeValueAccessor
  (node-value [_ session]))</pre></td></tr><tr><td class="docs"><p>Throw an exception on access other than deref</p>
</td><td class="codes"><pre class="brush: clojure">(defn invalid-access
  [s]
  (throw-map
   &quot;Invalid access of a node-value that has yet to be set by an action.&quot;
   {:type :pallet/access-of-node-value-without-deref
    :via s}))</pre></td></tr><tr><td class="docs"><p>A value that is set based on some value from a node.
We implement several interfaces, just to ensure that they do not silently
fail.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Use IFn to read value from session?</p>
</td><td class="codes"><pre class="brush: clojure">(deftype NodeValue
    [path]
  ;; SetableNodeValue
  ;; (node-value! [_ new-value] (reset! value new-value))
  NodeValueAccessor
  (node-value [_ session]
    (let [rv (get-in session [:plan-state :node-values path] ::not-set)]
      (if (= rv ::not-set)
        (throw-map
         (str
          &quot;Invalid access of a node-value that has yet to be set by an action. &quot;
          &quot;If you are using an expression involving a node-value as an &quot;
          &quot;argument to a plan function, you should wrap the expression in a &quot;
          &quot;`delayed` form.\n\n&quot;
          &quot;    (pallet.argument/delayed [session] @node-value)&quot;)
         {:type :pallet/access-of-unset-node-value
          :path path})
        rv)))
  DelayedArgument
  (evaluate [x session]
    (node-value x session))
  Object
  (toString [_] (pr-str path))
  clojure.lang.IDeref
  (deref [nv]
    (node-value nv *session*))
  clojure.lang.IPending
  (isRealized [nv]
    (not=
     (get-in *session* [:plan-state :node-values path] ::not-set)
     ::not-set))
  clojure.lang.Associative
  (containsKey [_ key] (invalid-access 'containsKey))
  (entryAt [_ key] (invalid-access 'entryAt))
  (assoc [_ key val] (invalid-access 'assoc)))</pre></td></tr><tr><td class="docs"><p>Create an empty node-value</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-node-value
  [path]
  (NodeValue. path))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn node-value?
  [v]
  (instance? NodeValue v))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-node-value
  ([session v node-value-path]
     (assoc-in session [:plan-state :node-values node-value-path] v))
  ([session v]
     (set-node-value session v (:current-node-value-path session))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn assign-node-value
  [nv v]
  (session!
   (assoc-in (session) [:plan-state :node-values (.path ^NodeValue nv)] v)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-node-value
  [nv]
  (fn [session] [(node-value nv session) session]))</pre></td></tr><tr><td class="docs"><p>Return a node value symbol</p>
</td><td class="codes"><pre class="brush: clojure">(defn node-value-symbol
  []
  (gensym &quot;nv&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.phase" name="pallet.phase"><h1 class="project-name">pallet.phase</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A phase is a function of a single <code>session</code> argument, that contains
   calls to crate functions or actions. A phase has an implicitly
   defined pre and post phase.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.phase
  (:require
   [pallet.core.session :refer [session session! session-context]]
   [pallet.session.verify :refer [check-session]]))</pre></td></tr><tr><td class="docs"><p>Return the name for the pre-phase for the given <code>phase</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pre-phase-name
  [phase]
  (keyword &quot;pallet.phase&quot; (str &quot;pre-&quot; (name phase))))</pre></td></tr><tr><td class="docs"><p>Return the name for the post-phase for the given <code>phase</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn post-phase-name
  [phase]
  (keyword &quot;pallet.phase&quot; (str &quot;post-&quot; (name phase))))</pre></td></tr><tr><td class="docs"><p>Return a sequence including the implicit pre and post phases for a phase.</p>
</td><td class="codes"><pre class="brush: clojure">(defn all-phases-for-phase
  [phase]
  [(pre-phase-name phase) phase (post-phase-name phase)])</pre></td></tr><tr><td class="docs"><p>Return the phase this is a subphase for, or nil if not a subphase</p>
</td><td class="codes"><pre class="brush: clojure">(defn subphase-for
  [phase]
  (when (= (namespace phase) &quot;pallet.phase&quot;)
    (let [n (name phase)
          [_ pre] (re-matches #&quot;pre-(.*)&quot; n)
          [_ post] (re-matches #&quot;post-(.*)&quot; n)
          p (or pre post)]
      (when p
        (keyword p)))))</pre></td></tr><tr><td class="docs"><p>Specify that the body should be executed in the pre-phase.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [#'session-context session! session]}
  schedule-in-pre-phase
  [&amp; body]
  `(session-context
    schedule-in-pre-phase {}
    (let [phase# (get (session) :phase)]
      (session! (assoc (session) :phase (pre-phase-name phase#)))
      ~@body
      (session! (assoc (session) :phase phase#)))))</pre></td></tr><tr><td class="docs"><p>Specify that the body should be executed in the post-phase.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro schedule-in-post-phase
  [&amp; body]
  `(session-context
    schedule-in-post-phase {}
    (let [phase# (get (session) :phase)]
      (session! (assoc (session) :phase (post-phase-name phase#)))
      ~@body
      (session! (assoc (session) :phase phase#)))))</pre></td></tr><tr><td class="docs"><p>Add session checking to a sequence of calls which thread a session
   map. e.g.</p>

<pre><code>   (-&gt;
     session
     (check-session-thread
       (file "/some-file")
       (file "/other-file")))
</code></pre>

<p>   The example is thus equivalent to:</p>

<pre><code>   (-&gt; session
     (check-session "The session passed to the pipeline")
     (check-session (file "/some-file"))
     (check-session (file "/other-file")))
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [check-session]}
  check-session-thread
  [arg &amp; body]
  `(-&gt;
    ~arg
    (check-session &quot;The session passed to the pipeline&quot;)
    ~@(mapcat (fn [form] [form `(check-session '~form)]) body)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.plugin" name="pallet.plugin"><h1 class="project-name">pallet.plugin</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.plugin (:require
                   [chiba.plugin :refer [plugins]]))</pre></td></tr><tr><td class="docs"><p>Load pallet plugins</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-plugins
  []
  (let [plugin-namespaces (plugins &quot;pallet.plugin.&quot; #&quot;.*test.*&quot;)]
    (doseq [plugin plugin-namespaces]
      (require plugin)
      (when-let [init (ns-resolve plugin 'init)]
        (init)))
    plugin-namespaces))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.project" name="pallet.project"><h1 class="project-name">pallet.project</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet projects are specified in a pallet.clj file.</p>

<p>The files are loaded by calling clojure.core/load in the pallet.project.load
namespace.  The defproject form in that file def's a <code>pallet-project-map</code> var,
which is reset after loading.</p>

<p>defproject refers to pallet.project.loader/defproject.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.project
  (:require
   [clojure.java.io :refer [file resource]]
   [clojure.set :refer [intersection]]
   [clojure.string :as string]
   [clojure.tools.logging :refer [debugf tracef]]
   [pallet.api :refer [cluster-spec extend-specs]]
   [pallet.contracts :refer [check-group-spec]]
   [pallet.utils :refer [log-multiline]]))</pre></td></tr><tr><td class="docs"><h2>Read a project file</h2>
</td><td class="codes"><pre class="brush: clojure">(def default-pallet-file &quot;pallet.clj&quot;)
(def default-user-pallet-file
  (.getAbsolutePath
   (file (System/getProperty &quot;user.home&quot;) &quot;.pallet&quot; &quot;pallet.clj&quot;)))</pre></td></tr><tr><td class="docs"><p>Adds default phases.  Note that these are merged as ordinary clojure maps,
  not as server-specs, so that the project can remove default behaviour.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-default-phases
  [{:keys [phases]} project]
  (assoc project :phases (merge {:bootstrap ()}) ))</pre></td></tr><tr><td class="docs"><p>Read the project file</p>
</td><td class="codes"><pre class="brush: clojure">(defn read-project
  ([pallet-file]
     (locking read-project
       (require 'pallet.project.load)
       (binding [*ns* (find-ns 'pallet.project.load)]
         (try (load-file pallet-file)
              (catch java.io.FileNotFoundException e
                (throw e))
              (catch Exception e
                (throw
                 (ex-info &quot;Error loading project.clj&quot;
                          {:project-file pallet-file} e)))))
       (let [project (resolve 'pallet.project.load/pallet-project-map)]
         (when-not project
           (throw (ex-info &quot;pallet.clj must define project map.&quot;
                           {:actual (pr-str project)})))
         ;; Remove the pallet project loading var
         (ns-unmap 'pallet.project.load 'pallet-project-map)
         @project)))
  ([] (read-project default-pallet-file)))</pre></td></tr><tr><td class="docs"><p>Predicate to check if a pallet.clj file exists.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pallet-file-exists?
  ([pallet-file] (.exists (file pallet-file)))
  ([] (pallet-file-exists? default-pallet-file)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-project-file
  [project-name pallet-file]
  (when-let [parent (.getParentFile (file pallet-file))]
    (.mkdirs parent))
  (spit pallet-file
        (-&gt; (resource &quot;pallet/default-project-pallet.clj&quot;)
            slurp
            (string/replace &quot;{{project-name}}&quot; project-name))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn read-or-create-project
  ([project-name pallet-file]
     (when-not (pallet-file-exists? pallet-file)
       (create-project-file project-name pallet-file))
     (read-project pallet-file))
  ([project-name] (read-or-create-project project-name default-pallet-file)))</pre></td></tr><tr><td class="docs"><h2>Provide a default project</h2>
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic ^:internal *project* nil)</pre></td></tr><tr><td class="docs"><p>Set the specified project map as the default project.</p>
</td><td class="codes"><pre class="brush: clojure">(defn use-project!
  [project]
  (alter-var-root #'*project* project))</pre></td></tr><tr><td class="docs"><p>Return the default project, or nil if there is none.</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-project
  []
  *project*)</pre></td></tr><tr><td class="docs"><h2>group-specs for a project</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ensure-group-count [group]
  (merge {:count 1} group))</pre></td></tr><tr><td class="docs"><p>Use the node-specs specified in the variant.  The variant can have a
   general node-spec, or a per-group node-spec under the <code>:groups</code> key</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-variant-node-specs
  [{:keys [node-spec groups] :as variant} {:keys [group-name] :as group}]
  (merge node-spec (get-in groups [group-name :node-spec]) group))</pre></td></tr><tr><td class="docs"><p>Use the node-specs specified in the variant.  The variant can have a
   general node-spec, or a per-group node-spec under the <code>:groups</code> key</p>
</td><td class="codes"><pre class="brush: clojure">(defn merge-variant-phases
  [{:keys [phases groups] :as variant} {:keys [group-name] :as group}]
  (extend-specs
   group
   (remove
    nil?
    [(select-keys variant [:phases]) (get-in groups [group-name])])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decorate-name [{:keys [group-prefix group-suffix node-spec]
                      :or {group-prefix  group-suffix }
                      :as variant} group]
  (update-in group [:group-name]
             #(keyword (str group-prefix (name %) group-suffix))))</pre></td></tr><tr><td class="docs"><p>Compute the groups for a pallet project using the given compute service
provider keyword.  The node specs are filtered by the selector selector set,
which defaults to #{:default}.  The groups can be filtered by the roles set, and
by group-names.</p>
</td><td class="codes"><pre class="brush: clojure">(defn spec-from-project
  ([{:keys [groups provider service] :as pallet-project} provider-kw
    selectors roles group-names]
     (debugf
      &quot;spec-from-project selectors %s roles %s group-names %s provider %s&quot;
      selectors roles group-names provider-kw)
     (let [selectors (or selectors #{:default})
           variants (get-in provider [provider-kw :variants])
           ;; if variants are given we select from them, otherwise just
           ;; use the default
           variants (if variants
                      (filter
                       (comp seq #(intersection (set selectors) %) :selectors)
                       variants)
                      [(get provider provider-kw)])
           _ (debugf &quot;Groups : %s&quot; (mapv :group-name groups))
           _ (debugf &quot;Filtering groups with group-names : %s&quot; group-names)
           groups (if (seq group-names)
                    (filter #((set group-names) (:group-name %)) groups)
                    groups)
           _ (debugf &quot;Filtering %s for roles with %s&quot;
                     (mapv :group-name groups) roles)
           _ (tracef &quot;Variants %s&quot; (vec variants))
           groups (if (seq roles)
                    (filter
                     (comp seq #(intersection (set roles) %) :roles)
                     groups)
                    groups)
           _ (doseq [group groups] (check-group-spec group))
           groups (apply concat
                         (for [variant variants]
                           (map
                            (comp
                             #(decorate-name variant %)
                             #(merge-variant-node-specs variant %)
                             #(merge-variant-phases variant %)
                             ensure-group-count)
                            groups)))]
       (debugf
        &quot;spec-from-project for %s found %s variants and %s groups&quot;
               selectors (count variants) (count groups))
       (debugf &quot;spec-from-project groups %s&quot; (mapv :group-name groups))
       (log-multiline
        :trace
        &quot;spec-from-project groups %s&quot;
        (with-out-str (clojure.pprint/pprint (vec groups))))
       (doseq [group groups] (check-group-spec group))
       (:groups (cluster-spec &quot;&quot; :groups groups))))
  ([pallet-project provider-kw]
     (spec-from-project pallet-project provider-kw #{:default})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.project.load" name="pallet.project.load"><h1 class="project-name">pallet.project.load</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Namespace for loading pallet project files.  Provides a default set of
  requires that are available to the pallet file.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.project.load)</pre></td></tr><tr><td class="docs"><p>Anything in here is visible in the pallet.clj project file.
The explicit require is to prevent slamhound removing it.</p>
</td><td class="codes"><pre class="brush: clojure">(require
 '[pallet.action :refer [with-action-options]]
 '[pallet.actions :refer :all :exclude [update-settings assoc-settings]]
 '[pallet.api :refer :all]
 '[pallet.crate :refer :all :exclude [compute-service]]
 '[pallet.crate.automated-admin-user
   :refer [automated-admin-user with-automated-admin-user]]
 '[pallet.project.loader :refer [defproject]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.project.loader" name="pallet.project.loader"><h1 class="project-name">pallet.project.loader</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions and macros required to load a pallet project configuration file.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.project.loader
  (:require
   [pallet.actions :refer [package-manager]]
   [pallet.api :refer [group-spec plan-fn]]
   [pallet.core.primitives :refer [default-phase-meta]]
   [pallet.crate.automated-admin-user :refer [automated-admin-user]]))</pre></td></tr><tr><td class="docs"><p>Defaults are handled here so we can prevent pallet.project from dependening
statically on pallet.api and the crates.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def static-project-defaults
  {:source-paths [&quot;pallet/src&quot;]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-bootstrap
  (with-meta
    (plan-fn
      (package-manager :update)
      (automated-admin-user))
    (:bootstrap default-phase-meta)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-default-phases
  [{:keys [project-name phases] :as project}]
  (-&gt; project
      (update-in [:phases :bootstrap] #(or % default-bootstrap))
      (update-in
       [:groups]
       (fn [groups]
         (map
          (fn [g]
            (update-in g [:phases :bootstrap] #(or % default-bootstrap)))
          groups)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-default-group-spec
  [{:keys [project-name phases] :as project}]
  (update-in project [:groups] #(or %
                                    [(group-spec project-name
                                                 :phases phases
                                                 :count 1)])))</pre></td></tr><tr><td class="docs"><p>Add project defaults</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-defaults
  [project]
  (-&gt;&gt;
   project
   (merge static-project-defaults)
   add-default-phases
   add-default-group-spec))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-project
  [project project-name root]
  (add-defaults (assoc project
                  :project-name (name project-name)
                  :root root)))</pre></td></tr><tr><td class="docs"><p>The pallet.clj file must either def a project map or call this macro.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defproject
  [project-name &amp; {:as args}]
  `(let [args# ~args
         root# ~(.getParent (clojure.java.io/file *file*))]
     (def ~'pallet-project-map
       (make-project args# '~project-name root#))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.script.lib" name="pallet.script.lib"><h1 class="project-name">pallet.script.lib</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Script library for abstracting target host script differences</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.script.lib
  (:refer-clojure :exclude [alias source])
  (:require
   [clojure.string :as string]
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [chained-script script with-source-line-comments]]
   [pallet.thread-expr :as thread-expr]))</pre></td></tr><tr><td class="docs"><p>basic</p>
</td><td class="codes"><pre class="brush: clojure">(defn translate-options
  [options translations]
  (reduce
   (fn [options [from to]]
     (-&gt; options
         (assoc to (from options))
         (dissoc from)))
   options
   translations))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript exit [value])
(script/defimpl exit :default [value]
  (&quot;exit&quot; ~value))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript export [name value])
(script/defimpl export :default [name value]
  (&quot;export&quot; (str ~name &quot;=&quot; ~value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript source [path])
(script/defimpl source :default [path]
  (&quot;source&quot; ~path))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript alias [name value])
(script/defimpl alias :default [name value]
  (&quot;alias&quot; (str ~name &quot;=&quot; ~value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript xargs [script])
(script/defimpl xargs :default
  [script]
  (&quot;xargs \\\n&quot; ~script))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript which [arg])
(script/defimpl which :default
  [arg]
  (&quot;which&quot; ~arg))</pre></td></tr><tr><td class="docs"><p>Check whether the specified command is on the path</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript has-command?
  [arg])
(script/defimpl has-command? :default [arg] (&quot;hash&quot; ~arg &quot;2&gt;&amp;-&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript canonical-path [path]
  &quot;Return the canonical version of the specified path&quot;
  [arg])
(script/defimpl canonical-path :default [arg] (&quot;readlink&quot; -f ~arg))
(script/defimpl canonical-path [#{:darwin :os-x}] [arg]
  (chain-and
   (var ccwd @(&quot;pwd&quot;))
   (&quot;cd&quot; @(&quot;dirname&quot; ~arg))
   (println (quoted (str @(&quot;pwd&quot; -P) &quot;/&quot; @(&quot;basename&quot; ~arg))))
   (&quot;cd&quot; @ccwd)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript rm [file &amp; {:keys [recursive force]}])
(script/defimpl rm :default [file &amp; {:keys [recursive force] :as options}]
  (&quot;rm&quot; ~(stevedore/map-to-arg-string options) ~file))
(script/defimpl rm [#{:darwin :os-x}] [file &amp; {:keys [recursive force]}]
  (&quot;rm&quot; ~(stevedore/map-to-arg-string {:r recursive :f force}) ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript mv [source destination &amp; {:keys [force backup]}])
(script/defimpl mv :default
  [source destination &amp; {:keys [force backup]}]
  (&quot;mv&quot;
   ~(stevedore/map-to-arg-string
     {:f force :backup (when backup (name backup))}
     :assign true)
   ~source ~destination))
(script/defimpl mv [#{:darwin :os-x}]
  [source destination &amp; {:keys [force backup]}]
  (&quot;mv&quot;
   ~(stevedore/map-to-arg-string
     {:f force}
     :assign true)
   ~source ~destination))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript cp [source destination &amp; {:keys [force backup preserve]}])
(script/defimpl cp :default
  [source destination &amp; {:keys [force backup preserve]}]
  (&quot;cp&quot;
   ~(stevedore/map-to-arg-string {:f force
                                  :backup (when backup (name backup))
                                  :p preserve}
                                 :assign true)
   ~source ~destination))
(script/defimpl cp [#{:darwin :os-x}]
  [source destination &amp; {:keys [force backup preserve]}]
  (&quot;cp&quot;
   ~(stevedore/map-to-arg-string {:f force :p preserve} :assign true)
   ~source ~destination))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript ln [source destination &amp; {:keys [force symbolic no-deref]}])
(script/defimpl ln :default
  [source destination &amp; {:keys [force symbolic no-deref]}]
  (&quot;ln&quot;
   ~(stevedore/map-to-arg-string {:f force :s symbolic :n no-deref})
   ~source ~destination))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript backup-option [])
(script/defimpl backup-option :default []
  &quot;--backup=numbered&quot;)
(script/defimpl backup-option [#{:darwin :os-x}] [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript basename [path])
(script/defimpl basename :default
  [path]
  (&quot;basename&quot; ~path))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript dirname [path])
(script/defimpl dirname :default
  [path]
  (&quot;dirname&quot; ~path))</pre></td></tr><tr><td class="docs"><p>Return the owner of the given path</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript path-owner
  [path])
(script/defimpl path-owner :default
  [path]
  (&quot;stat&quot; &quot;-c%U&quot; ~path))
(script/defimpl path-owner [#{:darwin :os-x}] [path]
  (&quot;stat&quot; &quot;-f&quot; &quot;%Su&quot; ~path))</pre></td></tr><tr><td class="docs"><p>Return the group of the given path</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript path-group
  [path])
(script/defimpl path-group :default
  [path]
  (&quot;stat&quot; &quot;-c%G&quot; ~path))
(script/defimpl path-group [#{:darwin :os-x}] [path]
  (&quot;stat&quot; &quot;-f&quot; &quot;%Sg&quot; ~path))</pre></td></tr><tr><td class="docs"><p>Return the mode of the given path</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript path-mode
  [path])
(script/defimpl path-mode :default
  [path]
  (&quot;stat&quot; &quot;-c%a&quot; ~path))
(script/defimpl path-mode [#{:darwin :os-x}] [path]
  (&quot;stat&quot; &quot;-f&quot; &quot;%Op&quot; ~path))</pre></td></tr><tr><td class="docs"><p>Return the user's default group</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript user-default-group
  [user])
(script/defimpl user-default-group :default
  [user]
  (&quot;id&quot; &quot;-ng&quot; ~user))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript ls [pattern &amp; {:keys [sort-by-time sort-by-size reverse]}])
(script/defimpl ls :default
  [pattern &amp; {:keys [sort-by-time sort-by-size reverse]}]
  (&quot;ls&quot; ~(stevedore/map-to-arg-string
          {:t sort-by-time
           :S sort-by-size
           :r reverse})
   ~pattern))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript cat [pattern])
(script/defimpl cat :default
  [pattern]
  (&quot;cat&quot; ~pattern))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript tail [pattern &amp; {:keys [max-lines]}])
(script/defimpl tail :default
  [pattern &amp; {:keys [max-lines]}]
  (&quot;tail&quot; ~(stevedore/map-to-arg-string {:n max-lines}) ~pattern))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript diff [file1 file2 &amp; {:keys [unified]}])
(script/defimpl diff :default
  [file1 file2 &amp; {:keys [unified]}]
  (&quot;diff&quot; ~(stevedore/map-to-arg-string {:u unified}) ~file1 ~file2))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript cut [file &amp; {:keys [fields delimiter]}])
(script/defimpl cut :default
  [file &amp; {:keys [fields delimiter]}]
  (&quot;cut&quot;
   ~(stevedore/map-to-arg-string {:f fields :d delimiter})
   ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript chown [owner file &amp; {:as options}])
(script/defimpl chown :default [owner file &amp; {:as options}]
  (&quot;chown&quot; ~(stevedore/map-to-arg-string options) ~owner ~file))
(script/defimpl chown [#{:darwin :os-x}]
  [owner file &amp; {:keys [recursive force]}]
  (&quot;chown&quot; ~(stevedore/map-to-arg-string {:R recursive :f force}) ~owner ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript chgrp [group file &amp; {:as options}])
(script/defimpl chgrp :default [group file &amp; {:as options}]
  (&quot;chgrp&quot; ~(stevedore/map-to-arg-string options) ~group ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript chmod [mode file &amp; {:as options}])
(script/defimpl chmod :default [mode file &amp; {:as options}]
  (&quot;chmod&quot; ~(stevedore/map-to-arg-string options) ~mode ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript touch [file &amp; {:as options}])
(script/defimpl touch :default [file &amp; {:as options}]
  (&quot;touch&quot; ~(stevedore/map-to-arg-string options) ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript sed-file [file expr-map options])</pre></td></tr><tr><td class="docs"><p>Possible sed separators</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc  :private true}
  sed-separators
  (concat [\/ \_ \| \: \% \! \@] (map char (range 42 127))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl sed-file :default
  [file expr-map {:keys [seperator restriction quote-with]
                  :or {quote-with &quot;\}
                  :as options}]
  (&quot;sed&quot; &quot;-i&quot;
   ~(if (map? expr-map)
      (string/join
       &quot; &quot;
       (map
        (fn [[^String key ^String value]]
          (let [used (fn [c]
                       (or (&gt;= (.indexOf key (int c)) 0)
                           (&gt;= (.indexOf value (int c)) 0)))
                seperator (or seperator (first (remove used sed-separators)))]
            (format
             &quot;-e %s%ss%s%s%s%s%s%s&quot;
             quote-with
             (if restriction (str restriction &quot; &quot;) )
             seperator key seperator value seperator quote-with)))
        expr-map))
      (format
       &quot;-e %s%s%s%s&quot;
       quote-with
       (if restriction (str restriction &quot; &quot;) )
       expr-map quote-with))
   ~file))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript sed-ext [])
(script/defimpl sed-ext :default [] )
(script/defimpl sed-ext [#{:darwin :os-x}] [] &quot;.bak&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript md5sum [file &amp; {:as options}])
(script/defimpl md5sum :default [file &amp; {:as options}]
  (&quot;md5sum&quot; ~(stevedore/map-to-arg-string options) ~file))
(script/defimpl md5sum [#{:darwin :os-x}] [file &amp; {:as options}]
  (&quot;/sbin/md5&quot; -r ~file))</pre></td></tr><tr><td class="docs"><p>Normalise an md5 sum file to contain the base filename</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript normalise-md5
  [file])
(script/defimpl normalise-md5 :default
  [file]
  (if (&quot;egrep&quot; &quot;'^[a-fA-F0-9]+$'&quot; ~file)
    (println
     (quoted (str &quot;  &quot; @(pipe (&quot;basename&quot; ~file) (&quot;sed&quot; -e &quot;s/.md5//&quot;))))
     &quot;&gt;&gt;&quot; ~file))
  (sed-file ~file ~{&quot;/.*/\\(..*\\)&quot; &quot;\\1&quot;} ~{}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript md5sum-verify [file &amp; {:as options}])
(script/defimpl md5sum-verify :default
  [file &amp; {:keys [quiet check] :or {quiet true check true} :as options}]
  (&quot;(&quot; (chain-and
        (&quot;cd&quot; @(dirname ~file))
        (&quot;md5sum&quot;
         ~(stevedore/map-to-arg-string {:quiet quiet :check check})
         @(basename ~file))) &quot;)&quot;))
(script/defimpl md5sum-verify [#{:centos :debian :amzn-linux :rhel :fedora}]
  [file &amp; {:keys [quiet check] :or {quiet true check true} :as options}]
  (&quot;(&quot; (chain-and
        (&quot;cd&quot; @(dirname ~file))
        (&quot;md5sum&quot;
         ~(stevedore/map-to-arg-string {:status quiet :check check})
         @(&quot;basename&quot; ~file))) &quot;)&quot;))
(script/defimpl md5sum-verify [#{:darwin :os-x}] [file &amp; {:as options}]
  (&quot;(&quot; (chain-and
        (var testfile @(~cut ~file :delimiter &quot; &quot; :fields 2))
        (var md5 @(~cut ~file :delimiter &quot; &quot; :fields 1))
        (var md5q @(&quot;/sbin/md5&quot; -q (quoted (str @(dirname ~file) / @testfile))))
        (&quot;test&quot; (quoted @md5q) == (quoted @md5))
        @mres) &quot;)&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript backup-option [])
(script/defimpl backup-option :default []
  &quot;--backup=numbered&quot;)
(script/defimpl backup-option [#{:darwin :os-x}] [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript download-file [url path &amp; {:keys [proxy insecure]}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl download-file :default [url path &amp; {:keys [proxy insecure]}]
  (if (~has-command? curl)
    (&quot;curl&quot; &quot;-o&quot; (quoted ~path)
          --retry 5 --silent --show-error --fail --location
          ~(if proxy
             (let [url (java.net.URL. proxy)]
               (format &quot;--proxy %s:%s&quot; (.getHost url) (.getPort url))))
          ~(if insecure &quot;--insecure&quot; )
          (quoted ~url))
    (if (~has-command? wget)
      (&quot;wget&quot; &quot;-O&quot; (quoted ~path) --tries 5 --no-verbose --progress=dot:mega
            ~(if proxy
               (format
                &quot;-e \&quot;http_proxy = %s\&quot; -e \&quot;ftp_proxy = %s\ proxy proxy))
            ~(if insecure &quot;--no-check-certificate&quot; )
            (quoted ~url))
      (do
        (println &quot;No download utility available&quot;)
        (exit 1)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript download-request [path request])
(script/defimpl download-request :default [path request]
  (&quot;curl&quot; &quot;-o&quot; (quoted ~path) --retry 3 --silent --show-error --fail --location
   ~(string/join
     &quot; &quot;
     (map (fn dlr-fmt [e] (format &quot;-H \&quot;%s: %s\ (key e) (val e)))
          (:headers request)))
   (quoted ~(str (:endpoint request)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript tmp-dir [])
(script/defimpl tmp-dir :default []
  (deref TMPDIR :default-value
         (deref TEMP :default-value
                (deref TMP :default-value
                       @(if (directory? &quot;/tmp&quot;)
                          (println &quot;/tmp&quot;)
                          (if (directory? &quot;/var/tmp&quot;)
                            (println &quot;/var/tmp&quot;)
                            (if (directory? &quot;/use/tmp&quot;)
                              (println &quot;/usr/tmp&quot;))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript make-temp-file [pattern &amp; {:keys [tmpdir]}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl make-temp-file :default
  [pattern &amp; {:keys [tmpdir]}]
  ;; mktemp without --tmpdir, and -t with no option value
  ~(if tmpdir
     (if (string? tmpdir)
       (script
        (&quot;(&quot;                            ; subprocess so TMPDIR is not clobbered
         (set! TMPDIR (quoted ~tmpdir))
         @(&quot;mktemp&quot; -t (quoted ~(str pattern &quot;XXXXX&quot;)))
         &quot;)&quot;))
       (script @(&quot;mktemp&quot; -t (quoted ~(str pattern &quot;XXXXX&quot;)))))
     (script
      @(&quot;mktemp&quot; (quoted ~(str pattern &quot;XXXXX&quot;))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl make-temp-file [:ubuntu]
  [pattern &amp; {:keys [tmpdir] :as options}]
  ;; mktemp with --tmpdir
  @(&quot;mktemp&quot;
    ~(stevedore/map-to-arg-string options :assign true)
    (quoted ~(str pattern &quot;XXXXX&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl make-temp-file [:darwin :os-x]
  [pattern &amp; {:keys [tmpdir]}]
  ;; mktemp without --tmpdir, and -t with an option value
  ~(if tmpdir
     (if (string? tmpdir)
       (script
        (&quot;(&quot;                            ; subprocess so TMPDIR is not clobbered
         (set! TMPDIR (quoted ~tmpdir))
         @(&quot;mktemp&quot; -t (quoted ~pattern) &quot;XXXXX&quot;)
         &quot;)&quot;))
       (script @(&quot;mktemp&quot; -t (quoted ~pattern) &quot;XXXXX&quot;)))
     (script
      @(&quot;mktemp&quot; (quoted ~(str pattern &quot;XXXXX&quot;))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript heredoc-in [cmd content {:keys [literal]}])
(script/defimpl heredoc-in :default [cmd content {:keys [literal]}]
  (&quot;{&quot; ~cmd
   ~(str (if literal &quot;&lt;&lt;'EOFpallet'\n&quot; &quot;&lt;&lt;EOFpallet\n&quot;)
         content &quot;\nEOFpallet\n }&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript heredoc [path content {:keys [literal]}])
(script/defimpl heredoc :default
  [path content {:keys [literal] :as options}]
  (~heredoc-in (&quot;cat&quot; &quot;&gt;&quot; ~path) ~content ~options))</pre></td></tr><tr><td class="docs"><p>Remove the specified directory</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript rmdir
  [directory &amp; {:as options}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl rmdir :default [directory &amp; {:as options}]
  (rmdir ~(stevedore/map-to-arg-string options) ~directory))</pre></td></tr><tr><td class="docs"><p>Create the specified directory</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript mkdir
  [directory &amp; {:keys [path verbose mode]}])
(script/defimpl mkdir :default
  [directory &amp; {:keys [path verbose mode] :as options}]
  (&quot;mkdir&quot;
   ~(stevedore/map-to-arg-string {:m mode :p path :v verbose})
   ~directory))</pre></td></tr><tr><td class="docs"><p>Create a temporary directory</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript make-temp-dir
  [pattern &amp; {:as options}])
(script/defimpl make-temp-dir :default [pattern &amp; {:as options}]
  @(&quot;mktemp&quot; -d --tmpdir
    ~(stevedore/map-to-arg-string options)
    ~(str pattern &quot;XXXXX&quot;)))
(script/defimpl make-temp-dir [#{:darwin :os-x}] [pattern &amp; {:as options}]
  @(&quot;mktemp&quot; -d
    ~(stevedore/map-to-arg-string options)
    -t (str &quot;pallet&quot; ~(str pattern &quot;XXXXX&quot;))))</pre></td></tr><tr><td class="docs"><p>Host information.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript os-version-name [])
(script/defimpl os-version-name [#{:ubuntu :debian}] []
  @(&quot;lsb_release&quot; -c -s))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl os-version-name :default [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript hostname [&amp; options])
(script/defimpl hostname :default [&amp; options]
  @(&quot;hostname&quot;
    ~(if (first options)
       (stevedore/map-to-arg-string (apply hash-map options)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript dnsdomainname [])
(script/defimpl dnsdomainname :default []
  @(&quot;dnsdomainname&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript nameservers [])
(script/defimpl nameservers :default []
  @(pipe (&quot;grep&quot; nameserver &quot;/etc/resolv.conf&quot;)
         (&quot;cut&quot; &quot;-f2&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript debian-version [])
(script/defimpl debian-version :default []
  (if (file-exists? &quot;/etc/debian&quot;) (&quot;cat&quot; &quot;/etc/debian&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript redhat-version [])
(script/defimpl redhat-version :default []
  (if (file-exists? &quot;/etc/redhat-release&quot;) (&quot;cat&quot; &quot;/etc/redhat-release&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript ubuntu-version [])
(script/defimpl ubuntu-version :default []
  (if (file-exists? &quot;/usr/bin/lsb_release&quot;) @(&quot;/usr/bin/lsb_release&quot; -c -s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript arch [])
(script/defimpl arch :default []
  @(&quot;uname&quot; -p))</pre></td></tr><tr><td class="docs"><p>Users</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript user-exists? [name])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript modify-user [name options])
(script/defscript create-user [name options])
(script/defscript remove-user [name options])
(script/defscript lock-user [name])
(script/defscript unlock-user [name])
(script/defscript user-home [username])
(script/defscript current-user [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript group-exists? [name])
(script/defscript modify-group [name options])
(script/defscript create-group [name options])
(script/defscript remove-group [name options])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl user-exists? :default [username]
  (&quot;getent&quot; passwd ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn group-seq-&gt;string
  [groups]
  (if (not (string? groups))
    (string/join &quot;,&quot; groups)
    groups))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl create-user :default [username options]
  (&quot;/usr/sbin/useradd&quot;
   ~(-&gt; options
        (thread-expr/when-&gt;
         (:groups options)
         (update-in [:groups] group-seq-&gt;string))
        (thread-expr/when-&gt;
         (:group options)
         (assoc :g (:group options))
         (dissoc :group))
        stevedore/map-to-arg-string)
   ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl create-user [#{:rhel :centos :amzn-linux :fedora}]
  [username options]
  (&quot;/usr/sbin/useradd&quot;
   ~(-&gt; options
        (thread-expr/when-&gt;
         (:groups options)
         (update-in [:groups] group-seq-&gt;string))
        (translate-options {:system :r :group :g :password :p :groups :G})
        stevedore/map-to-arg-string)
   ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl modify-user :default [username options]
  (&quot;/usr/sbin/usermod&quot;
   ~(stevedore/map-to-arg-string
     (-&gt; options
         (thread-expr/when-&gt;
          (:groups options)
          (update-in [:groups] group-seq-&gt;string))))
   ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl modify-user [#{:rhel :centos :amzn-linux :fedora}]
  [username options]
  (&quot;/usr/sbin/usermod&quot;
   ~(-&gt; options
        (thread-expr/when-&gt;
         (:groups options)
         (update-in [:groups] group-seq-&gt;string))
        (translate-options
         {:system :r :group :g :password :p :append :a :groups :G})
        stevedore/map-to-arg-string)
   ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-user :default [username options]
  (&quot;/usr/sbin/userdel&quot; ~(stevedore/map-to-arg-string options) ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl lock-user :default [username]
  (&quot;/usr/sbin/usermod&quot; --lock ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl unlock-user :default [username]
  (&quot;/usr/sbin/usermod&quot; --unlock ~username))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl user-home :default [username]
  @(&quot;getent&quot; passwd ~username | &quot;cut&quot; &quot;-d:&quot; &quot;-f6&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl user-home [#{:darwin :os-x}] [username]
  @(pipe
    (&quot;dscl&quot; localhost -read ~(str &quot;/Local/Default/Users/&quot; username)
          &quot;dsAttrTypeNative:home&quot;)
    (&quot;cut&quot; -d &quot;' '&quot; -f 2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl current-user :default []
  @(&quot;whoami&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl group-exists? :default [name]
  (&quot;getent&quot; group ~name))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl create-group :default [groupname options]
  (&quot;/usr/sbin/groupadd&quot; ~(stevedore/map-to-arg-string options) ~groupname))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl create-group [#{:rhel :centos :amzn-linux :fedora}]
  [groupname options]
  (&quot;/usr/sbin/groupadd&quot;
   ~(-&gt; options
        (assoc :r (:system options))
        (dissoc :system)
        stevedore/map-to-arg-string)
   ~groupname))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl modify-group :default [groupname options]
  (&quot;/usr/sbin/groupmod&quot; ~(stevedore/map-to-arg-string options) ~groupname))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-group :default [groupname options]
  (&quot;/usr/sbin/groupdel&quot; ~(stevedore/map-to-arg-string options) ~groupname))</pre></td></tr><tr><td class="docs"><p>Package management</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Update the list of packages available to the package manager from the
   declared package sources.</p>

<p>the package management commands vary for each distribution, so we
use a script multimethod to describe these</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript update-package-list
  [&amp; options])</pre></td></tr><tr><td class="docs"><p>Upgrade the all installed package.</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript upgrade-all-packages
  [&amp; options])</pre></td></tr><tr><td class="docs"><p>Install the specified package.</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript install-package
  [name &amp; options])</pre></td></tr><tr><td class="docs"><p>Upgrade the specified package.</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript upgrade-package
  [name &amp; options])</pre></td></tr><tr><td class="docs"><p>Uninstall the specified package, leaving the configuration files if
   possible.</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript remove-package
  [name &amp; options])</pre></td></tr><tr><td class="docs"><p>Uninstall the specified package, removing the configuration files if
   possible.</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript purge-package
  [name &amp; options])</pre></td></tr><tr><td class="docs"><p>List the installed packages</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript list-installed-packages
  [&amp; options])</pre></td></tr><tr><td class="docs"><p>Implementation to do nothing
Repeating the selector makes it more explicit</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:no-packages} #{:no-packages}]
  [&amp; options] )
(script/defimpl upgrade-all-packages [#{:no-packages} #{:no-packages}]
  [&amp; options] )
(script/defimpl install-package [#{:no-packages} #{:no-packages}]
  [package &amp; options] )
(script/defimpl upgrade-package [#{:no-packages} #{:no-packages}]
  [package &amp; options] )
(script/defimpl remove-package [#{:no-packages} #{:no-packages}]
  [package &amp; options] )
(script/defimpl purge-package [#{:no-packages} #{:no-packages}]
  [package &amp; options] )
(script/defimpl list-installed-packages [#{:no-packages} #{:no-packages}]
  [&amp; options] )</pre></td></tr><tr><td class="docs"><p>aptitude</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:aptitude}] [&amp; {:keys [] :as options}]
  (chain-or
   (&quot;aptitude&quot; update -q=2 -y ~(stevedore/map-to-arg-string options)) true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:aptitude}] [&amp; options]
  (&quot;aptitude&quot; upgrade -q -y ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl install-package [#{:aptitude}] [package &amp; options]
  ~(with-source-line-comments false
     (script
      (chain-and
       (&quot;aptitude&quot; install -q -y ~(stevedore/option-args options) ~package)
       ;; show returns an error code if no package found, while install
       ;; does not.  There should be a better way than this...
       (&quot;aptitude&quot; show ~package)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-package [#{:aptitude}] [package &amp; options]
  (chain-and
   (&quot;aptitude&quot; install -q -y ~(stevedore/option-args options) ~package)
   ;; show returns an error code if no package found, while install
   ;; does not.  There should be a better way than this...
   (&quot;aptitude&quot; show ~package)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-package [#{:aptitude}] [package &amp; options]
  (&quot;aptitude&quot; remove -y ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl purge-package [#{:aptitude}] [package &amp; options]
  (&quot;aptitude&quot; purge -y  ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl list-installed-packages [#{:aptitude}] [&amp; options]
  (&quot;aptitude&quot; search --disable-columns (quoted &quot;~i&quot;)))</pre></td></tr><tr><td class="docs"><p>apt</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:apt}] [&amp; {:keys [] :as options}]
  (&quot;apt-get&quot; -qq ~(stevedore/map-to-arg-string options) update))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:apt}] [&amp; options]
  (&quot;apt-get&quot; -qq -y ~(stevedore/option-args options) upgrade))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl install-package [#{:apt}] [package &amp; options]
  (&quot;apt-get&quot; -qq -y ~(stevedore/option-args options) install ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-package [#{:apt}] [package &amp; options]
  (&quot;apt-get&quot; -qq -y ~(stevedore/option-args options)  install ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-package [#{:apt}] [package &amp; options]
  (&quot;apt-get&quot; -qq -y ~(stevedore/option-args options) remove ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl purge-package [#{:apt}] [package &amp; options]
  (&quot;apt-get&quot; -qq -y ~(stevedore/option-args options) remove ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl list-installed-packages [#{:apt}] [&amp; options]
  (&quot;dpkg&quot; --get-selections))</pre></td></tr><tr><td class="docs"><p>yum</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:yum}] [&amp; {:keys [enable disable]}]
  (&quot;yum&quot; makecache -q ~(string/join
                      &quot; &quot;
                      (concat
                       (map #(str &quot;--disablerepo=&quot; %) disable)
                       (map #(str &quot;--enablerepo=&quot; %) enable)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:yum}] [&amp; options]
  (&quot;yum&quot; update -y -q ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl install-package [#{:yum}] [package &amp; options]
  (&quot;yum&quot; install -y -q ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-package [#{:yum}] [package &amp; options]
  (&quot;yum&quot; upgrade -y -q ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-package [#{:yum}] [package &amp; options]
  (&quot;yum&quot; remove ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl purge-package [#{:yum}] [package &amp; options]
  (&quot;yum&quot; purge ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl list-installed-packages [#{:yum}] [&amp; options]
  (&quot;yum&quot; list installed))</pre></td></tr><tr><td class="docs"><p>zypper</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:zypper}] [&amp; options]
  (&quot;zypper&quot; refresh ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:zypper}] [&amp; options]
  (&quot;zypper&quot; update -y ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl install-package [#{:zypper}] [package &amp; options]
  (&quot;zypper&quot; install -y ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-package [#{:zypper}] [package &amp; options]
  (&quot;zypper&quot; remove ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl purge-package [#{:zypper}] [package &amp; options]
  (&quot;zypper&quot; remove ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs"><p>"pacman"</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:pacman}] [&amp; options]
  (&quot;pacman&quot; -Sy &quot;--noconfirm&quot; &quot;--noprogressbar&quot;
   ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:pacman}] [&amp; options]
  (&quot;pacman&quot; -Su &quot;--noconfirm&quot; &quot;--noprogressbar&quot; ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl install-package [#{:pacman}] [package &amp; options]
  (&quot;pacman&quot; -S &quot;--noconfirm&quot; &quot;--noprogressbar&quot;
   ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-package [#{:pacman}] [package &amp; options]
  (&quot;pacman&quot; -S &quot;--noconfirm&quot; &quot;--noprogressbar&quot;
   ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-package [#{:pacman}] [package &amp; options]
  (&quot;pacman&quot; -R &quot;--noconfirm&quot; ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl purge-package [#{:pacman}] [package &amp; options]
  (&quot;pacman&quot; -R &quot;--noconfirm&quot; &quot;--nosave&quot;
   ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs"><p>brew</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl update-package-list [#{:brew}] [&amp; options]
  (&quot;brew&quot; update ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl upgrade-all-packages [#{:brew}] [&amp; options]
  (&quot;brew&quot; upgrade ~(stevedore/option-args options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl install-package [#{:brew}] [package &amp; options]
  (chain-or
   ;; brew install complains if already installed
   (&quot;brew&quot; ls ~package &gt; &quot;/dev/null&quot; &quot;2&gt;&amp;1&quot;)
   (&quot;brew&quot; install -y ~(stevedore/option-args options) ~package)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl remove-package [#{:brew}] [package &amp; options]
  (&quot;brew&quot; uninstall ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl purge-package [#{:brew}] [package &amp; options]
  (&quot;brew&quot; uninstall ~(stevedore/option-args options) ~package))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript debconf-set-selections [&amp; selections])
(script/defimpl debconf-set-selections :default [&amp; selections] )
(script/defimpl debconf-set-selections [#{:aptitude :apt}] [&amp; selections]
  (&quot;{ debconf-set-selections&quot;
   ~(str &quot;&lt;&lt;EOF\n&quot; (string/join \newline selections) &quot;\nEOF\n}&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript package-manager-non-interactive [])
(script/defimpl package-manager-non-interactive :default [] )
(script/defimpl package-manager-non-interactive [#{:aptitude :apt}] []
  (~debconf-set-selections
   &quot;debconf debconf/frontend select noninteractive&quot;
   &quot;debconf debconf/frontend seen false&quot;))</pre></td></tr><tr><td class="docs"><p>Service functions</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript configure-service
  [name action options])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def debian-configure-option-names
     {:force :f})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn debian-options [options]
  (zipmap
   (map #(% debian-configure-option-names %) (keys options))
   (vals options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl configure-service :default [name action options]
  ~(condp = action
       :disable (stevedore/script
                 (&quot;update-rc.d&quot;
                  ~(stevedore/map-to-arg-string
                    (select-keys [:f :n] (debian-options options)))
                  ~name remove))
       :enable (stevedore/script
                (&quot;update-rc.d&quot;
                 ~(stevedore/map-to-arg-string
                   (select-keys [:n] (debian-options options)))
                 ~name defaults
                 ~(:sequence-start options 20)
                 ~(:sequence-stop options (:sequence-start options 20))))
       :start-stop (stevedore/script ;; start/stop
                    (&quot;update-rc.d&quot;
                     ~(stevedore/map-to-arg-string
                       (select-keys [:n] (debian-options options)))
                     ~name
                     start ~(:sequence-start options 20)
                     &quot;.&quot;
                     stop ~(:sequence-stop options (:sequence-start options 20))
                     &quot;.&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} chkconfig-default-options
  [20 2 3 4 5])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- chkconfig-levels
  [options]
  (-&gt;&gt; options (drop 1 ) (map str) string/join))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl configure-service [#{:yum}] [name action options]
  ~(condp = action
       :disable (stevedore/script (&quot;/sbin/chkconfig&quot; ~name off))
       :enable (stevedore/script
                (&quot;/sbin/chkconfig&quot;
                 ~name on
                 &quot;--level&quot; ~(chkconfig-levels
                             (:sequence-start
                              options chkconfig-default-options))))
       :start-stop (stevedore/script ;; start/stop
                    (&quot;/sbin/chkconfig&quot;
                     ~name on
                     &quot;--level&quot; ~(chkconfig-levels
                                 (:sequence-start
                                  options chkconfig-default-options))))))</pre></td></tr><tr><td class="docs"><p>Functions like clojure.java.io</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript file [&amp; args])
(script/defimpl file :default [&amp; args]
  (str ~@(interpose &quot;/&quot; args)))</pre></td></tr><tr><td class="docs"><p>Functions to return distribution specific paths.</p>

<p>These script functions are meant to help build distribution agnostic crates.
 * Links
  - man 7 hier
  - http://www.pathname.com/fhs/
  - http://wiki.apache.org/httpd/DistrosDefaultLayout</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript etc-default [])
(script/defimpl etc-default [#{:ubuntu :debian :jeos}] []
  &quot;/etc/default&quot;)
(script/defimpl etc-default [#{:centos :rhel :amzn-linux :fedora}] []
  &quot;/etc/sysconfig&quot;)
(script/defimpl etc-default [#{:os-x :darwin}] []
  &quot;/etc/defaults&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript log-root [])
(script/defimpl log-root :default []
  &quot;/var/log&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript state-root [])
(script/defimpl state-root :default []
  &quot;/var/lib&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript pid-root [])
(script/defimpl pid-root :default []
  &quot;/var/run&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript spool-root [])
(script/defimpl spool-root :default []
  &quot;/var/spool&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript config-root [])
(script/defimpl config-root :default []
  &quot;/etc&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript etc-hosts [])
(script/defimpl etc-hosts :default []
  &quot;/etc/hosts&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript etc-init [])
(script/defimpl etc-init :default [] &quot;/etc/init.d&quot;)
(script/defimpl etc-init [:pacman] [] &quot;/etc/rc.d&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript upstart-script-dir [])
(script/defimpl upstart-script-dir :default [] &quot;/etc/init&quot;)</pre></td></tr><tr><td class="docs"><p>Some of the packagers, like brew, are "add-ons" in the sense that they are
outside of the base system.  These paths refer to locations of packager
installed files.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript pkg-etc-default [])
(script/defimpl pkg-etc-default :default [] (~etc-default))
(script/defimpl etc-default [:brew] [] &quot;/usr/local/etc/default&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript pkg-log-root [])
(script/defimpl pkg-log-root :default [] (~log-root))
(script/defimpl pkg-log-root [:brew] [] &quot;/usr/local/var/log&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript pkg-pid-root [])
(script/defimpl pkg-pid-root :default [] (~pid-root))
(script/defimpl pkg-pid-root [:brew] [] &quot;/usr/local/var/run&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript pkg-config-root [])
(script/defimpl pkg-config-root :default [] (~config-root))
(script/defimpl pkg-config-root [:brew] [] &quot;/usr/local/etc&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript pkg-sbin [])
(script/defimpl pkg-sbin :default [] &quot;/sbin&quot;)
(script/defimpl pkg-sbin [:brew] [] &quot;/usr/local/sbin&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript system-environment [])
(script/defimpl system-environment :default [] &quot;/etc/environment&quot;)
(script/defimpl system-environment [#{:rhel :centos :fedora}] []
  &quot;/etc/profile.d&quot;)
(script/defimpl system-environment [#{:darwin :os-x}] [] &quot;/etc/profile&quot;)</pre></td></tr><tr><td class="docs"><h1>Flags</h1>

<p>Flags are used to communicate state from the node to the origin</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Register changed files</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript file-changed [path])
(script/defimpl file-changed :default [path]
  (assoc! changed_files path 1))</pre></td></tr><tr><td class="docs"><p>(script/defscript set-flag [path])
(script/defimpl set-flag :default [path]
  (assoc! flags_hash ~(name path) 1))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript set-flag [flag-name])
(script/defimpl set-flag :default [flag-name]
  (println &quot;SETFLAG:&quot; ~flag-name &quot;:SETFLAG&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript set-flag-value [flag-name flag-value])
(script/defimpl set-flag-value :default [flag-name flag-value]
  (println &quot;SETVALUE:&quot; ~flag-name ~flag-value &quot;:SETVALUE&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defscript flag? [path])
(script/defimpl flag? :default [path]
  (get flags_hash ~(name path)))</pre></td></tr><tr><td class="docs"><p>selinux</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Set the selinux file type</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript selinux-file-type
  [path type])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl selinux-file-type :default
  [path type]
  (if (&amp;&amp; (~has-command? chcon)
          (&amp;&amp; (directory? &quot;/etc/selinux&quot;)
              (&amp;&amp; (file-exists? &quot;/selinux/enforce&quot;)
                  (&quot;stat&quot; --format &quot;%C&quot; ~path &quot;2&gt;&amp;-&quot;))))
    (&quot;chcon&quot; -Rv ~(str &quot;--type=&quot; type) ~path)))</pre></td></tr><tr><td class="docs"><p>Set the selinux boolean value</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript selinux-bool
  [flag value &amp; {:keys [persist]}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(script/defimpl selinux-bool :default
  [flag value &amp; {:keys [persist]}]
  (if (&amp;&amp; (&amp;&amp; (~has-command? setsebool) (directory? &quot;/etc/selinux&quot;))
          (file-exists? &quot;/selinux/enforce&quot;))
    (&quot;setsebool&quot; ~(if persist &quot;-P&quot; ) ~(name flag) ~value)))</pre></td></tr><tr><td class="docs"><h2>Basic program locations</h2>
</td><td class="codes"><pre class="brush: clojure">(script/defscript sudo [&amp; {:keys [no-prompt user stdin]}])
(script/defimpl sudo :default [&amp; {:keys [no-prompt user stdin]}]
  (&quot;/usr/bin/sudo&quot;
   ~@(when no-prompt [&quot;-n&quot;])
   ~@(when user [&quot;-u&quot; user])
   ~@(when stdin [&quot;-S&quot;])) )</pre></td></tr><tr><td class="docs"><p>no support for -p</p>
</td><td class="codes"><pre class="brush: clojure">(script/defimpl sudo
  [#{:centos-5.3 :os-x :darwin :debian :fedora}]
  [&amp; {:keys [no-prompt user stdin]}]
  (&quot;/usr/bin/sudo&quot;
   ~@(when user [&quot;-u&quot; user])
   ~@(when stdin [&quot;-S&quot;])))</pre></td></tr><tr><td class="docs"><p>Call bash</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript bash
  [&amp; {:keys [login]}])
(script/defimpl bash :default [&amp; {:keys [login]}]
  (&quot;/bin/bash&quot;
   ~@(when login [&quot;-l&quot;])))</pre></td></tr><tr><td class="docs"><p>Return a sequence of name=var strings for the given <code>vars</code> map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn env-var-pairs
  [vars]
  (map
   (fn [[k v]] (format &quot;%s=\&quot;%s\&quot;&quot; (name k) v))
   vars))</pre></td></tr><tr><td class="docs"><p>Setup an environment for another cmd.  Vars is a map of name and value
  pairs.</p>
</td><td class="codes"><pre class="brush: clojure">(script/defscript env
  [&amp; {:keys [vars]}])
(script/defimpl env :default [&amp; {:keys [vars]}]
  (&quot;/usr/bin/env&quot; ~@(env-var-pairs vars)))</pre></td></tr><tr><td class="docs"><p>Returns a script expression that waits while test-expr is successful, using
a constant standoff (in seconds) and max-retries.</p>
</td><td class="codes"><pre class="brush: clojure">(defn wait-while
  [test-expr standoff max-retries waiting-msg failed-msg]
  (chained-script
   (group (chain-or (let x 0) true))
   (while ~test-expr
     (let x (+ x 1))
     (if (= ~max-retries @x)
       (do
         (println ~failed-msg &gt;&amp;2)
         (exit 1)))
     (println ~waiting-msg)
     (&quot;sleep&quot; ~standoff))
   (&quot;sleep&quot; ~standoff)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.script-builder" name="pallet.script-builder"><h1 class="project-name">pallet.script-builder</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Build scripts with prologues, epilogues, etc, and command lines for
   running them in different environments</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.script-builder
  (:require
   [clojure.tools.logging :refer [debugf]]
   [clojure.string :as string]
   [clojure.string :refer [split]]
   [pallet.script :refer [with-script-context *script-context*]]
   [pallet.script.lib
    :refer [bash env env-var-pairs exit heredoc make-temp-file mkdir rm sudo]]
   [pallet.stevedore :as stevedore]
   [pallet.stevedore :refer [fragment with-source-line-comments]]
   [pallet.stevedore.bash :refer [infix-operators]]))</pre></td></tr><tr><td class="docs"><p>keep slamhound from removing the pallet.stevedore.bash require</p>
</td><td class="codes"><pre class="brush: clojure">infix-operators

(defn prolog []  (str &quot;#!&quot; (fragment (env)) &quot; bash\n&quot;))
(def epilog &quot;\nexit $?&quot;)</pre></td></tr><tr><td class="docs"><p>The interprester used to run a script.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti interpreter
  (fn [{:keys [language]}] language))
(defmethod interpreter :default [_] nil)
(defmethod interpreter :bash [_] (split (fragment (bash)) #&quot; +&quot;))</pre></td></tr><tr><td class="docs"><p>Construct a sudo command prefix for the specified user.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sudo-cmd-for
  [{:keys [no-sudo password sudo-user sudo-password username] :as user}]
  (debugf
   &quot;sudo-cmd-for %s&quot;
   (select-keys user [:no-sudo :password :sudo-user :sudo-password :username]))
  (if (or (and (= username &quot;root&quot;) (not sudo-user))
          no-sudo)
    nil
    (str
     (if sudo-password
       (fragment
        (pipe
         (println (str &quot;'&quot; ~sudo-password &quot;'&quot;))
         (sudo :stdin true :user ~sudo-user)))
       (fragment
        (sudo :user ~sudo-user :no-prompt true))))))</pre></td></tr><tr><td class="docs"><p>Ensure that a :sudo-user specified in the action trumps a :no-sudo
  specified in the admin user.</p>
</td><td class="codes"><pre class="brush: clojure">(defn normalise-sudo-options
  [user action]
  (let [r (merge user action)]
    (if (:sudo-user action)
      (assoc r :no-sudo false)
      r)))</pre></td></tr><tr><td class="docs"><p>The executable used to prefix the interpreter (eg. sudo, chroot, etc).</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti prefix
  (fn [kw session action] kw))
(defmethod prefix :default [_ _ _] nil)
(defmethod prefix :sudo [_ session action]
  (debugf &quot;prefix sudo %s&quot; (into {} (merge (:user session) action)))
  (sudo-cmd-for (normalise-sudo-options (:user session) action)))</pre></td></tr><tr><td class="docs"><p>Builds a script. The script is wrapped in a shell script to set
up the working directory (and possibly environment variables in the
future).</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-script
  [{:keys [language version interpreter interpreter-args]
    :or {language :bash}
    :as options}
   script
   {:keys [script-dir script-trace script-hash]
    :or {script-hash true}
    :as action}]
  (str
   (prolog)
   (if script-dir
     (stevedore/script
      (chain-or (~mkdir ~script-dir :path true) (exit 1))
      (&quot;cd&quot; ~script-dir))
     &quot;&quot;)
   (if (and (= language :bash) script-trace)
     &quot;set -x\n&quot;
     &quot;&quot;)
   (if (and (= language :bash) script-hash)
     &quot;set -h\n&quot;
     &quot;set +h\n&quot;)
   (if (= language :bash)
     script
     (let [interpreter (or interpreter
                           (pallet.script-builder/interpreter options))]
       (stevedore/script
        (var t (str (~make-temp-file &quot;pallet&quot;) &quot;.&quot; ~language))
        (~heredoc @t ~script {:literal true})
        ((str ~interpreter) ~@interpreter-args @t)
        (var r @?)
        (rm @t)
        (exit @r))))
   epilog))</pre></td></tr><tr><td class="docs"><p>Builds a code map, describing the command to execute a script.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-code
  [session {:keys [default-script-prefix script-context script-dir script-env
                   script-env-fwd script-prefix sudo-user]
            :as action}
   &amp; args]
  (debugf
   &quot;%s&quot;
   (select-keys action
                [:default-script-prefix :script-dir :script-env :script-env-fwd
                 :script-prefix :sudo-user :script-context]))
  (debugf
   &quot;prefix kw %s&quot;
   (:script-prefix session (or script-prefix default-script-prefix :sudo)))
  (with-script-context (concat *script-context* script-context)
    (with-source-line-comments false
      {:env-cmd (fragment (env))
       :env (or script-env (:script-env session))
       :env-fwd (or script-env-fwd (:script-env-fwd session) [:SSH_AUTH_SOCK])
       :prefix (when-let [prefix (prefix
                                  (:script-prefix
                                   session
                                   (or script-prefix
                                       default-script-prefix
                                       :sudo))
                                  session
                                  action)]
                 (debugf &quot;prefix %s&quot; prefix)
                 (string/split prefix #&quot; &quot;))
       :execv (concat (interpreter {:language :bash}) args)})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.script-exec" name="pallet.script-exec"><h1 class="project-name">pallet.script-exec</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Script execution for pallet.
   Abstracts over transport, script environment, and the script itself</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.script-exec)</pre></td></tr><tr><td class="docs"><p>Transfer</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A transport needs to be able to transfer files</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Script Environment</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Run under given user (maybe with authentication details.
Run with a prefix command (e.g. use a chroot)
Run in a given directory
Is interpreter specific</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">    :transport {:protocol [:ssh]</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">    :transport {:protocol [:ssh]
                :user {:username, :password, :private-key, :public-key}}</pre></td></tr><tr><td class="docs"><p>Options
      :environment {:exec-prefix [:sudo]
                    :user
                    :directory
                    :env }
    :script    {:interpreter [:bash], :text}</p>
</td><td class="codes"><pre class="brush: clojure">(defn exec
  [{:as options}])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.session.action-plan" name="pallet.session.action-plan"><h1 class="project-name">pallet.session.action-plan</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Session specific action-plan functions.</p>

<p>Encapsulates the location of the action-plans in the session.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.session.action-plan)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def action-plan-key :action-plan)</pre></td></tr><tr><td class="docs"><p>Set the session action-plan</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-action-plan
  [session]
  (action-plan-key session))</pre></td></tr><tr><td class="docs"><p>Set the session action-plan</p>
</td><td class="codes"><pre class="brush: clojure">(defn assoc-action-plan
  [session action-plan]
  (assoc session action-plan-key action-plan))</pre></td></tr><tr><td class="docs"><p>Set the session action-plan</p>
</td><td class="codes"><pre class="brush: clojure">(defn dissoc-action-plan
  [session]
  (dissoc session action-plan-key))</pre></td></tr><tr><td class="docs"><p>Retrieves the current action plan, and resets it</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-session-action-plan
  [session]
  {:pre [(map? session)]}
  [(action-plan-key session) (dissoc session action-plan-key)])</pre></td></tr><tr><td class="docs"><p>Return the vector path of the action plan for the specified phase an
  target-id.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- target-path*
  [phase target-id]
  [:action-plans phase target-id])</pre></td></tr><tr><td class="docs"><p>Return the vector path of the action plan for the current session target
   node, or target group.</p>
</td><td class="codes"><pre class="brush: clojure">(defn target-path
  [session]
  {:pre [(keyword? (:phase session))
         (keyword? (:target-id session))]}
  (target-path* (:phase session) (-&gt; session :target-id)))</pre></td></tr><tr><td class="docs"><p>(defn mv-session-action-plan
  "Move the session action-plan into its target specific location"
  [session]
  (let [action-plan (action-plan-key session)]
    [action-plan
     (->
      session
      (assoc-in (target-path session) action-plan)
      (dissoc action-plan-key))]))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Session action plan update applier</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-action-plan
  [session f]
  (update-in session [action-plan-key] f))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.session.verify" name="pallet.session.verify"><h1 class="project-name">pallet.session.verify</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns pallet.session.verify
  (:require
   [pallet.common.context :refer [throw-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def session-verification-key :pallet.phase/session-verification)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-session-verification-key
  [session]
  (assoc session session-verification-key true))</pre></td></tr><tr><td class="docs"><p>Function that can check a session map to ensure it is a valid part of
   phase definition. It returns the session map.</p>

<p>   If this fails, then it is likely that you have an incorrect crate function
   which is failing to return its session map properly, or you have a non crate
   function in the phase definition.</p>
</td><td class="codes"><pre class="brush: clojure">(defn check-session
  ([session]
     ;; we do not use a precondition in order to improve the error message
     (when-not (and session (map? session) (session-verification-key session))
       (throw-map
        &quot;Invalid session map in phase. Check for non crate functions
      improper crate functions, or problems in threading the session map
      in your phase definition.
      A crate function is a function that takes a session map and other
      arguments, and returns a modified session map. Calls to crate functions
      are often wrapped in a threading macro, -&gt; or pallet.api/plan-fn
      to simplify chaining of the session map argument.&quot;
        {:type :invalid-session
         :session session}))
     session)
  ([session form]
     ;; we do not use a precondition in order to improve the error message
     (when-not (and session (map? session) (session-verification-key session))
       (throw-map
        (format
         (str
          &quot;Invalid session map in phase session.\n&quot;
          &quot;`session` is %s\n&quot;
          &quot;Problem probably caused in:\n  %s &quot;)
         session form)
        {:type :invalid-session
         :session session}))
     session))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.credentials" name="pallet.ssh.credentials"><h1 class="project-name">pallet.ssh.credentials</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for working with ssh credentials.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.credentials
  (:require
   [clj-ssh.ssh :refer [generate-keypair keypair ssh-agent]]
   [clojure.java.io :refer [file]]
   [clojure.tools.logging :refer [debugf error errorf warn]]))</pre></td></tr><tr><td class="docs"><p>Given a user map, returns a keyword indicating the credentials' status.</p>

<ul>
<li>:not-found</li>
<li>:private-key-not-found</li>
<li>:public-key-not-found</li>
<li>:invalid-key</li>
<li>:valid-key</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn ssh-credential-status
  [{:keys [password private-key private-key-path public-key-path] :as user}]
  (cond
   password
   :valid-credential
   private-key
   (try
     (if (keypair (ssh-agent {}) user)
       :valid-credential
       :invalid-key)
     (catch Exception e
       (debugf e &quot;Error when verifying keypair&quot;)
       :invalid-key))
   (and (not (.exists (file private-key-path)))
        (not (.exists (file public-key-path))))
   :not-found
   (and (.exists (file private-key-path))
        (not (.exists (file public-key-path))))
   :public-key-not-found
   (and (not (.exists (file private-key-path)))
        (.exists (file public-key-path)))
   :private-key-not-found
   :else
   (try
     (if (keypair (ssh-agent {}) user)
       :valid-credential
       :invalid-key)
     (catch Exception e
       (debugf e &quot;Error when verifying keypair&quot;)
       :invalid-key))))</pre></td></tr><tr><td class="docs"><p>Generate keypair files for the given user and options</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-keypair-files
  [{:keys [private-key-path public-key-path] :as user}
   {:keys [comment key-type key-size passphrase]
    :or {key-type :rsa key-size 2048}
    :as options}]
  {:pre [private-key-path public-key-path]}
  (generate-keypair
   (ssh-agent {}) key-type key-size passphrase
   :private-key-path private-key-path
   :public-key-path public-key-path
   :comment comment))</pre></td></tr><tr><td class="docs"><p>Given a user map, ensure credentials exist at the specified :private-key-path
  and :public-key-path.  Logs and prints any issues found with the credentials.</p>

<p>  Returns a keyword indicating the credentials' status.</p>

<ul>
<li>:not-found</li>
<li>:private-key-not-found</li>
<li>:public-key-not-found</li>
<li>:invalid-key</li>
<li>:valid-key</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn ensure-ssh-credential
  [{:keys [private-key-path public-key-path] :as user}
   {:keys [comment key-type key-size passphrase] :as options}]
  (case (ssh-credential-status user)
    :invalid-key
    (throw (ex-info &quot;Invalid key&quot; {:user user}))
    :not-found
    (let [msg (format &quot;keypair (%s, %s) does not exist&quot;
                      public-key-path private-key-path)]
      (println msg)
      (warn msg)
      (generate-keypair-files user options))
    :public-key-not-found
    (let [msg (format
               &quot;The public key path %s does not exist, but %s does.&quot;
               public-key-path private-key-path)]
      (println msg)
      (error msg)
      (throw (ex-info &quot;Invalid public key path&quot; {:user user})))
    :private-key-not-found
    (let [msg (format
               &quot;The private key path %s does not exist, but %s does.&quot;
               private-key-path public-key-path)]
      (println msg)
      (error msg)
      (throw (ex-info &quot;Invalid private key path&quot; {:user user})))
    :valid-credential nil))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.execute" name="pallet.ssh.execute"><h1 class="project-name">pallet.ssh.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Execution of pallet actions via ssh</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.execute
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.action-impl :refer [action-symbol]]
   [pallet.action-plan :refer [context-label]]
   [pallet.common.filesystem :as filesystem]
   [pallet.common.logging.logutils :as logutils]
   [pallet.core.session :refer [effective-username]]
   [pallet.core.user :refer [obfuscated-passwords]]
   [pallet.execute :as execute
    :refer [clean-logs log-script-output result-with-error-map]]
   [pallet.local.execute :as local]
   [pallet.node :as node]
   [pallet.script-builder :as script-builder]
   [pallet.script.lib :as lib]
   [pallet.script.lib
    :refer [chgrp chmod chown env exit mkdir path-group path-owner]]
   [pallet.stevedore :as stevedore :refer [fragment]]
   [pallet.transport :as transport]
   [pallet.transport.local]
   [pallet.transport.ssh]
   [pallet.utils :refer [log-multiline]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ssh-connection (transport/factory :ssh {}))
(def local-connection (transport/factory :local {}))</pre></td></tr><tr><td class="docs"><p>Return the user to use for authentication.  This is not necessarily the
  admin user (e.g. when bootstrapping, it is the image user).</p>
</td><td class="codes"><pre class="brush: clojure">(defn authentication
  [session]
  (logging/debugf &quot;authentication %s&quot; (obfuscated-passwords (:user session)))
  {:user (:user session)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn endpoint
  [session]
  (let [target-node (-&gt; session :server :node)
        proxy (node/proxy target-node)]
    (if proxy
      {:server (or (:host proxy &quot;localhost&quot;))
       :port (:port proxy)}
      {:server (node/node-address target-node)
       :port (node/ssh-port target-node)})))</pre></td></tr><tr><td class="docs"><p>Create a temporary remote file using the <code>ssh-session</code> and the filename
  <code>prefix</code></p>
</td><td class="codes"><pre class="brush: clojure">(defn- ssh-mktemp
  [connection prefix script-env]
  (logging/tracef &quot;ssh-mktemp %s&quot; (bean connection))
  (let [cmd (stevedore/script
             ((env ~@(mapcat identity script-env))
              (println
               (~lib/make-temp-file
                ~prefix
                :tmpdir ~(or (get script-env &quot;TMPDIR&quot;) true)))))
        result (transport/exec connection {:execv [cmd]} {})]
    (logging/tracef &quot;ssh-mktemp script-env %s&quot; script-env)
    (logging/tracef &quot;ssh-mktemp %s %s&quot; cmd result)
    (if (zero? (:exit result))
      (string/trim (result :out))
      (throw
       (ex-info
        (format &quot;Failed to generate remote temporary file %s&quot; (:err result))
        {:type :remote-execution-failure
         :exit (:exit result)
         :err (:err result)
         :out (:out result)})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-connection [session]
  (transport/open
   ssh-connection (endpoint session) (authentication session)
   {:max-tries 3}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn release-connection [session]
  (transport/release
   ssh-connection (endpoint session) (authentication session)
   {:max-tries 3}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:internal true} with-connection-exception-handler
  [e]
  (logging/errorf e &quot;SSH Error&quot;)
  (if-let [{:keys [type reason]} (ex-data e)]
    (if (and (= type :clj-ssh/open-channel-failure)
             (= reason :clj-ssh/channel-open-failed))
      {::retriable true ::exception e}
      (throw e))
    (throw e)))</pre></td></tr><tr><td class="docs"><p>Execute a function with a connection to the current target node,</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:internal true} with-connection*
  [session f]
  (loop [retries 1]
    (let [connection (get-connection session)
          r (f connection)]
      (if (map? r)
        (cond
         (and (::retriable r) (pos? retries))
         (do
           (release-connection session)
           (recur (dec retries)))
         (::retriable r) (throw (::exception r))
         :else r)
        r))))</pre></td></tr><tr><td class="docs"><p>Execute the body with a connection to the current target node,</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:indent 2} with-connection
  [session [connection] &amp; body]
  `(with-connection* ~session (fn [~connection]
                                (try
                                  ~@body
                                  (catch Exception e#
                                    (with-connection-exception-handler e#))))))</pre></td></tr><tr><td class="docs"><p>Execute a bash action on the target via ssh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ssh-script-on-target
  [session {:keys [context node-value-path] :as action} action-type
   [options script]]
  (logging/trace &quot;ssh-script-on-target&quot;)
  (logging/trace &quot;action %s options %s&quot; action options)
  (let [endpoint (endpoint session)]
    (logutils/with-context [:target (:server endpoint)]
      (logging/infof
       &quot;%s %s %s %s&quot;
       (:server endpoint) (:port endpoint)
       (or (context-label action) &quot;&quot;)
       (or (:summary options) &quot;&quot;))
      (with-connection session [connection]
        (let [authentication (transport/authentication connection)
              script (script-builder/build-script options script action)
              sudo-user (or (:sudo-user action)
                            (-&gt; authentication :user :sudo-user))
              tmpfile (ssh-mktemp
                       connection &quot;pallet&quot; (:script-env action))]
          (log-multiline :debug (str (:server endpoint) &quot; ==&gt; %s&quot;)
                         (str &quot; -----------------------------------------\n&quot;
                              script
                              &quot;\n------------------------------------------&quot;))
          (logging/debugf
           &quot;%s:%s send script via %s as %s&quot;
           (:server endpoint) (:port endpoint) tmpfile (or sudo-user &quot;root&quot;))
          (logging/debugf &quot;%s   &lt;== ----------------------------------------&quot;
                          (:server endpoint))
          (transport/send-text
           connection script tmpfile
           {:mode (if sudo-user 0644 0600)})
          (logging/trace &quot;ssh-script-on-target execute script file&quot;)
          (let [clean-f (clean-logs (:user authentication))
                cmd (script-builder/build-code session action tmpfile)
                _ (logging/debugf &quot;ssh-script-on-target command %s&quot; cmd)
                result (transport/exec
                        connection
                        cmd
                        {:output-f (log-script-output
                                    (:server endpoint) (:user authentication))
                         :agent-forwarding (:ssh-agent-forwarding action)
                         :pty (:ssh-pty action true)})
                [result session] (execute/parse-shell-result session result)
                result (update-in result [:out] clean-f)
                result (result-with-error-map
                        (:server endpoint) &quot;Error executing script&quot; result)
                ;; Set the node-value to the result of execution, rather than
                ;; the script.
                session (assoc-in
                         session [:plan-state :node-values node-value-path]
                         result)
                result (assoc result
                         :script (if (and (sequential? script)
                                          (map? (first script)))
                                   (update-in script [0] dissoc :summary)
                                   script)
                         :summary (when (and (sequential? script)
                                             (map? (first script)))
                                    (:summary options)))]
            (logging/trace &quot;ssh-script-on-target remove script file&quot;)
            (transport/exec
             connection {:execv [(fragment (&quot;rm&quot; -f ~tmpfile))]} {})
            (logging/trace &quot;ssh-script-on-target done&quot;)
            (logging/debugf &quot;%s   &lt;== ----------------------------------------&quot;
                            (:server endpoint))
            (when (:new-login-after-action action)
              (transport/close connection))
            [result session]))))))</pre></td></tr><tr><td class="docs"><p>Upload a file to a remote location via sftp</p>
</td><td class="codes"><pre class="brush: clojure">(defn- ssh-upload
  [session connection file remote-name]
  (logging/infof
   &quot;Transferring file %s from local to %s:%s&quot;
   file (:server (transport/endpoint connection)) remote-name)
  (if-let [dir (.getParent (io/file remote-name))]
    (let [  ; prefix (or (script-builder/prefix :sudo session nil) &quot;&quot;)
          user (-&gt; session :user :username)
          _ (logging/debugf
             &quot;Transfer: ensure dir %s with ownership %s&quot; dir user)
          {:keys [exit] :as rv} (transport/exec
                                 connection
                                 {:in (stevedore/script
                                       (mkdir ~dir :path true)
                                       ;; (~prefix (mkdir ~dir :path true))
                                       ;; (~prefix (chown ~user ~dir))
                                       (exit &quot;$?&quot;))}
                                 {})]
      (if (zero? exit)
        (transport/send-stream
         connection (io/input-stream file) remote-name {:mode 0600})
        (throw (ex-info
                (str &quot;Failed to create target directory &quot; dir)
                rv))))
    (transport/send-stream
     connection (io/input-stream file) remote-name {:mode 0600}))
  (let [effective-user (effective-username session)
        state-group (-&gt; session :user :state-group)]
    (cond
     state-group
     (do (logging/debugf &quot;Transfer: chgrp/mod %s %s&quot; state-group remote-name)
         (let [{:keys [exit out] :as rv}
               (transport/exec
                connection
                {:in (stevedore/script
                      (println &quot;group is &quot; @(path-group ~remote-name))
                      (println &quot;owner is &quot; @(path-owner ~remote-name))
                      (chain-and
                       (when-not (= @(path-group ~remote-name) ~state-group)
                         (chgrp ~state-group ~remote-name))
                       (chmod &quot;0666&quot; ~remote-name))
                      (exit &quot;$?&quot;))}
                {})]
           (when-not (zero? exit)
             (throw (ex-info
                     (str &quot;Failed to chgrp/mod uploaded file &quot; remote-name
                          &quot;.  &quot; out)
                     rv)))))
     (not= effective-user (-&gt; session :user :username))
     (do (logging/debugf &quot;Transfer: chown %s %s&quot; effective-user remote-name)
         (let [{:keys [exit out] :as rv}
               (transport/exec
                connection
                {:in (stevedore/script
                      (println &quot;group is &quot; @(path-group ~remote-name))
                      (println &quot;owner is &quot; @(path-owner ~remote-name))
                      (if-not (= @(path-owner ~remote-name) ~effective-user)
                        (chown ~effective-user ~remote-name))
                      (exit &quot;$?&quot;))}
                {})]
           (when-not (zero? exit)
             (throw (ex-info
                     (str &quot;Failed to chown uploaded file &quot; remote-name
                          &quot;.  &quot; out)
                     rv))))))))</pre></td></tr><tr><td class="docs"><p>Transfer a file from the origin machine to the target via ssh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ssh-from-local
  [session value]
  (logging/tracef &quot;ssh-from-local %s&quot; value)
  (logging/tracef &quot;ssh-from-local %s&quot; session)
  (assert (-&gt; session :server) &quot;Target server in session&quot;)
  (assert (-&gt; session :server :node) &quot;Target node in session&quot;)
  (with-connection session [connection]
    (let [endpoint (transport/endpoint connection)]
      (let [[file remote-name remote-md5-name] value]
        (logging/debugf
         &quot;Remote file %s:%s from %s&quot; (:server endpoint) remote-md5-name file)
        (let [md5 (try
                    (filesystem/with-temp-file [md5-copy]
                      (transport/receive
                       connection remote-md5-name (.getPath md5-copy))
                      (slurp md5-copy))
                    (catch Exception _ nil))]
          (if md5
            (filesystem/with-temp-file [local-md5-file]
              (logging/debugf &quot;Calculating md5 for %s&quot; file)
              (local/local-script
               ((~lib/md5sum ~file) &quot;&gt;&quot; ~(.getPath local-md5-file))
               (~lib/normalise-md5 ~(.getPath local-md5-file)))
              (let [local-md5 (slurp local-md5-file)]
                (logging/debugf
                 &quot;md5 check - remote: %s local: %s&quot; md5 local-md5)
                (if (not=
                     (first (string/split md5 #&quot; &quot;))
                     (first (string/split local-md5 #&quot; &quot;)) )
                  (ssh-upload session connection file remote-name)
                  (logging/infof
                   &quot;%s:%s is already up to date&quot;
                   (:server endpoint) remote-name))))
            (ssh-upload session connection file remote-name))))
      [value session])))</pre></td></tr><tr><td class="docs"><p>Transfer a file from the target machine to the origin via ssh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ssh-to-local
  [session value]
  (with-connection session [connection]
    (let [[remote-file local-file] value]
      (logging/infof
       &quot;Transferring file %s from node to %s&quot; remote-file local-file)
      (transport/receive connection remote-file local-file))
    [value session]))</pre></td></tr><tr><td class="docs"><p>Execute the body with an ssh-tunnel available for the ports given in the
   tunnels map. Automatically closes port forwards on completion.</p>

<p>   Tunnels should be a map from local ports (integers) to either
     1) An integer remote port. Remote host is assumed to be "localhost".
     2) A vector of remote host and remote port. eg, ["yahoo.com" 80].</p>

<p>   e.g.
        (with-ssh-tunnel session {2222 22}
           ;; do something on local port 2222
           session)</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-ssh-tunnel
  [transport session tunnels &amp; body]
  `(let [{:as connection#} (get-connection ~session)]
     (transport/with-ssh-tunnel
       connection# ~tunnels
       ~@body)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.file-upload.sftp-upload" name="pallet.ssh.file-upload.sftp-upload"><h1 class="project-name">pallet.ssh.file-upload.sftp-upload</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation of file upload using SFTP.</p>

<p>  This assumes that chown/chgrp/chmod are all going to work.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.file-upload.sftp-upload
  (:require
   [clojure.java.io :refer [input-stream]]
   [clojure.string :refer [blank?]]
   [clojure.tools.logging :refer [debugf]]
   [pallet.common.filesystem :as filesystem]
   [pallet.script.lib
    :refer [chgrp chmod chown dirname env exit file mkdir path-group
            path-owner user-home]]
   [pallet.ssh.execute :refer [with-connection]]
   [pallet.core.file-upload :refer [file-uploader]]
   [pallet.core.file-upload.protocols :refer [FileUpload]]
   [pallet.core.session :refer [admin-user]]
   [pallet.stevedore :refer [fragment]]
   [pallet.transport :as transport]
   [pallet.utils :refer [base64-md5]])
  (:import
   [java.security MessageDigest DigestInputStream]
   [org.apache.commons.codec.binary Base64]))</pre></td></tr><tr><td class="docs"><p>Return a tuple containing a MessageDigest and a DigestInputStream.</p>
</td><td class="codes"><pre class="brush: clojure">(defn md5-digest-input-stream
  [str]
  (let [md (MessageDigest/getInstance &quot;MD5&quot;)]
    [md (DigestInputStream. str md)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^String md5 [path]
  (let [[^java.security.MessageDigest md s]
        (md5-digest-input-stream (input-stream path))
        buffer-size 1024
        buffer (make-array Byte/TYPE buffer-size)]
    (with-open [s s]
      (loop []
        (let [size (.read s buffer)]
          (when (pos? size)
            (recur)))))
    (Base64/encodeBase64URLSafeString (.digest md))))</pre></td></tr><tr><td class="docs"><p>Return the upload directory for username. A :home at the start of the
  upload directory will be replaced by the user's home directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn upload-dir
  [upload-root username]
  (if (.startsWith upload-root &quot;:home&quot;)
    (let [path-rest (subs upload-root 5)]
      (if (blank? path-rest)
        (fragment (user-home ~username))
        (fragment (str (user-home ~username) ~path-rest))))
    (str upload-root &quot;/&quot; username)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn target
  [upload-root username target-path]
  (str (upload-dir upload-root username)  &quot;/&quot; (base64-md5 target-path)))</pre></td></tr><tr><td class="docs"><p>Ensure directory exists</p>
</td><td class="codes"><pre class="brush: clojure">(defn sftp-ensure-dir
  [connection target-path]
  (debugf &quot;sftp-ensure-dir %s:%s&quot;
          (:server (transport/endpoint connection)) target-path)
  (let [dir (fragment @(dirname ~target-path))
        {:keys [exit] :as rv} (do
                                (debugf &quot;Transfer: ensure dir %s&quot; dir)
                                (transport/exec
                                 connection
                                 {:in (fragment
                                       (mkdir ~dir :path true)
                                       (chmod &quot;0700&quot; ~dir)
                                       (exit &quot;$?&quot;))}
                                 {}))]
    (when-not (zero? exit)
      (throw (ex-info
              (str &quot;Failed to create target directory &quot; dir &quot;. &quot; (:out rv))
              {:type :pallet/upload-fail
               :status rv})))))</pre></td></tr><tr><td class="docs"><p>Upload a file via SFTP</p>
</td><td class="codes"><pre class="brush: clojure">(defn sftp-upload-file
  [connection local-path target-path]
  (debugf &quot;sftp-upload-file %s:%s from %s&quot;
          (:server (transport/endpoint connection))
          target-path local-path)
  (transport/send-stream
       connection
       (input-stream local-path)
       target-path
       {:mode 0600}))</pre></td></tr><tr><td class="docs"><p>Return the md5 for a remote file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sftp-remote-md5
  [connection md5-path]
  (try
    (filesystem/with-temp-file [md5-copy]
      (transport/receive connection md5-path (.getPath md5-copy))
      (slurp md5-copy))
    (catch Exception _ nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sftp-put-md5
  [connection path md5]
  (transport/send-text connection md5 path {:mode 0600}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord SftpUpload [upload-root]
  FileUpload
  (upload-file-path [_ session target-path action-options]
    (target upload-root (-&gt; session :user :username) target-path))
  (user-file-path [_ session target-path action-options username]
    (target upload-root username target-path))
  (upload-file
    [_ session local-path target-path action-options]
    (let [target (target upload-root (-&gt; session :user :username) target-path)
          target-md5-path (str target &quot;.md5&quot;)]
      (with-connection session [connection]
        (let [target-md5 (sftp-remote-md5 connection target-md5-path)
              local-md5 (md5 local-path)]
          (when-not (= target-md5 local-md5)
            (sftp-ensure-dir connection target)
            (sftp-upload-file connection local-path target)
            (sftp-put-md5 connection target-md5-path local-md5)))))))</pre></td></tr><tr><td class="docs"><p>Create an instance of the SFTP upload strategy.</p>
</td><td class="codes"><pre class="brush: clojure">(defn sftp-upload
  [{:keys [upload-root] :as options}]
  (map-&gt;SftpUpload (merge
                    {:upload-root &quot;/tmp&quot;}
                    options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod file-uploader :sftp
  [_ options]
  (sftp-upload options))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.node-state" name="pallet.ssh.node-state"><h1 class="project-name">pallet.ssh.node-state</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Node state tracking</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.node-state
  (:require
   [pallet.ssh.node-state.protocols :as impl]))</pre></td></tr><tr><td class="docs"><p>Notify that path has been modified.
    Options include, :versioning, :no-versioning, :max-versions</p>
</td><td class="codes"><pre class="brush: clojure">(defn new-file-content
  [ns session path options]
  (impl/new-file-content ns session path options))</pre></td></tr><tr><td class="docs"><p>Verify the expected MD5 of the file at path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn verify-checksum
  [ns session path]
  (impl/verify-checksum ns session path))</pre></td></tr><tr><td class="docs"><p>Save the MD5 for the file at path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn record-checksum
  [ns session path]
  (impl/record-checksum ns session path))</pre></td></tr><tr><td class="docs"><p>Instantiate a file-backup provider based on keyword and option map.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti file-backup
  (fn [kw options] kw))</pre></td></tr><tr><td class="docs"><p>Instantiate a file-checksum provider based on keyword and option map.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti file-checksum
  (fn [kw options] kw))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.node-state.no-state" name="pallet.ssh.node-state.no-state"><h1 class="project-name">pallet.ssh.node-state.no-state</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A node-state implementation that maintains no node state</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.node-state.no-state
  (:require
   [pallet.ssh.node-state :refer [file-backup file-checksum]]
   [pallet.ssh.node-state.protocols :refer [FileBackup FileChecksum]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord NoBackup []
  FileBackup
  (new-file-content [_ session path options]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord NoChecksum []
  FileChecksum
  (verify-checksum [_ session path])
  (record-checksum [_ session path]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn no-backup []
  (NoBackup.))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn no-checksum []
  (NoChecksum.))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod file-backup :no-state
  [_ options]
  (no-backup))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod file-checksum :no-state
  [_ options]
  (no-checksum))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.node-state.protocols" name="pallet.ssh.node-state.protocols"><h1 class="project-name">pallet.ssh.node-state.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Protocols for node state updates</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.node-state.protocols)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol FileBackup
  (new-file-content [_ session path options]
    &quot;Notify that path has been modified.
    Options include, :versioning, :no-versioning, :max-versions&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol FileChecksum
  (verify-checksum [_ session path]
    &quot;Verify the expected MD5 of the file at path.&quot;)
  (record-checksum [_ session path]
    &quot;Save the MD5 for the file at path.&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.node-state.state-root" name="pallet.ssh.node-state.state-root"><h1 class="project-name">pallet.ssh.node-state.state-root</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A node-state implementation that maintains node state in a parallel directory
  tree.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.node-state.state-root
  (:require
   [pallet.actions.direct.file :as file]
   [pallet.core.session :refer [admin-user]]
   [pallet.script.lib :as lib
    :refer [canonical-path cat chgrp chmod chown cp diff dirname exit file ls
            md5sum md5sum-verify mkdir path-group path-mode path-owner rm
            tail user-home xargs]]
   [pallet.ssh.node-state :refer [file-backup file-checksum]]
   [pallet.ssh.node-state.protocols :refer [FileBackup FileChecksum]]
   [pallet.stevedore :refer [chain-commands chained-script fragment script]]))</pre></td></tr><tr><td class="docs"><p>Provide a computed default for state-root if it isn't set.</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-state-root
  []
  (fragment (file (lib/state-root) &quot;pallet&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- adjust-root
  [session ^String script-dir ^String path]
  (if (or (.startsWith path &quot;/&quot;)
          (.startsWith path &quot;$&quot;)
          (.startsWith path &quot;`&quot;))
    path
    (fragment
     (file ~(or script-dir
                (user-home (:username (admin-user session))))
           ~path))))</pre></td></tr><tr><td class="docs"><p>Return a path under state-root for a given path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn state-path*
  [session state-root script-dir path]
  (str state-root (adjust-root session script-dir path)))</pre></td></tr><tr><td class="docs"><p>Return a path under state-root for a given path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn state-path
  [session state-root path]
  (state-path* session
               (or state-root (default-state-root))
               (fragment @(&quot;pwd&quot;))
               path))</pre></td></tr><tr><td class="docs"><p>Return a path for the md5 file for state-path under state-root.</p>
</td><td class="codes"><pre class="brush: clojure">(defn md5-path
  [state-path]
  (str state-path &quot;.md5&quot;))</pre></td></tr><tr><td class="docs"><p>Create the /var/lib/pallet directory if required, ensuring correct
permissions. Note this is not the final directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-path-with-template
  [template-path new-path]
  (script
   (&quot;: &quot;)
   (&quot;#&quot; &quot;-- START pallet implementation function&quot;)
   (defn set_tree_permissions [template_path new_path]
     (set! dirpath @(dirname @new_path))
     (set! templatepath @(dirname @(if (file-exists? @template_path)
                                     (canonical-path @template_path)
                                     (println @template_path))))
     (when (not (directory? @templatepath))
       (println @templatepath &quot;: Directory does not exist.&quot;)
       (exit 1))
     (set! templatepath @(canonical-path @templatepath))
     (chain-or (mkdir @dirpath :path true) (exit 1))
     (&quot;while&quot; (!= &quot;/&quot; @templatepath) &quot;;do&quot;
      ~(chained-script
        (set! d @dirpath)        ; copy these and update
        (set! t @templatepath)   ; so we can continue on any failure
        (when (not (directory? @templatepath))
          (println @templatepath &quot;: Directory does not exist.&quot;)
          (exit 1))
        (set! dirpath @(dirname @dirpath))
        (set! templatepath @(dirname @templatepath))
        (if (not (== @(path-group @t) @(path-group @d)))
          (chgrp @(path-group @t) @d))
        (if (not (== @(path-mode @t) @(path-mode @d)))
          (chmod @(path-mode @t) @d))
        (if (not (== @(path-owner @t) @(path-owner @d)))
          (chown @(path-owner @t) @d)))
      (&quot;; done&quot;)))
   (&quot;#&quot; &quot;-- END pallet implementation function&quot;)
   (&quot;set_tree_permissions&quot; ~template-path ~new-path)))</pre></td></tr><tr><td class="docs"><p>verify if the files at path and state-path are identical, and
  whether they match the md5-path.</p>
</td><td class="codes"><pre class="brush: clojure">(defn verify
  [path state-path md5-path]
  (script
   (&quot;: &quot;)
   (&quot;#&quot; &quot;-- START pallet implementation function&quot;)
   (defn verify_md5 [path state_path md5_path]
     (chain-and
      ;; check if the file and the current copy are the same
      (var filediff &quot;&quot;)
      (if (&amp;&amp; (file-exists? @path) (file-exists? @state_path))
        (do
          (diff @path @state_path :unified true)
          (set! filediff &quot;$?&quot;)))
      ;; check if the current copy and the md5 match
      (var md5diff &quot;&quot;)
      (if (&amp;&amp; (file-exists? @state_path) (file-exists? @md5_path))
        (do
          (md5sum-verify @md5_path)
          (set! md5diff &quot;$?&quot;)))
      ;; report any errors
      (var errexit 0)
      (if (== @filediff 1)
        (do
          (println
           &quot;Existing file did not match the pallet master copy: FAIL&quot;)
          (set! errexit 1)))
      (if (== @md5diff 1)
        (do
          (println &quot;Existing content did not match md5: FAIL&quot;)
          (set! errexit 1)))
      ;; exit if error
      (== @errexit 0)))
   (&quot;#&quot; &quot;-- END pallet implementation function&quot;)
   (&quot;verify_md5&quot; ~path ~state-path ~md5-path)))</pre></td></tr><tr><td class="docs"><p>Script to record a new (version of a) file in state-root</p>
</td><td class="codes"><pre class="brush: clojure">(defn record
  [path state-path {:keys [max-versions no-versioning versioning]
                    :or {max-versions 5
                         versioning :numbered}}]
  (script
   (&quot;: &quot;)
   (&quot;#&quot; &quot;-- START pallet implementation function&quot;)
   (defn record_file [path state_path]
     (chain-and
      ;; output the diff between current and new
      (var contentdiff &quot;&quot;)
      (if (&amp;&amp; (file-exists? @path) (file-exists? @state_path))
        (do
          (diff @path @state_path :unified true)
          (set! contentdiff &quot;$?&quot;)))
      ;; install the file if the content is different
      (if (file-exists? @path)
        (if (not (== @contentdiff 0))
          (cp @path @state_path :force ~true :backup ~versioning)))
      ;; cleanup backup copies
      ~(if (and (not no-versioning) (pos? max-versions))
         (script
          (pipe
           ((ls (str @state_path &quot;.~[0-9]*~&quot;) :sort-by-time ~true)
            &quot;2&gt;&quot; &quot;/dev/null&quot;)
           (tail &quot;&quot; :max-lines ~(str &quot;+&quot; (inc max-versions)))
           (xargs (rm &quot;&quot; :force ~true))))
         &quot;&quot;)))
   (&quot;#&quot; &quot;-- END pallet implementation function&quot;)
   (&quot;record_file&quot; ~path ~state-path )))</pre></td></tr><tr><td class="docs"><p>Script to record a file's md5</p>
</td><td class="codes"><pre class="brush: clojure">(defn record-md5
  [path md5-path]
  ;; write the md5 file
  (script
   (&quot;: &quot;)
   (&quot;#&quot; &quot;-- START pallet implementation function&quot;)
   (defn record_md5 [path md5_path]
     (chain-and
      (file/write-md5-for-file @path @md5_path)
      (println &quot;MD5 sum is&quot; @(cat @md5_path))))
   (&quot;#&quot; &quot;-- END pallet implementation function&quot;)
   (&quot;record_md5&quot; ~path ~md5-path)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord StateRootBackup [state-root]
  FileBackup
  (new-file-content
    [_ session path options]
    ;; create the state-root dir
    (let [state-path (state-path session state-root path)]
      (chain-commands
       (create-path-with-template path state-path)
       (record path state-path options)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord StateRootChecksum [state-root]
  FileChecksum
  (verify-checksum [_ session path]
    (let [state-path (state-path session state-root path)]
      (verify path state-path (md5-path state-path))))
  (record-checksum [_ session path]
    (let [state-path (state-path session state-root path)]
      (create-path-with-template path state-path)
      (record-md5 path (md5-path state-path)))))</pre></td></tr><tr><td class="docs"><p>Return a state-root backup instance that can keep backups.</p>
</td><td class="codes"><pre class="brush: clojure">(defn state-root-backup
  [{:keys [state-root] :as options}]
  (map-&gt;StateRootBackup options))</pre></td></tr><tr><td class="docs"><p>Return a state-root checksum instance that can verify md5 checksums.</p>
</td><td class="codes"><pre class="brush: clojure">(defn state-root-checksum
  [{:keys [state-root] :as options}]
  (map-&gt;StateRootChecksum options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod file-backup :state-root
  [_ options]
  (state-root-backup options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod file-checksum :state-root
  [_ options]
  (state-root-checksum options))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.ssh.script-upload.protocols" name="pallet.ssh.script-upload.protocols"><h1 class="project-name">pallet.ssh.script-upload.protocols</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Protocols for uploading scripts to be run on the remote machine</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.ssh.script-upload.protocols)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ScriptUpload
  (upload-file [_ local-path target-path file-options action-options]
    &quot;Upload a file to the target-path, and return any script needed to
    be run on the node to get the file into place.
    file-options is a map of options as passed to remote-file, for file
    ownership, permissions, etc.
    action-options can contain a :sudo-user, specify the user to install
    the file as.&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.strint" name="pallet.strint"><h1 class="project-name">pallet.strint</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Runtime string interpolation built on top of clojure.contrib.strint.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.strint
  (:require
   [clojure.walk :refer [prewalk-replace]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(require 'pallet.common.strint)         ; prevent slamhound from removing this</pre></td></tr><tr><td class="docs"><p>Capture the values of the specified symbols in a symbol->value map.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro capture-values
  [&amp; values]
  (into {} (map (fn [s] [ `'~s s]) values)))</pre></td></tr><tr><td class="docs"><p>Interpolate a string given a map of symbol->value</p>
</td><td class="codes"><pre class="brush: clojure">(defn &lt;&lt;!
  [f value-map]
  (apply str
         (map (fn [x] (if (symbol? x)
                            (value-map x)
                            (if (seq x)
                              (eval (prewalk-replace value-map x))
                              x)))
                  (#'pallet.common.strint/interpolate f))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task" name="pallet.task"><h1 class="project-name">pallet.task</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Task helpers, that do not have any dependencies in pallet.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(let [{:keys [major minor]} *clojure-version*]
  (when (and (= major 1) (&lt; minor 4))
    (throw (Exception. &quot;Pallet requires at least clojure 1.4.0&quot;))))</pre></td></tr><tr><td class="docs"><p>Report a message to <em>err</em>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn report-error
  [msg]
  (binding [*out* *err*]
    (println msg)))</pre></td></tr><tr><td class="docs"><p>Abort a task, with the specified error message, and no stack trace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn abort
  [msg]
  (report-error msg)
  (throw (ex-info msg {:exit-code 1})))</pre></td></tr><tr><td class="docs"><p>Convert the given symbol-string into a namespace qualified symbol.
   Returns a vector of ns and symbol</p>
</td><td class="codes"><pre class="brush: clojure">(defn parse-as-qualified-symbol
  [^String symbol-string]
  {:pre [(string? symbol-string)]}
  (when (re-matches #&quot;[^/]+/[^/]+&quot; symbol-string)
    (when-let [sym (symbol symbol-string)]
      [(symbol (namespace sym)) sym])))</pre></td></tr><tr><td class="docs"><p>Try and resolve a symbol-string to a var value</p>
</td><td class="codes"><pre class="brush: clojure">(defn maybe-resolve-symbol-string
  [symbol-string]
  (when-let [[ns sym] (parse-as-qualified-symbol symbol-string)]
    (try
      (require ns)
      (when-let [v (find-var sym)]
        (var-get v))
      (catch java.io.FileNotFoundException e
        nil))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.add-service" name="pallet.task.add-service"><h1 class="project-name">pallet.task.add-service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Add a service definition to pallet.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.add-service
  (:require
   [clojure.java.io :as io]
   [pallet.compute :as compute]
   [pallet.configure :refer [config-file-path]]
   [pallet.task.config :refer [write-config-clj-unless-exists]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn warn-on-invalid-provider-name
  [provider-name available-services]
  (if (not (and provider-name (some #(= provider-name %) available-services)))
    (do
      (println &quot;WARNING:&quot; provider-name &quot;is not an available provider&quot;)
      (println &quot;         Currently loaded providers are:&quot;)
      (doseq [provider available-services]
        (println &quot;           &quot; provider))
      (println &quot;Try adding &quot; (str &quot;org.jclouds/&quot; provider-name)
               &quot;or org.jclouds/jclouds-all as a dependency if you can not see&quot;
               &quot;the provider you want. Writing configuration file with&quot;
               &quot;specified provider anyway.&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn write-service
  [^java.io.File file service-name provider-name identity credential]
  (.. (java.io.File. (.getParent file)) mkdirs)
  (spit file (pr-str {(keyword service-name)
                      (into {}
                            (filter val {:provider provider-name
                                         :identity identity
                                         :credential credential}))})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-service*
  [file service-name provider-name identity credential]
  (let [service-name (name service-name)
        available-services (compute/supported-providers)]
    (warn-on-invalid-provider-name provider-name available-services)
    (write-service file service-name provider-name identity credential)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn usage []
  (binding [*out* *err*]
    (println &quot;incorrect arguments:&quot;)
    (println &quot;  lein pallet service-name provider-name [identity credential]&quot;)))</pre></td></tr><tr><td class="docs"><p>Add a service provider definition to your pallet configuration.
This will create ~/.pallet/services/service-name.clj</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-service
  {:no-service-required true
   :help-arglists '[[service-name provider-name? identity? credential?]]}
  ([options service-name]
     (add-service options service-name service-name))
  ([options service-name provider-name]
     (add-service options service-name provider-name nil nil))
  ([_ service-name provider-name identity credential]
     (write-config-clj-unless-exists)
     (if (and service-name provider-name)
       (let [service-name (name service-name)
             path (io/file
                   (.getParent
                    (config-file-path)) &quot;services&quot; (str service-name &quot;.clj&quot;))]
         (if (.exists path)
           (do
             (println
              &quot;Service configuration file&quot; (.getPath path) &quot;already exists&quot;)
             1)
           (add-service*
            path service-name
            (name provider-name)
            (and identity (name identity))
            (and credential (name credential)))))
       (usage))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.bootstrap" name="pallet.task.bootstrap"><h1 class="project-name">pallet.task.bootstrap</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Bootstrap pallet to work with the specified provider.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.bootstrap
  (:require
   [pallet.task :refer [abort]]
   [pallet.task-utils :refer [create-pallet-project]]))</pre></td></tr><tr><td class="docs"><p>Bootstrap</p>
</td><td class="codes"><pre class="brush: clojure">(defn bootstrap
  {:no-service-required true
   :help-arglists '[[provider?]]}
  ([{:keys [project] :as request} provider-name]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.config" name="pallet.task.config"><h1 class="project-name">pallet.task.config</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Create a pallet configuration file in ~/.pallet/config.clj</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.config
  (:require
   [pallet.configure :refer [config-file-path]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn write-config-clj
  [^java.io.File file]
  (.mkdirs (.getParentFile file))
  (spit file
        &quot;(defpallet
  ;; You can specify a default service to be used
  ;; :default-service :vmfest
  ;; you can specify global data in the :environment key here
  ;; :environment {:proxy \&quot;http://192.168.1.37:3128\&quot;})&quot;))</pre></td></tr><tr><td class="docs"><p>Write a config.clj file if one doesn't exist. Returns true if it actually
  writes</p>
</td><td class="codes"><pre class="brush: clojure">(defn write-config-clj-unless-exists
  []
  (let [file (config-file-path)]
    (if (.exists file)
      false
      (do
        (write-config-clj file)
        true))))</pre></td></tr><tr><td class="docs"><p>Create a pallet configuration file in ~/.pallet/config.clja</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:no-service-required true
        :help-arglists '([])}
  config
  [&amp; _]
  (when-not (write-config-clj-unless-exists)
    (println &quot;config file already exists at&quot; (.getPath (config-file-path))))
  0)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.containers" name="pallet.task.containers"><h1 class="project-name">pallet.task.containers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>List containers.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.containers
  (:require
   [pallet.blobstore :as blobstore]))</pre></td></tr><tr><td class="docs"><p>List containers.</p>
</td><td class="codes"><pre class="brush: clojure">(defn containers
  [request &amp; args]
  (doseq [container (blobstore/containers (:blobstore request))
          :let [container (bean container)
                location (-&gt; container :location)]]
    (println
     (format
      &quot;\t%20s  %s&quot;
      (:name container) (.getDescription location)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.converge" name="pallet.task.converge"><h1 class="project-name">pallet.task.converge</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Adjust node counts.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.converge
  (:require
   [clojure.pprint :refer [print-table]]
   [clojure.stacktrace :refer [print-cause-trace]]
   [clojure.tools.logging :as logging]
   [pallet.algo.fsmop :refer [complete? wait-for]]
   [pallet.api :as api]
   [pallet.api :refer [print-targets]]
   [pallet.core.primitives :refer [phase-errors]]
   [pallet.task :refer [abort maybe-resolve-symbol-string]]
   [pallet.task-utils :refer [pallet-project project-groups]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [^String a (first args)]
      (let [v (maybe-resolve-symbol-string a)]
        (cond
          ;; non symbol as first arg
          (and (nil? m) (not v)) (recur (next args) a m phases)
          ;; a symbol number pair
          (not (.startsWith a &quot;:&quot;))
          (if v
            (let [n (read-string (fnext args))]
              (when-not (number? n)
                (abort
                 (format
                  &quot;Could not determine number of nodes for %s (%s given)&quot;
                  a (fnext args))))
              (recur (nnext args) prefix (assoc (or m {}) v n) phases))
            (abort
             (str &quot;Could not locate node definition for &quot; a)))
          ;; a phase
          :else (recur (next args) prefix m (conj phases (read-string a)))))
      (concat [m] (if prefix [:prefix prefix] []) [:phase phases]))))</pre></td></tr><tr><td class="docs"><p>Adjust node counts.  Requires a map of node-type, count pairs.
     eg. pallet converge mynodes/my-node 1
   The node-types should be namespace qualified.</p>
</td><td class="codes"><pre class="brush: clojure">(defn converge
  [{:keys [compute project] :as request} &amp; args]
  (let [[spec &amp; args] (build-args args)
        spec (or spec
                 (project-groups (pallet-project project) compute nil))]
    (logging/debugf &quot;converge %s&quot; (pr-str spec))
    (when-not spec
      (throw (ex-info &quot;Converge with no group specified&quot; {:args args})))
    (let [op (apply api/converge
                    spec
                    :async true
                    (concat
                     args
                     (apply concat
                            (-&gt;
                             request
                             (dissoc :config :project)
                             (assoc :environment
                               (or (:environment request)
                                   (-&gt; request :project :environment)))))))]
      (wait-for op)
        (if (complete? op)
          (print-targets @op)
          (do
            (println &quot;An error occured&quot;)
            (when-let [e (:exception @op)]
              (print-cause-trace e))
            (when-let [e (seq (phase-errors op))]
              (print-table (-&gt;&gt; e (map :error) (map #(dissoc % :type)))))
            (println &quot;See logs for further details&quot;))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.describe-node" name="pallet.task.describe-node"><h1 class="project-name">pallet.task.describe-node</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Describe the node definition.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.describe-node
  (:require
   [clojure.pprint :refer [pprint]]
   [pallet.task :refer [maybe-resolve-symbol-string]]))</pre></td></tr><tr><td class="docs"><p>Display the node definition for the given node-types.</p>
</td><td class="codes"><pre class="brush: clojure">(defn describe-node
  {:no-service-required true}
  [&amp; args]
  (doseq [arg (map maybe-resolve-symbol-string args)]
    (pprint arg)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.down" name="pallet.task.down"><h1 class="project-name">pallet.task.down</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Remove project nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.down
  (:require
   [clojure.pprint :refer [print-table]]
   [clojure.stacktrace :refer [print-cause-trace]]
   [pallet.algo.fsmop :refer [complete? wait-for]]
   [pallet.api :as api]
   [pallet.core.primitives :refer [phase-errors]]
   [pallet.task-utils :refer [pallet-project process-args project-groups]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def switches
  [[&quot;-s&quot; &quot;--selectors&quot; &quot;A comma separated list of selectors&quot;
    :default &quot;default&quot;]
   [&quot;-g&quot; &quot;--groups&quot; &quot;A comma separated list of groups&quot;]
   [&quot;-r&quot; &quot;--roles&quot; &quot;A comma separated list of group roles&quot;]
   [&quot;-q&quot; &quot;--quiet&quot; &quot;No output on successful completion&quot;
    :flag true :default false]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def help
  (str &quot;Bring down project nodes.\n&quot;
       \newline
       &quot;If you have variants defined, you can use `-s` to select variants.\n&quot;
       \newline
       (last (process-args &quot;nodes&quot; nil switches))))</pre></td></tr><tr><td class="docs"><p>help</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:doc help} down
  [{:keys [compute project] :as request} &amp; args]
  (let [[{:keys [selectors quiet groups roles]} args]
        (process-args &quot;down&quot; args switches)
        spec (project-groups
              (pallet-project project) compute selectors groups roles)]
    (let [op (apply-map api/converge
                        (map #(assoc % :count 0) spec)
                        :async true
                        (-&gt;
                         request
                         (dissoc :config :project)
                         (assoc :environment
                           (or (:environment request)
                               (-&gt; request :project :environment)))))]
      (wait-for op)
      (if (complete? op)
        (when-not quiet
          (println &quot;Removed&quot; (count (:old-nodes @op)) &quot;nodes&quot;))
        (binding [*out* *err*]
          (println &quot;An error occured&quot;)
          (when-let [e (seq (phase-errors op))]
            (print-table (-&gt;&gt; e (map :error) (map #(dissoc % :type)))))
          (when-let [e (:exception @op)]
            (print-cause-trace e)
            (throw (ex-info &quot;pallet down failed&quot; {:exit-code 1} e)))
          (throw (ex-info &quot;See logs for further details&quot; {:exit-code 1})))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.help" name="pallet.task.help"><h1 class="project-name">pallet.task.help</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Display a list of tasks or help for a given task.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.help
  (:require
   [chiba.plugin :refer [plugins]]
   [clojure.string :as string]
   [pallet.main :refer [pallet-args]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def impl-ns &quot;pallet.task.&quot;)
(def task-list (atom nil))</pre></td></tr><tr><td class="docs"><p>Find the available tasks.</p>
</td><td class="codes"><pre class="brush: clojure">(defn tasks
  []
  (try
    (or @task-list
        (reset! task-list (plugins impl-ns)))
    (catch java.io.FileNotFoundException e
      #{'pallet.task.help})))</pre></td></tr><tr><td class="docs"><p>Help for a task is stored in its docstring, or if that's not present
  in its namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn help-for
  [task-name]
  (let [task-ns (symbol (str &quot;pallet.task.&quot; task-name))
        _ (require task-ns)
        task (ns-resolve task-ns (symbol task-name))
        doc (or (:doc (meta task))
                (:doc (meta (find-ns task-ns))))
        arglists (or (:help-arglists (meta task))
                     (:arglists (meta task)))]
    (str doc
         (apply str
                (map
                 #(str \newline &quot;  lein pallet &quot; task-name &quot; &quot;
                       (string/join &quot; &quot; %))
                 arglists)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn help-summary-for [task-ns]
  (let [task-name (last (.split (name task-ns) &quot;\\.&quot;))]
    (try
      (require task-ns)
      (str task-name (apply str (repeat (- 16 (count task-name)) &quot; &quot;))
           &quot; - &quot; (:doc (meta (find-ns task-ns))))
      (catch Exception e
        (str task-name &quot; failed to load: &quot; (.getMessage e))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn help
  {:no-service-required true}
  ([_ task] (println (help-for task)))
  ([_]
     (println
      (str &quot;Pallet is a provisioning, configuration management and &quot;
           &quot;orchestration tool.\n&quot;))
     (println &quot;Several tasks are available:\n&quot;)
     (doseq [task-summary (sort (map help-summary-for (tasks)))]
       (println task-summary))
     (println &quot;\nRun pallet help $TASK for details.\n\n&quot;)
     (println (last (pallet-args nil)))
     (if @task-list
       (do
         (println &quot;\nIf no options are given, the following sequence is used to&quot;)
         (println &quot;find a compute service to use.&quot;)
         (println &quot;\n  the pallet.config.service property is checked for the&quot;)
         (println &quot;    name of a var to use for the service,&quot;)
         (println &quot;\n  the ~/.pallet/config.clj is checked for an active profile&quot;)
         (println &quot;    specified with `defpallet`.  e.g.&quot;)
         (println &quot;      (defpallet&quot;)
         (println &quot;        :services {&quot;)
         (println &quot;          :aws {:provider \&quot;ec2\)
         (println &quot;                :identity \&quot;username or key\)
         (println &quot;                :credential \&quot;password, key or secret key\&quot;}})&quot;)
         (println &quot;\n  the pallet.config/service is used if it exists.&quot;)
         (println &quot;\nYou can write project specific tasks under the\n&quot;
                  &quot;pallet.task namespace.&quot;)))
     (println &quot;\nSee http://palletops.com for documentation&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.images" name="pallet.task.images"><h1 class="project-name">pallet.task.images</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>List images.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.images
  (:require
   [pallet.compute :as compute]))</pre></td></tr><tr><td class="docs"><p>List available images.</p>
</td><td class="codes"><pre class="brush: clojure">(defn images
  [request &amp; args]
  (doseq [image (compute/images (:compute request))
          :let [image (bean image)]]
    (println (pr-str image))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.lift" name="pallet.task.lift"><h1 class="project-name">pallet.task.lift</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Apply configuration.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.lift
  (:require
   [clojure.pprint :refer [print-table]]
   [clojure.stacktrace :refer [print-cause-trace]]
   [clojure.tools.logging :as logging]
   [pallet.algo.fsmop :refer [complete? wait-for]]
   [pallet.api :as api]
   [pallet.api :refer [print-targets]]
   [pallet.core.primitives :refer [phase-errors]]
   [pallet.task :refer [abort maybe-resolve-symbol-string]]
   [pallet.task-utils :refer [pallet-project project-groups]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [^String a (first args)]
      (let [v (maybe-resolve-symbol-string a)]
        (cond
          ;; non symbol as first arg
          (and (nil? m) (not v)) (recur (next args) a m phases)
          ;; a symbol
          (not (.startsWith a &quot;:&quot;))
          (if v
            (recur (next args) prefix (conj (or m []) v) phases)
            (abort (str &quot;Could not locate node definition for &quot; a)))
          ;; a phase
          :else (recur (next args) prefix m (conj phases (read-string a)))))
      (concat [(set m)] [:phase phases]))))</pre></td></tr><tr><td class="docs"><p>Apply configuration.
     eg. pallet lift mynodes/my-node
   The node-types should be namespace qualified.</p>
</td><td class="codes"><pre class="brush: clojure">(defn lift
  [{:keys [compute project] :as request} &amp; args]
  (let [[spec &amp; args] (build-args args)
        spec (or (seq spec)
                 (project-groups (pallet-project project) compute nil nil nil))
        _ (logging/debugf &quot;lift %s&quot; (pr-str spec))
        op (apply api/lift
                  spec
                  :async true
                  (concat
                   args
                   (apply concat
                          (-&gt;
                           request
                           (dissoc :config :project)
                           (assoc :environment
                             (or (:environment request)
                                 (-&gt; request :project :environment)))))))]
    (wait-for op)
    (if (complete? op)
      (print-targets @op)
      (binding [*out* *err*]
        (println &quot;An error occured&quot;)
        (when-let [e (seq (phase-errors op))]
          (print-table (-&gt;&gt; e (map :error) (map #(dissoc % :type)))))
        (when-let [e (:exception @op)]
          (print-cause-trace e)
          (throw (ex-info &quot;pallet up failed&quot; {} e)))
        (println &quot;See logs for further details&quot;)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.nodes" name="pallet.task.nodes"><h1 class="project-name">pallet.task.nodes</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>List nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.nodes
  (:require
   [clojure.pprint :refer [pprint]]
   [pallet.api :refer [print-nodes]]
   [pallet.compute :as compute]
   [pallet.node :refer [node-map]]
   [pallet.task-utils :refer [process-args]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def nodes-switches
  [[&quot;-f&quot; &quot;--format&quot; &quot;Output nodes in a table [table,edn]&quot; :default &quot;table&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def help
  (str &quot;List all nodes.&quot;
       \newline \newline
       (last (process-args &quot;nodes&quot; nil nodes-switches))))</pre></td></tr><tr><td class="docs"><p>help</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:doc help} nodes
  [request &amp; args]
  (let [[{:keys [format]}] (process-args &quot;nodes&quot; args nodes-switches)
        nodes (compute/nodes (:compute request))]
    (condp = format
      &quot;edn&quot; (pprint (map node-map nodes))
      (print-nodes nodes))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.project-init" name="pallet.task.project-init"><h1 class="project-name">pallet.task.project-init</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Initialise a project.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.project-init
  (:require
   [pallet.task :refer [abort]]
   [pallet.task-utils :refer [create-pallet-project]]))</pre></td></tr><tr><td class="docs"><p>Initialise a project, creating a pallet.clj configuration file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn project-init
  {:no-service-required true
   :help-arglists '[[project-name?]]}
  ([{:keys [project] :as request}]
     (if (:root project)
       (println &quot;Your project's pallet configuration is in&quot;
                (create-pallet-project project))
       (abort &quot;You must supply a project name outside of a lein project.&quot;)))
  ([{:keys [project] :as request} project-name]
     (println &quot;Your project's pallet configuration is in&quot;
              (create-pallet-project {:name project-name
                                      :root (System/getProperty &quot;user.dir&quot;)}))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.providers" name="pallet.task.providers"><h1 class="project-name">pallet.task.providers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provide information on the supported and enabled providers.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.providers
  (:require
   [pallet.compute :refer [supported-providers]]))</pre></td></tr><tr><td class="docs"><p>Provide information on the supported and enabled providers.</p>
</td><td class="codes"><pre class="brush: clojure">(defn providers
  {:no-service-required true}
  [&amp; _]
  (println &quot;Pallet uses its own and jcloud's providers.\n&quot;)
  (doseq [name (supported-providers)]
    (println (format &quot;  %s&quot; name)))
  (println &quot;\nProviders can be enabled by adding a dependency on a pallet or\n&quot;)
  (println &quot;jclouds provider into your project.clj or pom.xml.&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.to-blob" name="pallet.task.to-blob"><h1 class="project-name">pallet.task.to-blob</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Upload to a blob.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.to-blob
  (:require
   [pallet.blobstore :as blobstore]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn war-file-name
  [project]
  (format &quot;%s-%s.war&quot; (:name project) (:version project)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn find-war
  [project]
  (some
   #(let [^String f (% project)] (and (.exists (java.io.File. f)) f))
   [war-file-name]))</pre></td></tr><tr><td class="docs"><p>Upload to a blob.
    to-blob container path filename
   By default tries to upload the project war file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn to-blob
  [request &amp; args]
  (let [[container path &amp; files] (map name args)
        file (or (first files) (find-war (:project request)))
        options (-&gt; request :project :pallet)]
    (if file
      (do
        (println &quot;Uploading&quot; file)
        (blobstore/put-file (:blobstore request) container path file))
      (println &quot;Nothing to upload&quot;))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.up" name="pallet.task.up"><h1 class="project-name">pallet.task.up</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Bring up nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.up
  (:require
   [clojure.pprint :refer [pprint]]
   [clojure.stacktrace :refer [print-cause-trace]]
   [clojure.string :as string]
   [pallet.algo.fsmop :refer [failed? fail-reason wait-for]]
   [pallet.api :as api]
   [pallet.api :refer [print-targets]]
   [pallet.compute :refer [service-properties]]
   [pallet.core.primitives :refer [phase-errors]]
   [pallet.node :refer [node-map]]
   [pallet.task-utils
    :refer [comma-sep-&gt;kw-seq
            comma-sep-&gt;seq
            pallet-project
            process-args
            project-groups]]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def switches
  [[&quot;-s&quot; &quot;--selectors&quot; &quot;A comma separated list of selectors&quot;
    :default &quot;default&quot;]
   [&quot;-g&quot; &quot;--groups&quot; &quot;A comma separated list of groups&quot;]
   [&quot;-r&quot; &quot;--roles&quot; &quot;A comma separated list of group roles&quot;]
   [&quot;-a&quot; &quot;--phases&quot; &quot;A comma separated list of phases&quot;]
   [&quot;-d&quot; &quot;--dry-run&quot; &quot;Don't run anything, just show matching groups&quot;
    :flag true]
   [&quot;-f&quot; &quot;--format&quot; &quot;Output nodes in a table [table,edn]&quot;
    :default &quot;table&quot;]
   [&quot;-q&quot; &quot;--quiet&quot; &quot;No output on successful completion&quot;
    :flag true :default false]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def help
  (str &quot;Bring up project nodes.\n&quot;
       \newline
       &quot;If you have variants defined, you can use `-s` to select variants.\n&quot;
       \newline
       (last (process-args &quot;nodes&quot; nil switches))))</pre></td></tr><tr><td class="docs"><p>Take phase keywords and apply comma separated args to each.</p>
</td><td class="codes"><pre class="brush: clojure">(defn phases-with-args
  [phases args]
  (map #(if %2
          (apply vector %1 (comma-sep-&gt;seq %2))
          %1)
       phases (concat args (repeat nil))))</pre></td></tr><tr><td class="docs"><p>help</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:doc help} up
  [{:keys [compute project quiet format] :as request} &amp; args]
  (let [[{:keys [selectors phases roles groups quiet format dry-run]} args]
        (process-args &quot;up&quot; args switches)
        pallet-project (pallet-project project)
        spec (project-groups pallet-project compute selectors groups roles)
        phases (phases-with-args (comma-sep-&gt;kw-seq phases) args)]
    (if dry-run
      (let [info (vec (map #(select-keys % [:group-name :roles :image]) spec))]
        (println &quot;Dry run&quot;)
        (if (pos? (count info))
          (do
            (println
             (if phases (str &quot;      phases: &quot; (vec phases) \newline) &quot;&quot;)
             &quot;  Node Specs:&quot;)
            (pprint info))
          (println
           (if (or selectors groups roles)
             (let [provider (:provider (service-properties compute))]
               (println
                &quot;No groups match selection, groups and roles criteria.\n&quot;
                &quot;   Provider:&quot; (name provider) \newline
                &quot;     Groups:&quot; (string/join &quot;, &quot;
                                            (map (comp name :group-name)
                                                 (:groups pallet-project))))
               (println &quot;  Node Specs:&quot;)
               (pprint (get-in pallet-project [:provider provider])))
             (println
              &quot;No groups defined in pallet.clj, or no node-specs match :default&quot;
              (if (= selectors &quot;default&quot;)
                &quot;&quot;
                (str &quot;  selectors: &quot; selectors \newline))
              (if groups (str &quot;     groups: &quot; groups \newline) &quot;&quot;)
              (if roles (str &quot;      roles: &quot; roles \newline) &quot;&quot;)))))
        (flush))
      (let [op (apply-map api/converge
                          spec
                          :async true
                          (-&gt;
                           request
                           (merge (when (seq phases)
                                    {:phase phases}))
                           (dissoc :config :project)
                           (assoc :environment
                             (assoc
                                 (or (:environment request)
                                     (-&gt; request :project :environment))
                               :project (dissoc
                                         (-&gt; request :project)
                                         :environment)))))]
        (wait-for op)
        (if (failed? op)
          (binding [*out* *err*]
            (println &quot;An error occured&quot;)
            (when-let [e (seq (phase-errors op))]
              (pprint (-&gt;&gt; e (map :error) (map #(dissoc % :type)))))
            (when-let [e (and (failed? op) (:exception (fail-reason op)))]
              (print-cause-trace e)
              (throw (ex-info &quot;pallet up failed&quot; {:exit-code 1} e)))
            (throw
             (ex-info &quot;See logs for further details&quot; {:exit-code 1})))
          (when-not quiet
            (if (= format &quot;edn&quot;)
              (pprint (map node-map (map :node (:targets @op))))
              (print-targets @op))))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.version" name="pallet.task.version"><h1 class="project-name">pallet.task.version</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Print Pallet's version to standard out.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task.version )</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn version
  {:no-service-required true
   :help-arglists '[[]]}
  [_]
  (println &quot;Pallet&quot; (System/getProperty &quot;pallet.version&quot;)
           &quot;on Java&quot; (System/getProperty &quot;java.version&quot;)
           (System/getProperty &quot;java.vm.name&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task-utils" name="pallet.task-utils"><h1 class="project-name">pallet.task-utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Task helpers that depend on pallet implementation</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.task-utils
  (:require
   [clojure.java.io :refer [file]]
   [clojure.string :as string]
   [clojure.tools.cli :refer [cli]]
   [clojure.tools.logging :refer [fatalf]]
   [pallet.compute :refer [service-properties]]
   [pallet.project
    :refer [create-project-file
            default-pallet-file
            default-user-pallet-file
            pallet-file-exists?
            read-or-create-project
            read-project
            spec-from-project]]
   [pallet.task :refer [abort report-error]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- ns-error-msg [ns crate]
  (str
   &quot;Could not find namespace &quot; ns \newline
   &quot;  This is probably caused by a missing dependency.&quot;
   \newline \newline
   &quot;  To solve this, add the correct dependency to your :pallet profile&quot;
   \newline
   &quot;  :dependencies in project.clj.&quot;
   (if crate
     (str \newline  \newline
          &quot;  It looks like you are trying to use the &quot; crate &quot; crate.&quot;
          \newline
          &quot;  The dependency for this should look like:&quot; \newline \newline
          &quot;    [com.palletops/&quot; crate &quot;-crate \&quot;0.8.0\&quot;]&quot;))
   \newline))</pre></td></tr><tr><td class="docs"><p>Load the pallet project for the specified lein project.  Will create
   a user level config if called outside of a project and no user level
   config exists yet.</p>
</td><td class="codes"><pre class="brush: clojure">(defn pallet-project
  [lein-project]
  (let [project-name (:name lein-project)
        pallet-file (or (:pallet-file lein-project)
                        (when (or (and project-name (:root lein-project))
                                  (.exists (file &quot;project.clj&quot;)))
                          default-pallet-file))]
    (if pallet-file
      (if (pallet-file-exists? pallet-file)
        (try
          (read-project pallet-file)
          (catch java.io.FileNotFoundException e
            (fatalf e &quot;Could not read pallet configuration for project from %s&quot;
                    (.getAbsolutePath (file pallet-file)))
            (abort
             (str &quot;Could not read pallet configuration for project from &quot;
                  (.getAbsolutePath (file pallet-file)))))
          (catch Exception e
            (if-let [project-file (:project-file (ex-data e))]
              (if-let [[_ path]
                       (re-matches
                        #&quot;Could not locate .* or (.*)\.clj on classpath.*&quot;
                        (.getMessage (.getCause e)))]
                (let [ns (-&gt; path (string/replace &quot;/&quot; &quot;.&quot;)
                             (string/replace &quot;_&quot; &quot;-&quot;))
                      [_ crate] (re-matches #&quot;pallet\.crate\.([^.]+)&quot; ns)]
                  (report-error (ns-error-msg ns crate))
                  (throw
                   (ex-info (str &quot;ERROR: Could not find namespace &quot; ns
                                 &quot; while loading &quot; project-file)
                            {:exit-code 1})))
                (throw e))
              (throw e))))
        (abort (str &quot;No pallet configuration for project.  &quot;
                    &quot;Use `lein pallet project-init` to create one&quot;)))
      (read-or-create-project &quot;pallet&quot; default-user-pallet-file))))</pre></td></tr><tr><td class="docs"><p>Create the pallet project for the specified lein project.</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-pallet-project
  [lein-project]
  (let [project-name (:name lein-project)
        pallet-file (or (:pallet-file lein-project)
                        (when (and project-name (:root lein-project))
                          default-pallet-file))]
    (if (pallet-file-exists? pallet-file)
      (abort (str &quot;Pallet configuration already exists for project in &quot;
                  pallet-file))
      (do (create-project-file (or project-name &quot;default&quot;) pallet-file)
          pallet-file))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comma-sep-&gt;seq
  [^String s]
  (and s (.split s &quot;,&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comma-sep-&gt;kw-seq
  [^String s]
  (and s (map keyword (.split s &quot;,&quot;))))</pre></td></tr><tr><td class="docs"><p>Compute the groups for a pallet project using the given compute service,
filtered by selectors, groups and roles.</p>
</td><td class="codes"><pre class="brush: clojure">(defn project-groups
  [pallet-project compute selectors groups roles]
  (let [{:keys [provider]} (service-properties compute)]
    (spec-from-project
     pallet-project
     provider
     (set (comma-sep-&gt;kw-seq selectors))
     (set (comma-sep-&gt;kw-seq roles))
     (set (comma-sep-&gt;kw-seq groups)))))</pre></td></tr><tr><td class="docs"><p>Process command line arguments. Returns an option map, a vector of arguments
  and a help string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn process-args
  [task args switches]
  (try
    (apply cli args switches)
    (catch Exception e
      (report-error
       (str (str (.getMessage e) &quot; for '&quot; task &quot;'&quot;) \newline \newline
            (last (apply cli nil switches))))
      (throw (ex-info
              (str &quot;Pallet &quot; task &quot; task failed&quot;)
              {:exit-code 1}
              e)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.template" name="pallet.template"><h1 class="project-name">pallet.template</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Template file writing</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.template
  (:require
   [clojure.tools.logging :as logging]
   [pallet.actions :refer [remote-file]]
   [pallet.core.session :refer [group-name os-family packager]]
   [pallet.strint :as strint]
   [pallet.utils :as utils]
   [pallet.utils :refer [apply-map]]))</pre></td></tr><tr><td class="docs"><p>Loads a resource. Returns a URI.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^java.net.URL get-resource
  [path]
  (-&gt; (clojure.lang.RT/baseLoader) (.getResource path)))</pre></td></tr><tr><td class="docs"><p>Split a resource path into path, basename and extension components.</p>
</td><td class="codes"><pre class="brush: clojure">(defn path-components
  [^String path]
  (let [p (inc (.lastIndexOf path &quot;/&quot;))
        i (.lastIndexOf path &quot;.&quot;)]
    [(when (pos? p) (subs path 0 (dec p)))
     (if (neg? i) (subs path p) (subs path p i))
     (if (neg? i) nil (subs path (inc i)))]))</pre></td></tr><tr><td class="docs"><p>Build a pathname from a list of path and filename parts.  Last part is
   assumed to be a file extension.</p>

<p>   'The name of a resource is a '/'-separated path name that identifies the
   resource.'</p>
</td><td class="codes"><pre class="brush: clojure">(defn pathname
  [path file ext]
  (str (when path (str path &quot;/&quot;)) file (when ext (str &quot;.&quot; ext))))</pre></td></tr><tr><td class="docs"><p>Generate a prioritised list of possible template paths.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- candidate-templates
  [path group-name session]
  (let [[dirpath base ext] (path-components path)
        variants (fn [specifier]
                   (let [p (pathname
                            dirpath
                            (if specifier (str base &quot;_&quot; specifier) base)
                            ext)]
                     [p (str &quot;resources/&quot; p)]))]
    (concat
     (variants group-name)
     (variants (name (or (os-family session) &quot;unknown&quot;)))
     (variants (name (or (packager session) &quot;unknown&quot;)))
     (variants nil))))</pre></td></tr><tr><td class="docs"><p>Find a template for the specified path, for application to the given node.
   Templates may be specialised.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-template
  [path session]
  {:pre [(map? session) (session :server)]}
  (some
   get-resource
   (candidate-templates path (group-name session) session)))</pre></td></tr><tr><td class="docs"><p>Interpolate the given template.</p>
</td><td class="codes"><pre class="brush: clojure">(defn interpolate-template
  [path values session]
  (strint/&lt;&lt;!
   (utils/load-resource-url
    (find-template path session))
   (utils/map-with-keys-as-symbols values)))</pre></td></tr><tr><td class="docs"><p>programatic templates - umm not really templates at all</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro deftemplate [template [&amp; args] m]
  `(defn ~template [~@args]
     ~m))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- apply-template-file
  [[file-spec content]]
  (logging/trace (str &quot;apply-template-file &quot; file-spec \newline content))
  (apply-map remote-file (:path file-spec) :content content
             (dissoc file-spec :path)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn apply-templates
  [template-fn args]
  (doseq [f (apply template-fn args)]
    (apply-template-file f)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.template.properties" name="pallet.template.properties"><h1 class="project-name">pallet.template.properties</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A template for writing properties style config files.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.template.properties
  (:require
   [pallet.utils :refer [as-string]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn property-section [[name settings]]
  (apply
   str
   &quot;[&quot; (as-string name) &quot;]&quot; \newline
   (map #(format &quot;%s = %s\n&quot; (as-string (first %)) (as-string (second %))) settings)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn property-set [p]
  (apply str (map property-section p)))</pre></td></tr><tr><td class="docs"><p>Write a properties file based on the input argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn properties
  [values]
  (apply str (map property-set values)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.utils" name="pallet.utils"><h1 class="project-name">pallet.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Utilities used across pallet.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.utils
  (:require
   [clojure.java.io :as io]
   [clojure.pprint :as pprint]
   [clojure.string :as string]
   [clojure.tools.logging :as logging]
   [pallet.common.deprecate :refer [deprecated]])
  (:import
   (java.security MessageDigest NoSuchAlgorithmException)
   (org.apache.commons.codec.binary Base64)))</pre></td></tr><tr><td class="docs"><p>Pretty print a multiline string</p>
</td><td class="codes"><pre class="brush: clojure">(defn pprint-lines
  [s]
  (pprint/pprint (seq (.split #&quot;\r?\n&quot; s))))</pre></td></tr><tr><td class="docs"><p>Return the string value of the argument in quotes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn quoted
  [s]
  (str &quot;\&quot;&quot; s &quot;\&quot;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn underscore [^String s]
  &quot;Change - to _&quot;
  (apply str (interpose &quot;_&quot;  (.split s &quot;-&quot;))))</pre></td></tr><tr><td class="docs"><p>Return the string value of the argument.</p>
</td><td class="codes"><pre class="brush: clojure">(defn as-string
  [arg]
  (cond
   (symbol? arg) (name arg)
   (keyword? arg) (name arg)
   :else (str arg)))</pre></td></tr><tr><td class="docs"><p>Return the first line of a string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn first-line
  [s]
  (first (string/split-lines (str s))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro apply-map
  [&amp; args]
  `(apply ~@(drop-last args) (apply concat ~(last args))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn resource-path [name]
  (let [loader (.getContextClassLoader (Thread/currentThread))
        resource (. loader getResource name)]
    (when resource
      (.getFile resource))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn load-resource
  [name]
  (let [loader (.getContextClassLoader (Thread/currentThread))]
    (.getResourceAsStream loader name)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn load-resource-url
  [^java.net.URL name]
  (logging/tracef &quot;load-resource-url %s&quot; name)
  (with-open [^java.io.InputStream stream (.getContent name)
              r (new java.io.BufferedReader
                     (new java.io.InputStreamReader
                          stream (.name (java.nio.charset.Charset/defaultCharset))))]
    (let [sb (new StringBuilder)]
      (loop [c (.read r)]
        (if (neg? c)
          (str sb)
          (do
            (.append sb (char c))
            (recur (.read r))))))))</pre></td></tr><tr><td class="docs"><p>Given a resource <code>path</code>, load it as a java properties file.
   Returns nil if resource not found.</p>
</td><td class="codes"><pre class="brush: clojure">(defn resource-properties
  [path]
  (let [loader (.getContextClassLoader (Thread/currentThread))
        stream (.getResourceAsStream loader path)]
    (when stream
      (with-open [stream stream]
        (let [properties (new java.util.Properties)]
          (.load properties stream)
          (let [keysseq (enumeration-seq (. properties propertyNames))]
            (reduce (fn [a b] (assoc a b (. properties getProperty b)))
                    {} keysseq)))))))</pre></td></tr><tr><td class="docs"><p>Read the given file as a byte array.</p>
</td><td class="codes"><pre class="brush: clojure">(defn slurp-as-byte-array
  [#^java.io.File file]
  (let [size (.length file)
        bytes #^bytes (byte-array size)
        stream (new java.io.FileInputStream file)]
    bytes))</pre></td></tr><tr><td class="docs"><p>Find the var for the given namespace and symbol. If the namespace does
   not exist, then it will be required.
       (find-var-with-require 'my.ns 'a-symbol)
       (find-var-with-require 'my.ns/a-symbol)</p>

<p>   If the namespace exists, but can not be loaded, and exception is thrown.  If
   the namespace is loaded, but the symbol is not found, then nil is returned.</p>
</td><td class="codes"><pre class="brush: clojure">(defn find-var-with-require
  ([sym]
     (find-var-with-require (symbol (namespace sym)) (symbol (name sym))))
  ([ns sym]
     (try
       (when-not (find-ns ns)
         (require ns))
       (catch java.io.FileNotFoundException _)
       (catch Exception e
         ;; require on a bad namespace still instantiates the namespace
         (remove-ns ns)
         (throw e)))
     (try
       (when-let [v (ns-resolve ns sym)]
         (var-get v))
       (catch Exception _))))</pre></td></tr><tr><td class="docs"><p>Create a block where <code>varname</code> is a temporary <code>File</code> containing <code>content</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-temp-file
  [[varname content] &amp; body]
  `(let [~varname (java.io.File/createTempFile &quot;stevedore&quot;, &quot;.tmp&quot;)]
     (io/copy ~content ~varname)
     (let [rv# (do ~@body)]
       (.delete ~varname)
       rv#)))</pre></td></tr><tr><td class="docs"><p>Create a temporary file</p>
</td><td class="codes"><pre class="brush: clojure">(defn tmpfile
  ([] (java.io.File/createTempFile &quot;pallet_&quot; &quot;tmp&quot;))
  ([^java.io.File dir] (java.io.File/createTempFile &quot;pallet_&quot; &quot;tmp&quot; dir)))</pre></td></tr><tr><td class="docs"><p>Create a temporary directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn tmpdir
  []
  (doto (java.io.File/createTempFile &quot;pallet_&quot; &quot;tmp&quot;)
    (.delete) ; this is a potential cause of non-unique names
    (.mkdir)))</pre></td></tr><tr><td class="docs"><p>A block scope allowing multiple bindings to expressions.  Each binding will
   have the member function <code>delete</code> called on it.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro with-temporary
  [bindings &amp; body] {:pre
   [(vector?  bindings)
         (even? (count bindings))]}
  (cond
   (= (count bindings) 0) `(do ~@body)
   (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)
                             (try
                              (with-temporary ~(subvec bindings 2) ~@body)
                              (finally
                               (. ~(bindings 0) delete))))
   :else (throw (IllegalArgumentException.
                 &quot;with-temporary only allows Symbols in bindings&quot;))))</pre></td></tr><tr><td class="docs"><p>Produce a map that is the same as m, but with all keys are converted to
  symbols.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-with-keys-as-symbols
  [m]
  (letfn [(to-symbol [x]
                     (cond
                      (symbol? x) x
                      (string? x) (symbol x)
                      (keyword? x) (symbol (name x))))]
    (zipmap (map to-symbol (keys m)) (vals m))))</pre></td></tr><tr><td class="docs"><p>Like clojure.core/dissoc, except it takes a vector of keys to remove</p>
</td><td class="codes"><pre class="brush: clojure">(defn dissoc-keys
  [m keys]
  (apply dissoc m keys))</pre></td></tr><tr><td class="docs"><p>Like clojure.core/dissoc, except it only dissoc's if the value at the
   keyword is nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dissoc-if-empty
  [m key]
  (if (empty? (m key)) (dissoc m key) m))</pre></td></tr><tr><td class="docs"><p>'Updates' a value in a nested associative structure, where ks is a
  sequence of keys and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  nested structure.  If any levels do not exist, hash-maps will be
  created only if the update function returns a non-nil value. If
  the update function returns nil, the map is returned unmodified.</p>
</td><td class="codes"><pre class="brush: clojure">(defn maybe-update-in
  [m [&amp; ks] f &amp; args]
  (let [v (apply f (get-in m ks) args)]
    (if v
      (assoc-in m ks v)
      m)))</pre></td></tr><tr><td class="docs"><p>'Assoc a value in an associative structure, where k is a key and v is the
value to assoc. The assoc only occurs if the value is non-nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn maybe-assoc
  [m k v]
  (if (nil? v)
    m
    (assoc m k v)))</pre></td></tr><tr><td class="docs"><p>Given an argument, returns the argument, or nil if passed an empty map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn map-seq
  [m]
  (if (not= {} m) m))</pre></td></tr><tr><td class="docs"><p>Build a session processing pipeline from the specified forms.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro pipe
  [&amp; forms]
  (let [[middlewares etc] (split-with #(or (seq? %) (symbol? %)) forms)
        middlewares (reverse middlewares)
        [middlewares [x :as etc]]
          (if (seq etc)
            [middlewares etc]
            [(rest middlewares) (list (first middlewares))])
          handler x]
    (if (seq middlewares)
      `(-&gt; ~handler ~@middlewares)
      handler)))</pre></td></tr><tr><td class="docs"><p>Computes the base64 encoding of the md5 of a string</p>
</td><td class="codes"><pre class="brush: clojure">(defn base64-md5
  [#^String unsafe-id]
  (let [alg (doto (MessageDigest/getInstance &quot;MD5&quot;)
              (.reset)
              (.update (.getBytes unsafe-id)))]
    (try
      (Base64/encodeBase64URLSafeString (.digest alg))
      (catch NoSuchAlgorithmException e
        (throw (new RuntimeException e))))))</pre></td></tr><tr><td class="docs"><p>Build a middleware processing pipeline from the specified forms.
   The result is a middleware.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro middleware
  [&amp; forms]
  (let [[middlewares] (split-with #(or (seq? %) (symbol? %)) forms)
        middlewares (reverse middlewares)]
    (if (seq middlewares)
      `(fn [handler#] (-&gt; handler# ~@middlewares))
      `(fn [handler#] handler#))))</pre></td></tr><tr><td class="docs"><p>Convert a URL to a File. </p>

<p>see http://weblogs.java.net/blog/kohsuke/archive/2007/04/how<em>to</em>convert.html</p>
</td><td class="codes"><pre class="brush: clojure">(defn file-for-url
  [^java.net.URL url]
  (try
    (java.io.File. (.toURI url))
    (catch java.net.URISyntaxException _
      (java.io.File. (.getPath url)))))</pre></td></tr><tr><td class="docs"><p>Return the classpath URL's for the current clojure classloader.</p>
</td><td class="codes"><pre class="brush: clojure">(defn classpath-urls
  []
  (.getURLs ^java.net.URLClassLoader (.getClassLoader clojure.lang.RT)))</pre></td></tr><tr><td class="docs"><p>Return the classpath File's for the current clojure classloader.</p>
</td><td class="codes"><pre class="brush: clojure">(defn classpath
  []
  (map file-for-url (classpath-urls)))</pre></td></tr><tr><td class="docs"><p>Returns true if file is a normal file with a .jar or .JAR extension.</p>
</td><td class="codes"><pre class="brush: clojure">(defn jar-file?
  [^java.io.File file]
  (and (.isFile file)
       (or (.endsWith (.getName file) &quot;.jar&quot;)
           (.endsWith (.getName file) &quot;.JAR&quot;))))</pre></td></tr><tr><td class="docs"><p>Returns a sequence of JarFile objects for the JAR files on classpath.</p>
</td><td class="codes"><pre class="brush: clojure">(defn classpath-jarfiles
  []
  (filter
   identity
   (map
    #(try
       (java.util.jar.JarFile. ^java.io.File %)
       (catch Exception _
         (logging/warnf &quot;Unable to open jar file on classpath: %s&quot; %)))
    (filter jar-file? (classpath)))))</pre></td></tr><tr><td class="docs"><p>Forward a script to the new script lib</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro forward-to-script-lib
  [&amp; symbols]
  `(do
     ~@(for [sym symbols]
         (list `def sym (symbol &quot;pallet.script.lib&quot; (name sym))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro fwd-to-configure [name &amp; [as-name &amp; _]]
  `(defn ~name [&amp; args#]
     (require '~'pallet.configure)
     (let [f# (ns-resolve '~'pallet.configure '~(or as-name name))]
       (apply f# args#))))</pre></td></tr><tr><td class="docs"><p>Compare and swap, returning old and new values</p>
</td><td class="codes"><pre class="brush: clojure">(defn compare-and-swap!
  [a f &amp; args]
  (loop [old-val @a]
    (let [new-val (apply f old-val args)]
      (if (compare-and-set! a old-val new-val)
        [old-val new-val]
        (recur @a)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-redef
  [[&amp; bindings] &amp; body]
  (if (find-var 'clojure.core/with-redefs)
    `(clojure.core/with-redefs [~@bindings] ~@body)
    `(binding [~@bindings] ~@body)))</pre></td></tr><tr><td class="docs"><p>Create a compiler exception that wraps a cause and includes source location.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro ^{:requires [io/file]}
  compiler-exception
  [exception]
  `(let [e# ~exception
         f# (io/file ~*file*)]
     (ex-info
      (str (.getMessage e#) &quot; &quot; (.getName f#) &quot;:&quot;)
      {:file ~*file*
       :line ~(-&gt; &amp;form meta :line)}
      ~exception)))</pre></td></tr><tr><td class="docs"><p>Create a compiler exception that wraps a cause and includes source location.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro macro-compiler-exception
  [exception]
  `(let [e# ~exception
         f# (io/file ~'*file*)]
     (ex-info
      (str (.getMessage e#) &quot; &quot; (.getName f#) &quot;:&quot;)
      {:file ~'*file*
       :line (-&gt; ~'&amp;form meta :line)}
      ~exception)))</pre></td></tr><tr><td class="docs"><p>Creates a User record with the given username and options. Generally used
   in conjunction with <em>admin-user</em> and pallet.api/with-admin-user, or passed
   to <code>lift</code> or <code>converge</code> as the named :user argument.</p>

<p>   Options:
    - :public-key-path
    - :private-key-path
    - :passphrase
    - :password
    - :sudo-password (defaults to :password)
    - :no-sudo</p>
</td><td class="codes"><pre class="brush: clojure">(defn make-user
  {:deprecated &quot;0.8.0&quot;}
  [username &amp; {:keys [public-key-path private-key-path passphrase
                      password sudo-password no-sudo] :as options}]
  (deprecated &quot;pallet.utils/make-user is now pallet.core.user/make-user&quot;)
  (require 'pallet.core.user)
  ((ns-resolve 'pallet.core.user 'make-user) username options))</pre></td></tr><tr><td class="docs"><p>Return clojure's local environment as a map of keyword value pairs.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro local-env
  []
  (letfn [(not-gensym? [sym] #(not (.contains (name sym) &quot;__&quot;)))]
    (into {}
          (map
           #(vector (keyword (name %)) %)
           (filter not-gensym? (keys &amp;env))))))</pre></td></tr><tr><td class="docs"><p>Log a multiline string in multiple log lines</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro log-multiline
  [level-kw fmt string]
  `(let [fmt# ~fmt]
     (when (logging/enabled? ~level-kw)
       (doseq [l# (string/split-lines ~string)]
         (logging/log ~level-kw (format fmt# l#))))))</pre></td></tr><tr><td class="docs"><p>Recursively merge maps.</p>
</td><td class="codes"><pre class="brush: clojure">(defn deep-merge
  [&amp; ms]
  (letfn [(f [a b]
            (if (and (map? a) (map? b))
              (deep-merge a b)
              b))]
    (apply merge-with f ms)))</pre></td></tr><tr><td class="docs"><p>Obfuscate a password, by replacing every character by an asterisk.</p>
</td><td class="codes"><pre class="brush: clojure">(defn obfuscate
  [pw]
  (when pw (string/replace pw #&quot;.&quot; &quot;*&quot;)))</pre></td></tr><tr><td class="docs"><p>Merge the <code>seqs</code> sequences so that the ordering of the elements in result is
  the same as the ordering of elements present in each of the specified
  sequences.  Throws an exception if no ordering can be found that satisfies the
  ordering in all the <code>seqs</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn total-order-merge
  [&amp; seqs]
  {:pre [(every? (some-fn nil? sequential?)
  seqs)]}
  (loop [m-seqs seqs
         r []]
    (if (seq m-seqs)
      (let [first-elements (map first m-seqs)
            other-elements (set (mapcat rest m-seqs))
            candidates (remove other-elements first-elements)]
        (if (seq candidates)
          (recur
           (-&gt;&gt;
            m-seqs
            (map #(if (= (first candidates) (first %)) (rest %) %))
            (filter seq))
           (conj r (first candidates)))
          (throw
           (ex-info (str &quot;No total ordering available: &quot;
                         (vec first-elements) &quot;, &quot;
                         (vec other-elements))
                    {:seqs seqs}))))
      r)))</pre></td></tr><tr><td class="docs"><p>Take a sequence and a key function, and returns a map with the
  count of each key.</p>
</td><td class="codes"><pre class="brush: clojure">(defn count-by
  [key-fn s]
  (reduce (fn [cnts e] (update-in cnts [(key-fn e)] (fnil inc 0))) {} s))</pre></td></tr><tr><td class="docs"><p>Take a sequence, and returns a map with the count of each value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn count-values
  [s]
  (reduce (fn [cnts e] (update-in cnts [e] (fnil inc 0))) {} s))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.version-dispatch" name="pallet.version-dispatch"><h1 class="project-name">pallet.version-dispatch</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Dispatch that is version aware.</p>

<p>A version is a dotted string, e.g. "1.0.3", which is represented as a vector
<code>[1 0 3]</code>.</p>

<p>A version specification is either a version vector, which matches a single
version (and all point versions thereof), or a vector of two elements,
specifying an inclusive version range. A nil in the version vector signifies an
open end to the range.</p>

<p>The basic idea is that you wish to dispatch on hierarchy where the dispatched
data may provide a version.</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.version-dispatch
  (:require
   [clojure.string :as string]
   [pallet.compute :refer [os-hierarchy]]
   [pallet.core.version-dispatch :refer [match-less version-map]]
   [pallet.crate :refer [os-family os-version phase-context]]
   [pallet.versions
    :refer [as-version-vector version-matches? version-spec-less]]))</pre></td></tr><tr><td class="docs"><p>Returns all values in a hierarchy, whether parents or children.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^{:internal true} hierarchy-vals
  [hierarchy]
  (set
   (concat
    (keys (:parents hierarchy))
    (keys (:descendants hierarchy)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ^{:internal true} dispatch-version
  [sym os os-version version args hierarchy methods]
  (letfn [(matches? [[i _]]
            (and (isa? hierarchy os (:os i))
                 (version-matches? os-version (:os-version i))
                 (version-matches? version (:version i))))]
    (if-let [[_ f] (first (sort
                           (comparator (partial match-less hierarchy))
                           (filter matches? methods)))]
      (apply f os os-version version args)
      (if-let [f (:default methods)]
        (apply f os os-version version args)
        (throw
         (ex-info
          (format &quot;No %s method for :os %s :os-version %s :version %s&quot;
                  sym os os-version version)
          {:reason :defmulti-version-method-missing
           :multi-version sym
           :os os
           :os-version os-version
           :version version}))))))</pre></td></tr><tr><td class="docs"><p>Defines a multi-version function used to abstract over an operating system
hierarchy, where dispatch includes an optional <code>os-version</code>. The <code>version</code>
refers to a software package version of some sort, on the specified <code>os</code> and
<code>os-version</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmulti-version
  {:indent 2}
  [name [os os-version version &amp; args] hierarchy-place]
  `(do
     (let [h# ~hierarchy-place
           m# (atom {})]
       (defn ~name
         {:hierarchy h# :methods m#}
         [~os ~os-version ~version ~@args]
         (dispatch-version '~name
          ~os ~os-version ~version [~@args] (var-get h#) @m#)))))</pre></td></tr><tr><td class="docs"><p>Adds a method to the specified multi-version function for the specified
<code>dispatch-value</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmethod-version
  {:indent 3}
  [multi-version {:keys [os os-version version] :as dispatch-value}
   [&amp; args] &amp; body]
  (let [{:keys [hierarchy methods]} (meta (resolve multi-version))
        h (var-get hierarchy)]
    (when-not ((hierarchy-vals h) os)
      (throw (Exception. (str os &quot; is not part of the hierarchy&quot;))))
    `(swap! (:methods (meta (var ~multi-version))) assoc ~dispatch-value
            (fn
              ~(symbol
                (str (name os) &quot;-&quot; os-version &quot;-&quot; (string/join &quot;&quot; version)))
              [~@args]
              ~@body))))</pre></td></tr><tr><td class="docs"><p>Defines a multi-version function used to abstract over an operating system
hierarchy, where dispatch includes an optional <code>os-version</code>. The <code>version</code>
refers to a software package version of some sort, on the specified <code>os</code> and
<code>os-version</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmulti-version-plan
  {:indent 2}
  [name [version &amp; args]]
  `(let [h# #'os-hierarchy
         m# (atom {})]
     (defn ~name
       {:hierarchy h# :methods m#}
       [~version ~@args]
       (dispatch-version
        '~name
        (os-family)
        (as-version-vector (os-version))
        (as-version-vector ~version) [~@args] (var-get h#) @m#))))</pre></td></tr><tr><td class="docs"><p>Adds a method to the specified multi-version function for the specified
<code>dispatch-value</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro defmethod-version-plan
  {:indent 3}
  [multi-version {:keys [os os-version version] :as dispatch-value}
   [&amp; args] &amp; body]
  (let [{:keys [hierarchy methods]} (meta (resolve multi-version))
        h (var-get hierarchy)]
    (when-not ((hierarchy-vals h) os)
      (throw (Exception. (str os &quot; is not part of the hierarchy&quot;))))
    `(swap! (:methods (meta (var ~multi-version))) assoc ~dispatch-value
            (fn ~(symbol
                  (str (name os) &quot;-&quot; os-version &quot;-&quot; (string/join &quot;&quot; version)))
              [~@args]
              (phase-context
                  ~(symbol
                    (str (name os) &quot;-&quot; os-version &quot;-&quot; (string/join &quot;&quot; version)))
                  {}
                ~@body)))))</pre></td></tr><tr><td class="docs"><p>Construct an os version map. The keys should be maps with :os-family
and :os-version keys. The :os-family value should be take from the
<code>os-hierarchy</code>. The :os-version should be a version vector, or a version range
vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn os-map
  [{:as os-value-pairs}]
  (version-map os-hierarchy :os :os-version os-value-pairs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn os-map-lookup
  [os-map]
  (get os-map {:os (os-family) :os-version (as-version-vector (os-version))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.versions" name="pallet.versions"><h1 class="project-name">pallet.versions</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Version handling for pallet</p>
</td><td class="codes"><pre class="brush: clojure">(ns pallet.versions
  (:require
   [clojure.tools.logging :refer [warnf]]
   [clojure.string :as string]))</pre></td></tr><tr><td class="docs"><p>Read a version number from a string, ignoring alphabetic chars.</p>
</td><td class="codes"><pre class="brush: clojure">(defn read-version-number
  [s]
  (try
    (Integer/parseInt (string/replace s #&quot;[a-zA-Z-_]&quot; &quot;&quot;))
    (catch Exception e
      (warnf &quot;Could not obtain an integer from version component '%s'. %s&quot;
             s (.getMessage e)))))</pre></td></tr><tr><td class="docs"><p>Convert a dotted version string to a vector of version numbers.
E.g.,
    (version-vector "1.2") => [1 2]</p>
</td><td class="codes"><pre class="brush: clojure">(defn version-vector
  [version-string]
  (filterv identity (map read-version-number
                         (string/split version-string #&quot;\.&quot;))))</pre></td></tr><tr><td class="docs"><p>Take a version, as either a string or a version vector, and returns a
version vector.</p>
</td><td class="codes"><pre class="brush: clojure">(defn as-version-vector
  [version]
  (if (string? version) (version-vector version) version))</pre></td></tr><tr><td class="docs"><p>Convert a a vector of version numbers to a dotted version string.
E.g.,
    (version-vector [1 2]) => "1.2"</p>
</td><td class="codes"><pre class="brush: clojure">(defn version-string
  [version-vector]
  {:pre [(seq version-vector)]}
  (string/join &quot;.&quot; version-vector))</pre></td></tr><tr><td class="docs"><p>Take a version, as either a string or a version vector, and returns a
version string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn as-version-string
  [version]
  (if (string? version) version (version-string version)))</pre></td></tr><tr><td class="docs"><p>Compare two version vectors.</p>
</td><td class="codes"><pre class="brush: clojure">(defn version-less
  [v1 v2]
  (loop [v1 (seq v1)
         v2 (seq v2)]
    (cond
      (and (not v1) (not v2)) false
      (and v1 (not v2)) false
      (or (and (not v1) v2) (&lt; (first v1) (first v2))) true
      (&gt; (first v1) (first v2)) false
      :else (recur (next v1) (next v2)))))</pre></td></tr><tr><td class="docs"><p>Does the version match a single version spec</p>
</td><td class="codes"><pre class="brush: clojure">(defn- version-matches-version?
  [version spec-version]
  (loop [v1 (seq version)
         v2 (seq spec-version)]
    (cond
      (and (not v1) (not v2)) true
      (and v1 (not v2)) true
      (or (and (not v1) v2) (not= (first v1) (first v2))) false
      :else (recur (next v1) (next v2)))))</pre></td></tr><tr><td class="docs"><p>Predicate to test if a version matches a version spec. A version spec is a
   version, or two (possibly nil) versions in a vector, to specify a version
   range.</p>
</td><td class="codes"><pre class="brush: clojure">(defn version-matches?
  [version spec]
  (cond
    (number? (first spec)) (version-matches-version? version spec)
    (vector? spec) (let [[from to] spec]
                     (and (or (nil? from)
                              (not
                               (version-less version from)))
                          (or (nil? to)
                              (not
                               (version-less to version)))))
    (nil? spec) true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn version-spec-less
  [spec1 spec2]
  (cond
    (number? (first spec1)) (if (number? (first spec2))
                              (&gt; (count spec1) (count spec2))
                              true)
    (number? (first spec2)) false
    :else (let [[from1 to1] spec1
                [from2 to2] spec2]
            (and (not (version-less from1 from2))
                 (not (version-less to2 to1))
                 (not= spec1 spec2)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>